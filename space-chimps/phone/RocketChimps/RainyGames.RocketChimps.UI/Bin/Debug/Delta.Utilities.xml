<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Delta.Utilities</name>
    </assembly>
    <members>
        <member name="T:Delta.Utilities.Datatypes.Vector">
            <summary>
            Vector class, will be automatically merged with XNA, OpenTK and SlimDx
            vector classes by the build system for quick access and optimized code
            paths (as it turns out however it seems most of our own methods are
            faster than those from XNA, OpenTK or SlimDx, see results below in the
            VectorPerformance class or more importantly MatrixPerformance).
            </summary>
        </member>
        <member name="T:Delta.Utilities.ISaveLoadBinary">
            <summary>
            This interface allows saving and loading of an object into and from a
            byte data stream. For speed and simplicity the BinaryWriter and
            BinaryReader classes are used to save and load the bytes. This interface
            is usually used to save and load simple data types inside a larger
            structure (e.g. scene files, level files, model data, etc. all use
            Points, Rectangles, Vectors, Matrices, etc.).
            <para />
            Please note that some complex classes with safe loading processes will
            need an additional layer on top of BinaryLoader to make sure data can
            be loaded even if one of the contained ISaveLoadBinary data types is
            corrupt. Then the stream is advanced by the number of bytes used and
            the failed loading of the object is reported, but the rest works fine!
            <para />
            Please use Factory.Load and .Save or the Content.Get functionality to
            create and load classes using this interface. FileHelper.Load and
            FileHelper.Save are useful functions for this interface.
            </summary>
        </member>
        <member name="M:Delta.Utilities.ISaveLoadBinary.Save(System.IO.BinaryWriter)">
            <summary>
            Saves all necessary data of the object into a binary writer stream for
            the caller to use for saving (or sending over network).
            </summary>
            <param name="writer">BinaryWriter for the stream to write into</param>
        </member>
        <member name="M:Delta.Utilities.ISaveLoadBinary.Load(System.IO.BinaryReader)">
            <summary>
            Loads the object again from previously saved data.
            </summary>
            <param name="reader">BinaryReader for reading the data</param>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Vector.DataSize">
            <summary>
            Represents the size in bytes of a Vector (3 * 4 = 12 bytes).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Vector.Zero">
            <summary>
            Returns a Vector with every value set to 0
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Vector.Half">
            <summary>
            Returns a Vector with every value set to 0.5
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Vector.One">
            <summary>
            Returns a Vector with every value set to 1
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Vector.UnitX">
            <summary>
            Returns a unit vector on the X axis (1, 0, 0)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Vector.UnitY">
            <summary>
            Returns a unit vector on the Y axis (0, 1, 0)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Vector.UnitZ">
            <summary>
            Returns a unit vector on the Z axis (0, 0, 1)
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Add(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Add the components two vectors
            </summary>
            <param name="value1">Vector 1</param>
            <param name="value2">Vector 2</param>
            <returns>
            New vector with X, Y and Z added from value1 and value2.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Add(Delta.Utilities.Datatypes.Vector@,Delta.Utilities.Datatypes.Vector@,Delta.Utilities.Datatypes.Vector@)">
            <summary>
            Add the components two vectors
            </summary>
            <param name="value1">Vector 1</param>
            <param name="value2">Vector 2</param>
            <param name="result">
            New vector with X, Y and Z added from value1 and value2.
            </param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Subtract(Delta.Utilities.Datatypes.Vector@,Delta.Utilities.Datatypes.Vector@,Delta.Utilities.Datatypes.Vector@)">
            <summary>
            Subtract
            </summary>
            <param name="value1">Vector 1</param>
            <param name="value2">Vector 2</param>
            <param name="result">
            New vector with X, Y and Z value2 values subtracted from value1.
            </param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Multiply(Delta.Utilities.Datatypes.Vector,System.Single)">
            <summary>
            Multiply the components of a vector with the specified factor.
            </summary>
            <param name="scaleFactor">scale factor</param>
            <param name="value1">value 1</param>
            <returns>Multiplied vector</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Multiply(Delta.Utilities.Datatypes.Vector@,System.Single,Delta.Utilities.Datatypes.Vector@)">
            <summary>
            Multiply the components of a vector with the specified factor.
            </summary>
            <param name="value">Vector value</param>
            <param name="scaleFactor">scale factor</param>
            <param name="result">Multiplied vector</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Multiply(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Multiply the components of two vectors
            </summary>
            <param name="value1">value 1</param>
            <param name="value2">value 2</param>
            <returns>Multiplied vector</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Divide(Delta.Utilities.Datatypes.Vector@,System.Single,Delta.Utilities.Datatypes.Vector@)">
            <summary>
            Divide vector through a value
            </summary>
            <param name="value1">value 1</param>
            <param name="value2">value 2</param>
            <param name="result">Divided vector</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Negate(Delta.Utilities.Datatypes.Vector@,Delta.Utilities.Datatypes.Vector@)">
            <summary>
            Negate
            </summary>
            <param name="value">Vector value to negate</param>
            <param name="result">Negated vector</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Min(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Return minimum values from 2 vectors (x, y, and z are checked
            separately). If you use XNA, SlimDX or Delta's fallback code than a
            vector containing the smallest values will be returned.
            OpenTK would return the vector with the smallest DistanceSquared,
            which is wrong for us and won't be used!
            </summary>
            <param name="value1">value 1</param>
            <param name="value2">value 2</param>
            <returns>minimum values from 2 vectors</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Min(Delta.Utilities.Datatypes.Vector@,Delta.Utilities.Datatypes.Vector@,Delta.Utilities.Datatypes.Vector@)">
            <summary>
            Minimum
            </summary>
            <param name="result">result</param>
            <param name="value1">value 1</param>
            <param name="value2">value 2</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Max(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Return maximum values from 2 vectors (largest x, y and z values).
            If you use XNA, SlimDX or Delta's fallback code than a vector
            containing the largest values will be returned.
            OpenTK would return the vector with the biggest DistanceSquared,
            which is wrong for us and won't be used!
            </summary>
            <param name="value1">value 1</param>
            <param name="value2">value 2</param>
            <returns>maximum values from 2 vectors</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Max(Delta.Utilities.Datatypes.Vector@,Delta.Utilities.Datatypes.Vector@,Delta.Utilities.Datatypes.Vector@)">
            <summary>
            Maximum
            </summary>
            <param name="result">result</param>
            <param name="value1">value 1</param>
            <param name="value2">value 2</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Dot(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Dot product of 2 vectors, will return 1 if vectors are equal,
            and 0 if vectors are orthogonal (90 degrees) and -1 if vectors
            pointing into opposite directions.
            </summary>
            <param name="vector1">Vector 1</param>
            <param name="vector2">Vector 2</param>
            <returns>Dot product</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Dot(Delta.Utilities.Datatypes.Vector@,Delta.Utilities.Datatypes.Vector@,System.Single@)">
            <summary>
            Dot product of 2 vectors, will return 1 if vectors are equal,
            and 0 if vectors are orthogonal (90 degrees) and -1 if vectors
            pointing into opposite directions.
            </summary>
            <param name="vector1">Vector 1</param>
            <param name="vector2">Vector 2</param>
            <param name="result">Dot product</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Clamp(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Clamp. Computing the closest point in an bounding box to a point.
            Notice that if the point is already inside the box, then this code
            returns the original point.
            </summary>
            <param name="value1">Vector value to clamp</param>
            <param name="max">
            Maximum vector (each component is checked individually)
            </param>
            <param name="min">
            Minimum vector (each component is checked individually)
            </param>
            <returns>
            Clamped vector that has all components between min and max.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Clamp(Delta.Utilities.Datatypes.Vector@,Delta.Utilities.Datatypes.Vector@,Delta.Utilities.Datatypes.Vector@,Delta.Utilities.Datatypes.Vector@)">
            <summary>
            Clamp. Computing the closest point in an bounding box to a point.
            Notice that if the point is already inside the box, then this code
            returns the original point.
            </summary>
            <param name="value1">Vector value to clamp</param>
            <param name="max">
            Maximum vector (each component is checked individually)
            </param>
            <param name="min">
            Minimum vector (each component is checked individually)
            </param>
            <param name="result">
            Clamped vector that has all components between min and max.
            </param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Cross(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Cross product of vector1 and vector2. Please note that if your vectors
            are not normalized or they are not orthogonal to each other, you should
            normalize the result if it is used for other calculations requiring
            normalized vectors (e.g. camera code or for billboards).
            </summary>
            <param name="vector1">Vector 1</param>
            <param name="vector2">Vector 2</param>
            <returns>Cross product between vector 1 and 2</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Cross(Delta.Utilities.Datatypes.Vector@,Delta.Utilities.Datatypes.Vector@,Delta.Utilities.Datatypes.Vector@)">
            <summary>
            Cross product of vector1 and vector2. Please note that if your vectors
            are not normalized or they are not orthogonal to each other, you should
            normalize the result if it is used for other calculations requiring
            normalized vectors (e.g. camera code or for billboards).
            </summary>
            <param name="vector1">Vector 1</param>
            <param name="vector2">Vector 2</param>
            <param name="result">Cross product between vector 1 and 2</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Distance(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Distance between two points (DistanceSquared is faster)
            </summary>
            <param name="value1">Vector 1</param>
            <param name="value2">Vector 2</param>
            <returns>Distance between vectors</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Distance(Delta.Utilities.Datatypes.Vector@,Delta.Utilities.Datatypes.Vector@,System.Single@)">
            <summary>
            Distance between two points (DistanceSquared is faster)
            </summary>
            <param name="value1">Vector 1</param>
            <param name="value2">Vector 2</param>
            <param name="result">Distance between vectors</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.DistanceSquared(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Distance squared
            </summary>
            <param name="value1">Vector 1</param>
            <param name="value2">Vector 2</param>
            <returns>Squared distance between vectors</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.DistanceSquared(Delta.Utilities.Datatypes.Vector@,Delta.Utilities.Datatypes.Vector@,System.Single@)">
            <summary>
            Distance squared
            </summary>
            <param name="value1">Vector 1</param>
            <param name="value2">Vector 2</param>
            <param name="result">Squared distance between vectors</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Normalize(Delta.Utilities.Datatypes.Vector)">
            <summary>
            Normalize the given vector and return the normalized version of it.
            </summary>
            <param name="value">Vector to normalize</param>
            <returns>Normalized vector</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Normalize(Delta.Utilities.Datatypes.Vector@)">
            <summary>
            Normalize the given vector.
            </summary>
            <param name="value">
            Vector to normalize, will be normalized after calling this method.
            </param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.TransformNormal(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Matrix)">
            <summary>
            Transform normal (a Vector3 version of Transform, that won't use the
            translation part of the matrix).
            </summary>
            <param name="normal">Normal to transform</param>
            <param name="matrix">Matrix for the transformation</param>
            <returns>Transformed normal vector</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.TransformNormal(Delta.Utilities.Datatypes.Vector@,Delta.Utilities.Datatypes.Matrix@,Delta.Utilities.Datatypes.Vector@)">
            <summary>
            Transform normal (a Vector3 version of Transform, that won't use the
            translation part of the matrix).
            </summary>
            <param name="normal">
            The normal vector which will be transformed by the matrix.
            </param>
            <param name="matrix">
            The matrix used for transforming the provided vector.
            </param>
            <param name="result">The resulting transformed normal vector.</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Transform(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Matrix)">
            <summary>
            Transform the given vector by the matrix. Note: This method is slower
            than the ref version, which should be used for performance critical
            code!
            </summary>
            <param name="position">Position vector to transform</param>
            <param name="matrix">Matrix for the transformation</param>
            <returns>Transformed vector</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Transform(Delta.Utilities.Datatypes.Vector@,Delta.Utilities.Datatypes.Matrix@,Delta.Utilities.Datatypes.Vector@)">
            <summary>
            Transform the given vector by the matrix (faster ref version).
            </summary>
            <param name="position">Position vector to transform</param>
            <param name="matrix">Matrix for the transformation</param>
            <param name="result">Transformed vector</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.AngleBetweenVectors(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Angle between vectors in degrees.
            http://www.euclideanspace.com/maths/algebra/vectors/angleBetween/index.htm
            RadiansToDegrees(atan2(a.y,a.x) - atan2(b.y,b.x)) would only give
            you 0-180 degrees, but we want full 0-360 degrees with Acos :)
            <para />
            Note: If one of the vectors is zero the method we will return 0.0f.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>Angle between the two vectors in the range [0, 360]</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Lerp(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector,System.Single)">
            <summary>
            Performs a linear interpolation between two vectors. 
            </summary>
            <param name="value1">Vector 1</param>
            <param name="value2">Vector 2</param>
            <param name="amount">Interpolation amount</param>
            <returns>Interpolated vector between vector 1 and 2</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Lerp(Delta.Utilities.Datatypes.Vector@,Delta.Utilities.Datatypes.Vector@,System.Single,Delta.Utilities.Datatypes.Vector@)">
            <summary>
            Performs a linear interpolation between two vectors. 
            </summary>
            <param name="value1">Vector 1</param>
            <param name="value2">Vector 2</param>
            <param name="amount">Interpolation amount</param>
            <param name="result">Interpolated vector between vector 1 and 2</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.GetByIndex(Delta.Utilities.Datatypes.Vector@,System.Int32)">
            <summary>
            Get a vector side (X, Y or Z) by index (0, 1 or 2).
            </summary>
            <param name="index">
            Index, 0 for X, 1 for Y, 2 for Z, all other values will thrown an
            IndexOutOfRangeException
            </param>
            <param name="vec">Vector for the X, Y or Z values.</param>
            <exception cref="T:System.IndexOutOfRangeException">
            If index is outside of 0-2.
            </exception>
            <returns>X, Y or Z value depending on the index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">
            Throws index out of range exception if index is not 0, 1 or 2.
            </exception>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.FromString(System.String)">
            <summary>
            Convert a string to a Vector. The expected format is (x.x, y.y, z.z)
            </summary>
            <param name="vectorString">The string containing the values in the
            correct format.</param>
            <returns>Vector from string if possible, otherwise Zero</returns>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Vector.X">
            <summary>
            X coordinate. FieldOffset means that we use the defined float in our
            union vector and value 0 means the first float
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Vector.Y">
            <summary>
            Y coordinate. FieldOffset means that we use the defined float in our
            union vector and value 4 means the second float (4 bytes per float).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Vector.Z">
            <summary>
            Z coordinate. FieldOffset means that we use the defined float in our
            union vector and value 8 means the third float (4 bytes per float).
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.#ctor(Delta.Utilities.Datatypes.Point,System.Single)">
            <summary>
            Create vector
            </summary>
            <param name="value">value</param>
            <param name="z">z</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Create vector
            </summary>
            <param name="setX">Set x</param>
            <param name="setY">Set y</param>
            <param name="setZ">Set z</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.#ctor(System.IO.BinaryReader)">
            <summary>
            Create vector
            </summary>
            <param name="reader">reader</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Equals(Delta.Utilities.Datatypes.Vector)">
            <summary>
            Equals
            </summary>
            <param name="other">Other</param>
            <returns>Value indicating the equality of two vectors</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Load(System.IO.BinaryReader)">
            <summary>
            Load all vector values from a stream (reads 12 bytes, 3 floats)
            </summary>
            <param name="reader">The stream that will be used.</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Save(System.IO.BinaryWriter)">
            <summary>
            Saves this vector to a stream (12 bytes, 3 floats).
            </summary>
            <param name="writer">The stream that will be used.</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.op_Equality(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Check for equality
            </summary>
            <param name="value1">Vector 1</param>
            <param name="value2">Vector 2</param>
            <returns>True if the vectors are equal</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.op_Inequality(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Check for inequality
            </summary>
            <param name="value1">Vector 1</param>
            <param name="value2">Vector 2</param>
            <returns>True if the vectors are not equal.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.op_Addition(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Operator for addition
            </summary>
            <param name="value1">Vector 1</param>
            <param name="value2">Vector 2</param>
            <returns>
            New vector with X, Y and Z values added from value1 and value2.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.op_UnaryNegation(Delta.Utilities.Datatypes.Vector)">
            <summary>
            Operator for unary negation
            </summary>
            <param name="value">Vector value</param>
            <returns>Negated vector</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.op_Subtraction(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Operator for subtraction
            </summary>
            <param name="value1">Vector 1</param>
            <param name="value2">Vector 2</param>
            <returns>X, Y and Z of value2 subtracted from value1</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.op_Multiply(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Operator for multiplication
            </summary>
            <param name="value1">Vector 1</param>
            <param name="value2">Vector 2</param>
            <returns>Dot product, which is the multiplication result</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.op_Multiply(Delta.Utilities.Datatypes.Vector,System.Single)">
            <summary>
            Operator for multiplication
            </summary>
            <param name="value">Vector value</param>
            <param name="scaleFactor">Scale factor</param>
            <returns>Multiplication result</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.op_Multiply(System.Single,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Operator for multiplication
            </summary>
            <param name="scaleFactor">Scale factor</param>
            <param name="value">Vector value</param>
            <returns>Multiplication result</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.op_Multiply(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Matrix)">
            <summary>
            Operator for multiplication
            </summary>
            <param name="value">Vector value</param>
            <param name="transformMatrix">Transformation matrix</param>
            <returns>Multiplication result</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.op_Division(Delta.Utilities.Datatypes.Vector,System.Single)">
            <summary>
            Operator for division
            </summary>
            <param name="value">Vector value</param>
            <param name="scaleFactor">Scale factor</param>
            <returns>Division result</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.op_Division(System.Single,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Op multiply
            </summary>
            <param name="scaleFactor">Scale factor</param>
            <param name="value">Vector value</param>
            <returns>Division result</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Normalize">
            <summary>
            Normalize this vector.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.GetByIndex(System.Int32)">
            <summary>
            Get a vector side (X, Y or Z) by index (0, 1 or 2).
            </summary>
            <param name="index">
            Index, 0 for X, 1 for Y, 2 for Z, all other values will thrown an
            IndexOutOfRangeException
            </param>
            <exception cref="T:System.IndexOutOfRangeException">
            If index is outside of 0-2.
            </exception>
            <returns>X, Y or Z value depending on the index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">Unsupported index</exception>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.GetHashCode">
            <summary>
            Get hash code
            </summary>
            <returns>Hash code from X, Y and Z</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.NearlyEquals(Delta.Utilities.Datatypes.Vector,System.Single)">
            <summary>
            Equals
            </summary>
            <param name="other">Other</param>
            <param name="epsilon">Epsilon difference we allow for
            floating imprecission</param>
            <returns>Value indicating the equality of two vectors</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.Equals(System.Object)">
            <summary>
            Equals
            </summary>
            <param name="obj">Object to check against</param>
            <returns>True if obj is a Vector and is equal to this vector.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.ToPoint">
            <summary>
            Creates a Point from the X and Y values
            </summary>
            <returns>Point created from X and Y values of this vector.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.ToArray">
            <summary>
            Returns the vector as float array (X, Y, Z)
            </summary>
            <returns>
            Array with just X, Y and Z float values created from this Vector.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.ToString">
            <summary>
            To string, also used for the old ToColladaString method, this
            is precise enough to be used for saving collada files.
            </summary>
            <returns>
            Text string with the vector in braces, e.g. "(0.4, 2.8)"
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.ToString(System.String,System.String)">
            <summary>
            To string, also used for the old ToColladaString method, this
            is precise enough to be used for saving collada files.
            </summary>
            <param name="openBrace">Add open brace string, e.g. "("</param>
            <param name="closeBrace">Add close brace string, e.g. ")"</param>
            <returns>String with X, Y and Z values with the format 0.0000</returns>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Vector.XProperty">
            <summary>
            Property-wrapper for using the X field in the editor.
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Vector.YProperty">
            <summary>
            Property-wrapper for using the Y field in the editor
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Vector.ZProperty">
            <summary>
            Property-wrapper for using the Z field in the editor
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Vector.Length">
            <summary>
            The length of the vector. This takes the square root and thus is
            slower than using LengthSquared.
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Vector.LengthSquared">
            <summary>
            Length squared, much faster than using Length because we do not
            have to take the square root.
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Vector.IsNormalized">
            <summary>
            Is normalized? Will return true if the vector length is 1.0
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Vector.VectorTests">
            <summary>
            Tests
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorTests.SizeOf">
            <summary>
            Checks if the size of Point is exactly 8 bytes (2 floats: X and Y)
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorTests.Length">
            <summary>
            Length
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorTests.LengthSquared">
            <summary>
            Length squared
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorTests.AngleBetweenVectors">
            <summary>
            Angle between vectors
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorTests.NearlyEqual">
            <summary>
            Nearly equal
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorTests.ToPoint">
            <summary>
            To string
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorTests.Equality">
            <summary>
            Equality
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorTests.Addition">
            <summary>
            Addition
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorTests.Substraction">
            <summary>
            Substraction
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorTests.Multiplication">
            <summary>
            Multiplication
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorTests.Division">
            <summary>
            Multiplication
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorTests.Min">
            <summary>
            Minimum
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorTests.Max">
            <summary>
            Maximum
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorTests.Dot">
            <summary>
            Dot
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorTests.Clamp">
            <summary>
            Clamp
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorTests.Cross">
            <summary>
            Cross
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorTests.Distance">
            <summary>
            Distance
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorTests.DistanceSquared">
            <summary>
            Distance squared
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorTests.Normalize">
            <summary>
            Normalize
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorTests.TransformNormal">
            <summary>
            Transform normal
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorTests.VectorToString">
            <summary>
            To string
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Vector.VectorPerformance">
            <summary>
            Vector performance class to figure out performance differences between
            different implementations of Vector methods available on different
            platforms and in different frameworks.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorPerformance.TestLength">
            <summary>
            Test the length property of the Vector class.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorPerformance.TestDot">
            <summary>
            Test the dot method of the vector struct.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorPerformance.TestCross">
            <summary>
            Test the cross method of the vector struct.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorPerformance.TestDistance">
            <summary>
            Test the distance method of the vector struct.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorPerformance.TestNormalize">
            <summary>
            Test the normalize method of the vector struct.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorPerformance.TestTransformNormal">
            <summary>
            Test the transform normal method of the vector struct.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Vector.VectorPerformance.ExecuteAllForPerformanceOverview">
            <summary>
            Execute all vector tests for a performance overview.
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.BoundingBox">
            <summary>
            Bounding box helper structure, basically just contains a min and max
            vector for the bounding. Can also be used to calculate a BoundingSphere.
            <para />
            Little ASCII art for the BoundingBox (Note: Does not translate well into
            the documentation, see the BoundingBox.cs file for details):
                    o--------o                           
                   /:       /|          Y (TOP)          
                  / :      / |          |                
                 o--------M  |          |                
                 |  :     |  |          |                
                 |  m.....|..o          o------X (RIGHT) 
                 | '      | /          /                 
                 |'       |/          /                  
                 o--------o          Z (FRONT)           
            
            m is the Min component, M is the Max component
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Advanced.IContains">
            <summary>
            Interface IContains checks whether a Delta.Utilities.Datatypes 
            contains another datatype.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.IContains.Contains(Delta.Utilities.Datatypes.BoundingBox)">
            <summary>
            Determines whether a Box contains another box or sphere
            </summary>
            <param name="box">Box to check against</param>
            <returns>Containment type (fully, partial or none)</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.IContains.Contains(Delta.Utilities.Datatypes.BoundingSphere)">
            <summary>
            Determines whether a sphere contains another box or sphere
            </summary>
            <param name="sphere">Sphere to check against</param>
            <returns>Containment type (fully, partial or none)</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.IContains.Contains(Delta.Utilities.Datatypes.Vector)">
            <summary>
            Checks whether a box or sphere contains a vector position.
            </summary>
            <param name="position">Position to check against</param>
            <returns>Either the position is inside the box or sphere (
            <see cref="F:Delta.Utilities.Datatypes.Advanced.ContainmentType.Fully"/> is returned), or not (then
            <see cref="F:Delta.Utilities.Datatypes.Advanced.ContainmentType.None"/> is returned).</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingBox.Create(System.Collections.Generic.IList{Delta.Utilities.Datatypes.Vector})">
            <summary>
            Creates a bounding box around the given positions.
            </summary>
            <param name="setPositions">Set positions</param>
            <returns>The created bounding box</returns>
        </member>
        <member name="F:Delta.Utilities.Datatypes.BoundingBox.Min">
            <summary>
            Min values for this bounding box
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.BoundingBox.Max">
            <summary>
            Max values for this bounding box
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingBox.#ctor(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Create bounding box
            </summary>
            <param name="setMax">SetMax</param>
            <param name="setMin">SetMin</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingBox.Contains(Delta.Utilities.Datatypes.BoundingBox)">
            <summary>
            Determines whether a Box contains another box
            </summary>
            <param name="box">Box to check against</param>
            <returns>Containment type (fully, partial or none)</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingBox.Contains(Delta.Utilities.Datatypes.BoundingSphere)">
            <summary>
            Determines whether a box contains another sphere
            </summary>
            <param name="sphere">The sphere.</param>
            <returns>Containment type (fully, partial or none)</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingBox.Contains(Delta.Utilities.Datatypes.Vector)">
            <summary>
            Checks whether this box contains a vector position.
            </summary>
            <param name="position">Position to check against</param>
            <returns>Either the position is inside the box or sphere (
            <see cref="F:Delta.Utilities.Datatypes.Advanced.ContainmentType.Fully"/> is returned), or not (then
            <see cref="F:Delta.Utilities.Datatypes.Advanced.ContainmentType.None"/> is returned).</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingBox.Equals(Delta.Utilities.Datatypes.BoundingBox)">
            <summary>
            Equals
            </summary>
            <param name="other">Other</param>
            <returns>Value indicating the equality of two vectors</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingBox.Load(System.IO.BinaryReader)">
            <summary>
            Load the BoundingBox values (Min and Max vectors) from a stream.
            </summary>
            <param name="reader">The stream that will be used.</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingBox.Save(System.IO.BinaryWriter)">
            <summary>
            Saves the BoundingBox (Min and Max vectors) to a stream.
            </summary>
            <param name="writer">The stream that will be used.</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingBox.op_Equality(Delta.Utilities.Datatypes.BoundingBox,Delta.Utilities.Datatypes.BoundingBox)">
            <summary>
            Check for equality
            </summary>
            <param name="value1">Value 1</param>
            <param name="value2">Value 2</param>
            <returns>True if the values are equal, false otherwise</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingBox.op_Inequality(Delta.Utilities.Datatypes.BoundingBox,Delta.Utilities.Datatypes.BoundingBox)">
            <summary>
            Check for inequality
            </summary>
            <param name="value1">Value 1</param>
            <param name="value2">Value 2</param>
            <returns>True if the values are not equal, false if they are</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingBox.Equals(System.Object)">
            <summary>
            Check if an object is equal to this bounding box.
            </summary>
            <param name="obj">Object to compare</param>
            <returns>True if obj is a boundbing box and equals to this</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingBox.GetHashCode">
            <summary>
            Get hash code from min and max.
            </summary>
            <returns>Hash code</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingBox.Merge(Delta.Utilities.Datatypes.BoundingBox)">
            <summary>
            Merge two bounding boxes together building a bigger box.
            </summary>
            <param name="otherBox">Other box</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingBox.ToBoundingSphere">
            <summary>
            Create bounding sphere from Min and Max values of this box.
            </summary>
            <returns>BoundingSphere created from this bounding box size.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingBox.ToString">
            <summary>
            To string
            </summary>
            <returns>String</returns>
        </member>
        <member name="P:Delta.Utilities.Datatypes.BoundingBox.Center">
            <summary>
            Gets the center point of this bounding box.
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.BoundingBox.BoundingBoxTests">
            <summary>
            Tests
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingBox.BoundingBoxTests.Merge">
            <summary>
            Merge
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingBox.BoundingBoxTests.Create">
            <summary>
            Create
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingBox.BoundingBoxTests.Contains">
            <summary>
            ContainsFully
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingBox.BoundingBoxTests.ToBoundingSphere">
            <summary>
            Test Bounding spheres 
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingBox.BoundingBoxTests.Equality">
            <summary>
            Equality
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingBox.BoundingBoxTests.SaveAndLoad">
            <summary>
            Test to save and load spheres into a binary stream
            </summary>
        </member>
        <member name="T:Delta.Utilities.Helpers.FileHelper">
            <summary>
            File helper class to get text lines, number of text lines, etc. This
            extends the existing File and Path functionality of .NET.
            <para />
            This class also abstracts the use of File.Exists and File.Open for
            platforms like WP7 where those calls are not allowed (instead the
            IsolatedStorage classes are used, which just allow access to the
            current directory, which is all we need in the engine internally).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.FileHelper.FileExtensionSeperator">
            <summary>
            The typical file extension separator is just a dot: .
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.FileHelper.FolderSeparator">
            <summary>
            Represents the separator for folders in file paths on microsoft
            platforms.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.FileHelper.AlternateFolderSeparator">
            <summary>
            Represents the separator for folders in file paths on Unix platforms.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.FileHelper.AllFolderSeparators">
            <summary>
            Both folder separators together in one char array, used for GetFilename
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.Exists(System.String)">
            <summary>
            Check if the file exists.
            On WP7 this is looking for the file in the Isolated Storage.
            </summary>
            <param name="filename">Filename</param>
            <returns>filename</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.Copy(System.String,System.String)">
            <summary>
            Copy the source file to the destination file.
            Note: this method overwrites existing destination files!
            </summary>
            <param name="sourceFile">Source filepath.</param>
            <param name="destinationFile">Destination Filepath.</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.Move(System.String,System.String)">
            <summary>
            Move the source file to the destination file.
            </summary>
            <param name="sourceFile">Source filepath.</param>
            <param name="destinationFile">Destination filepath.</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.Open(System.String)">
            <summary>
            Opens a the given file (will not create it if it doesn't exists) on
            platforms where this is possible.
            <para />
            Note: The file-mode is "Open" only and the file-access + file-share
            mode is "Read".
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Open, will use File.Open on platforms where this is possible.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.Rename(System.String,System.String)">
            <summary>
            Rename the file.
            </summary>
            <param name="sourceFile">Path to the file to rename.</param>
            <param name="destFile">Path to the file after rename.</param>
            <returns>True if succeeded otherwise false.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.GetFilename(System.String)">
            <summary>
            Extracts filename from full path+filename, but don't cuts off the
            extension. Can be also used to cut of directories from a path (only
            last one will remain).
            </summary>
            <returns>filename</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.GetFilename(System.String,System.String@)">
            <summary>
            Extracts filename from full path+filename, but don't cuts off the
            extension. Can be also used to cut of directories from a path (only
            last one will remain).
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.GetFilename(System.String,System.Boolean)">
            <summary>
            Extracts filename from full path+filename, cuts of extension
            if cutExtension is true. Can be also used to cut of directories
            from a path (only last one will remain).
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.IsFilenameOnly(System.String)">
            <summary>
            Is filename only
            </summary>
            <param name="anyFilePath">Any file path</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.HasFileNoExtension(System.String)">
            <summary>
            Has a filename no extension
            </summary>
            <param name="anyFilePath">Any file path</param>
            <returns>True if the given file path has no extension.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.GetDirectoryPath(System.String)">
            <summary>
            Get directory of path+File, if only a path is given we will cut off
            the last sub path!
            </summary>
            <param name="filePath">File path</param>
            <returns>Directory path</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.GetDirectoryPath(System.String,System.Int32)">
            <summary>
            Get directory sub path of the given path or file path.
            (-> e.g. "FileHelper.GetDirectoryPath(@"C:\Ab\cde\App.exe", 2)" will
            return "C:\Ab")
            </summary>
            <param name="filePath">File path</param>
            <param name="jumpbackCount">
            The number of folders it should be "jumped" back.
            </param>
            <returns>Directory path</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.GetFirstDirectoryName(System.String)">
            <summary>
            Get first directory of path or file path! Returns "c:" for "C:\test.x"
            or "bla" for "bla\blub\honk.txt".
            </summary>
            <param name="pathFile">Path file to search</param>
            <returns>First found directory part</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.GetLastDirectoryName(System.String)">
            <summary>
            Get last directory of path+File, if only a path is given we will cut
            off the last sub path! Returns "Models" for "C:\aoeus\Models\test.x".
            Warning: If you just use a path, the results might be different from
            what you want (use GetFilename instead): ""C:\aoeus\Models" will return
            "aoeus" and not "Models".
            </summary>
            <param name="pathFile">Path file to search</param>
            <returns>Last found directory</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.RemoveFirstDirectory(System.String)">
            <summary>
            Remove first directory of path if one exists. "maps\\mymaps\\hehe.map"
            becomes "mymaps\\hehe.map". Also used to cut first folder off,
            especially useful for paths. e.g. "maps\\test" becomes "test".
            </summary>
            <param name="path">Path</param>
            <returns>Reduced directory path</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.CutExtension(System.String)">
            <summary>
            Cut of extension, e.g. "hi.txt" becomes "hi"
            </summary>
            <param name="file">File</param>
            <returns>Filename without extension</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.GetExtension(System.String)">
            <summary>
            Get extension (whatever is behind that '.'), e.g. "test.bmp" will
            return "bmp". Only a filename will return "", e.g. "Test" returns ""
            </summary>
            <param name="file">File</param>
            <returns>Returns the extension string of the file.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.TryToUseRelativePath(System.String)">
            <summary>
            Helper function for saving, we check if path starts with same as
            our application. If so, better use relative path, then we can use
            them even if application is moved or copied over network!
            </summary>
            <param name="fullPath">Full path to check against</param>
            <returns>Relative path starting at fullPath if possible</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.TryToUseRelativePath(System.String,System.String)">
            <summary>
            Helper function for saving, we check if path starts with same as
            our application. If so, better use relative path, then we can use
            them even if application is moved or copied over network!
            </summary>
            <param name="pathToCheckFrom">Path to check from (e.g. from our
            application) and the origin for the relative path that is returned
            </param>
            <param name="fullPath">Full path to check against</param>
            <returns>Relative path starting at fullPath if possible</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.TryToUseAbsolutePath(System.String,System.String)">
            <summary>
            Helper method to use an absolute path. If the path is already absolute
            nothing will change, but if the path is relative the basePath is added.
            </summary>
            <param name="basePath">Path to check from</param>
            <param name="possibleFullPath">Full or relative path to check.</param>
            <returns>Absolute path to the file</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.IsDirectSubFolder(System.String,System.String)">
            <summary>
            Check if a folder is a direct sub folder of a main folder.
            True is only returned if this is a direct sub folder, not if
            it is some sub folder few levels below.
            </summary>
            <param name="mainFolder">MainFolder</param>
            <param name="subFolder">SubFolder</param>
            <returns>
            True if the subFolder is a direct sub folder of mainFolder.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.CleanupPath(System.String)">
            <summary>
            Cleans up the given path, so that it's in an homogenous unix/web path.
            E.g. ".\MyPath\With/Subfolder" => "My/Path/With/Subfolder"
            Also used by our whole content pipeline to make searching easier.
            </summary>
            <param name="anyPath">Any path</param>
            <returns>String</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.CleanupPath(System.String,System.Boolean)">
            <summary>
            Cleans up the given path, so that it's in an homogenous unix/web path.
            E.g. ".\MyPath\With/Subfolder" => "My/Path/With/Subfolder"
            Also used by our whole content pipeline to make searching easier.
            </summary>
            <param name="anyPath">Any path</param>
            <param name="useUnixFormat">Use linux file format? This means
            using normal slashes instead of backslashes like in Windows</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.GetRelativeFilePath(System.String,System.String)">
            <summary>
            Get relative file path of a given absolute file path based on basePath.
            If the basePath and the absoluteFilePath share something in common this
            method will try to remove the common part (e.g. "c:\code\Delta\bla"
            in the basePath "c:\code" will be reduced to "Delta\bla" or in the
            basePath "c:\code\DeltaEngine" will be "..\Delta\bla").
            </summary>
            <param name="absoluteFilePath">
            Absolute file path, might already be relative or even be on a different
            drive, then it will just be returned.
            </param>
            <param name="basePath">Base path</param>
            <returns>Relative path if possible</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.TrimPath(System.String)">
            <summary>
            Removes all unnecessary relative path fragments and will return a
            trimmed path. Useful in combination with GetRelativeFilePath.
            <para />
            Example: "C:\Path\SubPath1\..\SubPath2\file.exe" will become to
            "C:\Path\SubPath2\file.exe".
            </summary>
            <param name="filePath">Path to be shortened if possible.</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.GetFileSize(System.String)">
            <summary>
            Get file size. Returns 0 if file does not exists instead of throwing
            an exception. Else it returns file size as a long number.
            </summary>
            <param name="filename">Filename</param>
            <returns>Long</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.GetLines(System.String)">
            <summary>
            Returns the text lines we got in a file.
            </summary>
            <param name="filename">Filename</param>
            <returns>
            All text lines from the file or null if no file was found.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.GetLines(System.String,System.Text.Encoding)">
            <summary>
            Returns the text lines we got in a file. Will not crash! If file does
            not exist, we will just return null, same for an unreadable file.
            </summary>
            <param name="filename">Filename</param>
            <param name="textEncoding">Text encoding</param>
            <returns>
            All text lines from the file or null if no file was found.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.GetText(System.String)">
            <summary>
            Gets all the text of a file (e.g. if you just want to the text of a
            text file). Will not crash! If file does not exist, we will just return
            an empty string. If file is somehow unreadable, we will log an warning
            (because this shouldn't happen, we should always open files in a way
            that allows reading) and return an empty string too.
            </summary>
            <param name="filename">Filename for the file to load</param>
            <returns>String with all the text from the file</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.GetText(System.String,System.String@)">
            <summary>
            Gets all the text of a file (e.g. if you just want to the text of a
            text file). Will not crash! If file does not exist, we will just return
            an empty string. If file is somehow unreadable, we will log an warning
            (because this shouldn't happen, we should always open files in a way
            that allows reading) and return an empty string too.
            </summary>
            <param name="filename">Filename for the file to load</param>
            <returns>String with all the text from the file</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.PathCombine(System.String,System.String)">
            <summary>
            Path combining methods to ensure each path is compatible. This is
            more powerful than Path.Combine and handles all platform cases and
            should be used if you need your code to run on all platforms.
            </summary>
            <param name="path1">Path 1</param>
            <param name="path2">Path 2</param>
            <returns>Combined path</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.GetLinesCount(System.String)">
            <summary>
            Returns the number of text lines we got in a text file.
            </summary>
            <param name="filename">Filename</param>
            <returns>Number of lines in the given text file.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.CreateTextFile(System.String,System.String,System.Text.Encoding)">
            <summary>
            Create text file or overwrite an existing file. Will store all the
            given text into it with the optional Encoding (default is UTF8).
            </summary>
            <param name="filename">Filename to save text to</param>
            <param name="textForFile">Text to store in the new file</param>
            <param name="encoding">
            Encoding to use for file, by default UTF8
            </param>
            <exception cref="T:System.IO.IOException">
            Will be thrown if file already exists and could not be overwritten or
            if creating the file failed for other reasons (e.g. unable to write).
            </exception>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.CreateTextFile(System.String,System.String[],System.Text.Encoding)">
            <summary>
            Create text file. Will create a new file and store all the given text
            lines into it with the optional Encoding (default is UTF8).
            </summary>
            <param name="filename">Filename to save text to</param>
            <param name="textLines">Text lines to store</param>
            <param name="encoding">
            Encoding to use for file, by default UTF8
            </param>
            <exception cref="T:System.IO.IOException">
            Will be thrown if file already exists and could not be overwritten or
            if creating the file failed for other reasons (e.g. unable to write).
            </exception>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.CreateBinaryFile(System.String,System.Byte[])">
            <summary>
            Helper method to create a binary file with the given byte data array.
            /// <para />
            Note: If the file exists, it will just be overwritten. The path to
            the filename must exist however, else this will throw an exception.
            Also if writing this file is not possible an access denied IOException
            will be thrown.
            </summary>
            <param name="filename">Filename to save binary data to</param>
            <param name="binaryData">The data to save</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.CreateBinaryFile(System.String,System.IO.MemoryStream)">
            <summary>
            Helper method to create a binary file with the given memory stream.
            <para />
            Note: If the file exists, it will just be overwritten. The path to
            the filename must exist however, else this will throw an exception.
            Also if writing this file is not possible an access denied IOException
            will be thrown.
            </summary>
            <param name="filename">Filename to save binary data to</param>
            <param name="data">The data to save</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.GetBytes(System.String)">
            <summary>
            Helper method to grab all bytes of a binary file and then close it
            again. Will not crash! If file does not exist, we will just return
            an empty array. If file is somehow unreadable, we will log an warning
            (because this shouldn't happen, we should always open files in a way
            that allows reading) and return an empty array too.
            </summary>
            <param name="filename">File to load</param>
            <returns>Array of bytes from the file</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.SafeDelete(System.String)">
            <summary>
            Safely deletes a file.
            </summary>
            <param name="filePath">File to delete</param>
            <returns>True if file was deleted or did not exist anymore</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.SafeDeleteFiles(System.String,System.String,System.Boolean)">
            <summary>
            Safely delete the files matching the search pattern in the base
            directory and if wanted recursive in sub directories as well.
            </summary>
            <param name="basePath">Base Path</param>
            <param name="recursive">Recursive</param>
            <param name="searchPattern">Search Pattern</param>
            <returns>True if deleting the files worked (no matter if it actually
            deleted something or not), false otherwise (warnings for failed file
            deletes will be outputted via the SafeDelete method)</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.CheckIfFileIsNewer(System.String,System.String)">
            <summary>
            Check if file is newer. Not the fastest method ever as it needs
            to load both files and compare their last write times.
            </summary>
            <param name="fileToCheckIfNewer">File to check if newer</param>
            <param name="originalFile">Original File</param>
            <returns>True if the file is newer than the original.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.ExistsPath(System.String)">
            <summary>
            Exist path, will check if a full file path or just a directory path
            exists. This is different from the DirectoryHelper.Exists method,
            which just checks if a directory path exists (this one checks for
            files too if a valid extension for a file path was given).
            </summary>
            <param name="path">A path from a file or a directory</param>
            <returns>True if the path was found as a file or directory</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.CutPath(System.String,System.String)">
            <summary>
            Cuts off the given "cut path" completely from the given filePath.
            </summary>
            <param name="filePath">
            Any absolute or relative file or folder path.
            </param>
            <param name="pathToCutOff">
            The path (or folder) which should be cut off completely.
            </param>
            <returns>FilePath without pathToCutOff</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.CompareFiles(System.String,System.String)">
            <summary>
            Compare two files with the help of the MD5-checksum
            </summary>
            <param name="fileName1">Filename 1</param>
            <param name="fileName2">Filename 2</param>
            <returns>True if both file contents are the same</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.AppendTextToFile(System.String,System.String)">
            <summary>
            Append text to file, does the same as File.AppendAllText, but it
            won't crash and can handle already open files :)
            </summary>
            <param name="filename">Filename</param>
            <param name="text">Text</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.AppendTextToFile(System.String,System.String,System.Int32)">
            <summary>
            Append text to file, does the same as File.AppendAllText, but it
            won't crash and can handle already open files :) This overload checks
            if the existing data is more than maxTextFileSizeBeforeAppending
            already, then remove data from the beginning before appending.
            </summary>
            <param name="filename">Filename</param>
            <param name="maxTextFileSizeBeforeAppending">Max Text File Size before
            appending</param>
            <param name="text">Text</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.CheckIfFileExistsAndIsNotWrittenTo(System.String)">
            <summary>
            Check if file exists and is not written to recently. This is mostly
            used for update checks to see if we can assume this file is complete
            and we can now open it, etc. (e.g. used in the RestartTool).
            </summary>
            <param name="filename">File to check</param>
            <returns>
            True if the file exists and was not written to recently.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.OpenFileAsStream(System.String)">
            <summary>
            Open file as stream. Make sure the filePath is in the correct format
            for this platform!
            </summary>
            <param name="filePath">File path</param>
            <returns>Stream of the opened file for reading</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.Load``1(System.String,``0)">
            <summary>
            Helper method to load data into any ISaveLoadBinary object just with
            a given filePath. This helps reducing writing the same code over and
            over again in each content class or ISaveLoadBinary data class.
            </summary>
            <typeparam name="T">Type to load into, must be derived from
            ISaveLoadBinary</typeparam>
            <param name="filePath">File path to load the binary data from</param>
            <param name="objectToLoad">Object to load all binary data into</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.Save``1(System.String,``0)">
            <summary>
            Helper method to save data from any ISaveLoadBinary object into a
            given filePath. This helps reducing writing the same code over and
            over again in each content class or ISaveLoadBinary data class.
            </summary>
            <typeparam name="T">Type to save into, must be derived from
            ISaveLoadBinary</typeparam>
            <param name="filePath">File path to save the binary data to</param>
            <param name="objectToSave">Object we want to save</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.GetFileDate(System.String)">
            <summary>
            Get file date via File.GetLastWriteTime if supported by this platform!
            </summary>
            <param name="filePath">File path to check</param>
            <returns>Last time this file was written to.</returns>
        </member>
        <member name="F:Delta.Utilities.Helpers.FileHelper.CompareFilesCallback">
            <summary>
            Callback for comparing files. Some platforms won't support this as
            efficiently as others. Normally MD5 Checksums are used.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.FileHelper.FileNotWrittenToCallback">
            <summary>
            Delegate for CheckIfFileExistsAndIsNotWrittenTo.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.#cctor">
            <summary>
            Static FileHelper constructor to setup all the callbacks used here!
            </summary>
        </member>
        <member name="T:Delta.Utilities.Helpers.FileHelper.CompareFilesDelegate">
            <summary>
            Compare two files with the help of the MD5-checksum
            </summary>
            <param name="fileName1">Filename 1</param>
            <param name="fileName2">Filename 2</param>
            <returns>True if both file contents are the same</returns>
        </member>
        <member name="T:Delta.Utilities.Helpers.FileHelper.FileNotWrittenToDelegate">
            <summary>
            Check if file exists and is not written to recently. This is mostly
            used for update checks to see if we can assume this file is complete
            and we can now open it, etc. (e.g. used in the RestartTool).
            </summary>
            <param name="filename">File to check</param>
            <returns>
            True if the file exists and was not written to recently.
            </returns>
        </member>
        <member name="T:Delta.Utilities.Helpers.FileHelper.FileHelperTests">
            <summary>
            Test file helper
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.FileHelperTests.TestCreateTextFileAndSafeDelete">
            <summary>
            Test create text file and safe delete
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.FileHelperTests.TestCompareFiles">
            <summary>
            Test check if file is newer. Note: Too slow for a dynamic unit test.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.FileHelperTests.TestPathCombine">
            <summary>
            Test to see if our path combine methods correctly output the right path
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.FileHelperTests.OpenFileAsStream">
            <summary>
            Test OpenFileAsStream
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.FileHelperTests.SafeDeleteFiles">
            <summary>
            Test SafeDeleteFiles with some xml documentation files in the
            current directory.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.FileHelperTests.TrimPath">
            <summary>
            Trim path
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.FileHelperTests.FileExists">
            <summary>
            Test the File Exists method.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.FileHelperTests.TestCutAndGetExtension">
            <summary>
            Test cut and get extension
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.FileHelperTests.GetFilename">
            <summary>
            Get filename
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.FileHelperTests.IsFilenameOnly">
            <summary>
            Is filename only
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.FileHelperTests.TestCheckIfFileIsNewer">
            <summary>
            Test check if file is newer
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.FileHelperTests.GetFirstDirectoryName">
            <summary>
            Get first directory name part.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.FileHelperTests.GetLastDirectoryName">
            <summary>
            Get last directory name part.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.FileHelperTests.GetDirectoryPath">
            <summary>
            Get directory path
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.FileHelperTests.CutPath">
            <summary>
            Cut path
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.FileHelper.FileHelperTests.GetRelativeFilePath">
            <summary>
            Test the GetRelativeFilePath method with a couple of different paths.
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Advanced.HorizontalAlignment">
            <summary>
            The available modes to align a text horizontally.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.HorizontalAlignment.None">
            <summary>
            Displays the object unaligned to their original specified position.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.HorizontalAlignment.Left">
            <summary>
            Displays the object aligned to the left side.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.HorizontalAlignment.Centered">
            <summary>
            Displays the object horizontally centered.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.HorizontalAlignment.Right">
            <summary>
            Displays the object aligned to the right side.
            </summary>
        </member>
        <member name="T:Delta.Utilities.Log">
            <summary>
            Log, handles all the message logging and storing the messages in an
            extra file which helps for later tracking and fixing bugs. Some extra
            functionality is provided by Delta.Engine, which sets up the log server
            to send log messages to a log server if specified in the application
            settings. Usually logging happens to the console and a log file.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.FileExtension">
            <summary>
            The default extension for all our log files. Note 2011-04-06: Changed
            to .txt to make it easier to open by end users (.log is not longer
            used and has no special behavior anymore).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.MaxLogFileSize">
            <summary>
            The maximum file size for a log file is 10 MB, if we go above that
            (e.g. if too much info is written every frame), then we cut the file
            in half (5 MB) and append from there. This way we have both the
            first 5 MB of the application run and the last log entries as well.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.MaxArchiveLogFileSize">
            <summary>
            The maximum size for log archive files is 20 MB, if we go above that,
            we will remove data from the beginning before appending new stuff at
            the end (the FileHelper.AppendTextToFile handles this all for us).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.DefaultLogName">
            <summary>
            Default log name. Currently set to Engine in case something is logged
            in DynamicBase or Factory, will be overwritten in Application.Start!
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.MaxConsoleWritesPerSecond">
            <summary>
            Maximum of Console.WriteLines we allow because of poor WriteLine
            performance in debug mode with debugging window open in Visual Studio!
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.TextFormat">
            <summary>
            The text encoding format for all our logs.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.applicationStartTime">
            <summary>
            Helper to figure out when this application was started. This is
            not really the application start time because we will use the time
            the Log class is first accessed, but since we do that pretty much
            always at the application start (just to set the ProgramName, etc.)
            it will be the correct time. Used for the LogHeader!
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.lastLoggedMessages">
            <summary>
            Only remember the last 8 logged messages for CheckDuplicateMessage!
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.lastConsoleWriteTimes">
            <summary>
            Only remember the last 10 Console.WriteLines, skip all lines than 10
            console writes, completely cut of any Console.WriteLines then. This
            way we should not lose more than 10*5ms = 50ms per second. See unit
            test below: 6ms for 30 characters writing to an attached debug window.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.Equals(System.Object,System.Object)">
            <summary>
            Equals, just trying to hide it.
            </summary>
            <param name="objA">Object A</param>
            <param name="objB">Object B</param>
        </member>
        <member name="M:Delta.Utilities.Log.ReferenceEquals(System.Object,System.Object)">
            <summary>
            ReferenceEquals, just trying to hide it.
            </summary>
            <param name="objA">Object A</param>
            <param name="objB">Object B</param>
        </member>
        <member name="M:Delta.Utilities.Log.ShowCurrentLogInTextEditor">
            <summary>
            Show current log in text editor
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.Test(System.String)">
            <summary>
            Verbose log information that is usually only used for unit tests.
            Can be disabled in release mode and should be used only for tests
            anyway. This is not sent to the DeltaEngine.net server and not even
            put into the log file, just to the console for the debugging
            console or the TestRunner or TestDriven.net output window!
            Please note that we will skip logging the same message over and over
            again because it is REALLY slow in VisualStudio (@see "ToConsole()").
            If you really want to log everything out and do not care about
            performance, just use Console.WriteLine yourself (e.g. when just
            quickly testing if a click event happens). With Log.Test you can even
            spam millions of messages per second, most of them will be skipped.
            </summary>
            <param name="message">Message</param>
        </member>
        <member name="M:Delta.Utilities.Log.Test(System.String,System.Boolean)">
            <summary>
            Test
            </summary>
            <param name="message">Message</param>
            <param name="skipRepeatingMessages">
            If 'true', messages which are repeating will be skipped (recommended
            for looping calls like in render oder updating) to avoid log spamming.
            </param>
        </member>
        <member name="M:Delta.Utilities.Log.Info(System.String)">
            <summary>
            This method logs general information to the log file, to the console,
            if available to the screen, and finally to the DeltaEngine.net server.
            These kind of messages are usually for figuring stuff out that is
            working, but sometimes we need some additional details. On a normal
            release program run we should still have zero log messages!
            </summary>
            <param name="message">Message to show in the log and console</param>
        </member>
        <member name="M:Delta.Utilities.Log.Info(System.String,System.Boolean)">
            <summary>
            This method logs general information to the log file, to the console,
            if available to the screen, and finally to the DeltaEngine.net server.
            These kind of messages are usually for figuring stuff out that is
            working, but sometimes we need some additional details. On a normal
            release program run we should still have zero log messages!
            </summary>
            <param name="message">Message to show in the log and console</param>
            <param name="checkForDuplicates">Check if this message already was
            logged in the last 10 messages, then skip it to prevent log spam.
            This is on by default.
            </param>
        </member>
        <member name="M:Delta.Utilities.Log.Warning(System.String)">
            <summary>
            Outputs a warning, which usually indicates something went really
            wrong. It could be a required file was missing, an exception occurred
            and was caught. Sometimes even a dynamic class initialization failed
            and we provided some fallback, but we want to warn about the initial
            failure. Non recoverable errors should throw an exception and will end
            up in Application.HandleUnhandledExceptions (which will still use this
            method to put the error to the log, but then will abort the
            application). A programmer or user can sometimes ignore warnings and
            still continue working without the application crashing, but it might
            not behave correctly. Note: Warnings always have a stack trace!
            </summary>
            <param name="message">Message</param>
        </member>
        <member name="M:Delta.Utilities.Log.Warning(System.String,System.Boolean)">
            <summary>
            Outputs a warning, which usually indicates something went really
            wrong. It could be a required file was missing, an exception occurred
            and was caught. Sometimes even a dynamic class initialization failed
            and we provided some fallback, but we want to warn about the initial
            failure. Non recoverable errors should throw an exception and will end
            up in Application.HandleUnhandledExceptions (which will still use this
            method to put the error to the log, but then will abort the
            application). A programmer or user can sometimes ignore warnings and
            still continue working without the application crashing, but it might
            not behave correctly. Note: Warnings always have a stack trace!
            </summary>
            <param name="message">Message</param>
            <param name="showStackTrace">Show Stack Trace</param>
        </member>
        <member name="M:Delta.Utilities.Log.InvalidVersionWarning(System.String,System.Int32,System.Int32)">
            <summary>
            Logs a warning because of an invalid data version.
            </summary>
            <param name="className">Class name</param>
            <param name="dataVersion">Data version</param>
            <param name="maxSupportedVersion">Maximum supported version</param>
        </member>
        <member name="M:Delta.Utilities.Log.Close">
            <summary>
            Close log, will disconnect from the Log server and even open up the
            log file in editor in debug mode (if a log was generated at all).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.LogHappened">
            <summary>
            You can attach delegates to LogHappened to get notified whenever a
            log message is happening (usually should only happen for testing or
            when something goes wrong and a log warning is put out). Used
            in the Delta.Engine.Application class to add Log Server features.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.LastWarningMessage">
            <summary>
            Last warning message we want to display in Scene.Draw, usually not
            used, only if something bad happened. Set here, used there.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.LastWarningTime">
            <summary>
            Helpers to display warnings in Scene.Draw, will be reduced there.
            Set here, used there (thus public access is needed).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.ExtraHardwareInfo">
            <summary>
            Platform modules have the ability to add extra hardware information
            for the log, which might be interesting or useful. E.g. on the iPhone
            we use the DeviceHardware class to show more information about the
            device (is it an iPhone, iPod or iPad, which shader can it do, etc.)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.Directory">
            <summary>
            By default no log directory is used, all logs end up in the application
            directory (named by the program or unit test that was started).
            Note: This is just a directory, no filename should be specified here.
            Also note that this must be set before the actual logging happens,
            so in case you first have some log warnings and then load the settings
            the initial log directory is not set.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.loadedModules">
            <summary>
            This is also set in DynamicBase and will obviously only report
            the loaded modules if they have been set (Graphics, Sound, Video).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.logTimer">
            <summary>
            Use timer to have more accurate timing (uses PerformanceCounters
            internally and can return accurate millisecond values for many million
            years due the use of long integer values). Usually setup in the Time
            class, but if that is not used or was not called before logging
            happens we will initialize this on our own with a simple
            StopwatchTimeSource and update it ourself.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.allowDuplicateLogChecking">
            <summary>
            By default Allow Duplicate Log Checking. This speeds up console writing
            by a lot (skips messages if too much is going on, making logging
            10-100x faster). It also checks for duplicate messages written into
            the log file (keeping the log file much smaller).
            <para />
            But it can be useful if you really want every single log message in
            the console and log file including duplicates, then disable this
            feature (via Application Settings or by setting this to false).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.logName">
            <summary>
            Current log name, will be "Engine" until Application.Start is
            called, then it will be the current game, unit test or tool name.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.remToLaunchEngineLogAtEndOfProgram">
            <summary>
            Extra helper to show even the Engine.txt file when closing the
            program in case there were Engine warnings we need to know about!
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.isLogFileCreatable">
            <summary>
            Can the log file be created, helps us to remember if we have already
            tried to create a log file and was it successful.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.remOurSetupLogTimer">
            <summary>
            Helper to remember which timer we have setup (if we have done so at
            all). If this is null or not equal to logTimer than the engine has
            changed this and is now started. It is save to use the retrying
            connection feature of the Client class if so because Close is
            called by force when the application quits (otherwise not).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.logFile">
            <summary>
            The handle to our (local) log file.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.currentLogInstance">
            <summary>
            Current log instance.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.rememberLogWasCreatedFromNunitTestRunner">
            <summary>
            Remember if the log creation in Instance was done from a test runner.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.CheckIfLogWasCreatedFromNunitTestRunner">
            <summary>
            Helper method to find out if the log instance was created by the NUnit
            test runner or by ReSharpers Unit Test Sessions. This is important
            because if the log class is being disposed by a finalizer (e.g. from
            WPF) and we need to show the log file in a text editor it will crash
            with an System.Runtime.InteropServices.InvalidComObjectException: COM
            object that has been separated from its underlying RCW cannot be used.
            We can prevent this from happening by setting this to true in the
            Instance property. Since we see the output in the test runner anyway
            opening the text editor is not important anyway.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Log.lastDiscardedConsoleMessage">
            <summary>
            Remember the last discarded console message. Show it when the app
            quits. It often contains interesting information about performance.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.#ctor">
            <summary>
            Create log
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.Finalize">
            <summary>
            ~Log destructor, just calls Dispose, which calls Close.
            Note: Not often helpful because this is only called when everything
            else was killed and this only cleans up after all threads and objects
            are gone anyway.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.Dispose">
            <summary>
            Dispose, just calls Close to make sure we dispose stuff if the
            application is quitting (either forcefully or normally via
            Application.Quit).
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.ArchiveLogFile">
            <summary>
            Archives a log file to an existing log-file-archive or creates a new
            log-file-archive, if the archive-file doesn't exist yet. However in any
            case the current log file will be deleted after processing to the
            archive. This is used for in the LogService too.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.GetPlatformInfo">
            <summary>
            Get platform info helper method for LogHeader to output some useful
            information about the currently running platform (especially nice for
            the log server, which shows this info in the logs too).
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.CreateLogFile(System.String)">
            <summary>
            Create log file
            </summary>
            <param name="logFilename">Log filename</param>
        </member>
        <member name="M:Delta.Utilities.Log.CheckDuplicateMessage(System.String)">
            <summary>
            Returns true if we should skip this message in case we are logging it
            over and over again (prevent log spam). Make sure to call this BEFORE
            adding the time stamp, which most likely will make every message
            unique and prevents us from detecting log spam.
            </summary>
            <param name="message">Message</param>
        </member>
        <member name="M:Delta.Utilities.Log.ToFile(System.String)">
            <summary>
            To file
            </summary>
            <param name="message">Message</param>
        </member>
        <member name="M:Delta.Utilities.Log.ToConsole(System.String,System.Boolean)">
            <summary>
            Print to console, which is horribly slow in Visual Studio, but still
            very useful for debugging. Instead of logging everything to the
            console we gonna limit the amount of console writing. Usually we
            should have less than 10 message lines per second (we don't want to
            throw any warnings, informational logs or even test messages in
            a normal application run, it should have zero logging!)
            For additional details about bad performance of Debug.WriteLine see:
            http://rdn-consulting.com/blog/2008/05/28/net-consolewriteline-performance-issues/
            Also see the below unit test, which is horribly slow: 6ms for 30 chars
            </summary>
            <param name="message">Message</param>
            <param name="checkForDuplicates">Check for Duplicates</param>
        </member>
        <member name="M:Delta.Utilities.Log.FormatMessage(System.String)">
            <summary>
            Format message for use with the log methods (log server, file, console)
            </summary>
            <param name="rawMessage">Raw message</param>
        </member>
        <member name="M:Delta.Utilities.Log.WriteInfo(System.String,System.Boolean)">
            <summary>
            Write information string to the log, the console and to the
            DeltaEngin.net server. For details see the static Info method.
            </summary>
            <param name="message">Message to show in the log and console</param>
            <param name="checkForDuplicates">Check if this message already was
            logged in the last 10 messages, then skip it to prevent log spam.
            This is on by default.
            </param>
        </member>
        <member name="M:Delta.Utilities.Log.WriteWarning(System.String,System.Boolean)">
            <summary>
            Warning, thought for logging "light errors" which can be handled itself
            by the application. For details see the static Warning method!
            </summary>
            <param name="message">Warning to show in the log and console</param>
            <param name="showStackTrace">Show Stack Trace</param>
        </member>
        <member name="P:Delta.Utilities.Log.LogName">
            <summary>
            Current log name, initially "Engine" until Application.Start is
            called, then it will be the current game, unit test or tool name.
            </summary>
        </member>
        <member name="P:Delta.Utilities.Log.Filename">
            <summary>
            Returns the complete file name of the current log file.
            </summary>
        </member>
        <member name="P:Delta.Utilities.Log.ArchivedLogFilename">
            <summary>
            Archived log filename
            </summary>
        </member>
        <member name="P:Delta.Utilities.Log.LogHeader">
            <summary>
            The header information of our log.
            </summary>
        </member>
        <member name="P:Delta.Utilities.Log.Instance">
            <summary>
            Current log instance we are using, if there is no instance, we will
            create one with the current program name (defaults to Engine.txt).
            </summary>
        </member>
        <member name="T:Delta.Utilities.Log.LogDelegate">
            <summary>
            The log delegate is used for other classes to attach to all log events
            that happen (both Log.Info and Log.Warning calls, but not Log.Test).
            It provides an already formated log text string and it used for example
            in the Delta.Engine.Application class to add Log Server features.
            </summary>
            <param name="message">Message</param>
        </member>
        <member name="T:Delta.Utilities.Log.LogTests">
            <summary>
            Tests
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.LogTests.TestLogging">
            <summary>
            Test logging
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.LogTests.TestConsoleLog">
            <summary>
            Test console log
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.LogTests.ConsoleWriteLinePerformance">
            <summary>
            ConsoleWriteLinePerformance
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.LogTests.TestMassiveLogging2">
            <summary>
            Test massive logging 2
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.LogTests.TestInfoLogging">
            <summary>
            Test logging
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.LogTests.TestWarningLogging">
            <summary>
            TestWarningLogging
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.LogTests.ArchiveLogFileWhileFileIsOpen">
            <summary>
            Archive log file while file is open
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.LogTests.CreateLogFile">
            <summary>
            Create log file. Note: Too slow for a dynamic unit test.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.LogTests.LogHeader">
            <summary>
            Log header
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.LogTests.LogToFile">
            <summary>
            Log to file. Note: Too slow for a dynamic unit test.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.LogTests.ArchiveLogFile">
            <summary>
            Archive log file
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.LogTests.MultipleLogFileAccess">
            <summary>
            Multiple log file access
            </summary>
        </member>
        <member name="M:Delta.Utilities.Log.LogTests.TestQueue">
            <summary>
            Test queue
            </summary>
        </member>
        <member name="T:Delta.Utilities.Profiling.IProfiler">
            <summary>
            Interface for the profiler module, which basically just shows
            the Fps, Module, System or Simulator information via the
            ProfilingGraphics module that is created dynamically if needed.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Profiling.IProfiler.Start(System.String)">
            <summary>
            Set start flag
            </summary>
            <param name="flagDescription">Flag description</param>
        </member>
        <member name="M:Delta.Utilities.Profiling.IProfiler.Stop(System.String)">
            <summary>
            Set end flag
            </summary>
            <param name="flagDescription">Flag description</param>
        </member>
        <member name="M:Delta.Utilities.Profiling.IProfiler.AddLoadedContentSize(System.Int32)">
            <summary>
            Helper method to count how much content we are actually loading
            in bytes. This is only used in the System profiling mode.
            </summary>
            <param name="contentSizeInBytes">
            Content size in bytes for profiling.
            </param>
        </member>
        <member name="M:Delta.Utilities.Profiling.IProfiler.NewFrame">
            <summary>
            Update some per frame values, Marks beginning of new Frame
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Advanced.IIntersects">
            <summary>
            Interface Intersects checks whether two Delta.Utilities.Datatypes 
            intersect with each other.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.IIntersects.Intersects(Delta.Utilities.Datatypes.Ray,Delta.Utilities.Datatypes.Vector@)">
            <summary>
            Intersects the current object with specified ray and returns true
            plus the intersectionPosition if the ray hits this object.
            </summary>
            <param name="ray">The ray to check with</param>
            <param name="intersectionPosition">The intersection vector</param>
            <returns>True if the ray intersected with this object</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.IIntersects.Intersects(Delta.Utilities.Datatypes.Plane,Delta.Utilities.Datatypes.Vector@)">
            <summary>
            Intersects the current object with specified plane and returns true
            plus the intersectionPosition if the plane intersects this object.
            </summary>
            <param name="plane">The plane to check with</param>
            <param name="intersectionPosition">The intersection vector</param>
            <returns>True if the plane intersected with this object</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.IIntersects.Intersects(Delta.Utilities.Datatypes.BoundingSphere)">
            <summary>
            Intersects the current object with the specified sphere.
            </summary>
            <param name="sphere">The sphere to check against</param>
            <returns>True if the sphere intersected with this object</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.IIntersects.Intersects(Delta.Utilities.Datatypes.BoundingBox)">
            <summary>
            Intersects the current object with the specified box.
            </summary>
            <param name="box">The box to check against</param>
            <returns>True if the box intersected with this object</returns>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Advanced.Margin">
            <summary>
            Margin helper class to allow aligning and docking UI elements with some
            spacing in between them, but can be used for any other purpose as well.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.Margin.VersionNumber">
            <summary>
            The current version of the implementation of this class.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.Margin.Left">
            <summary>
            Left
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.Margin.Top">
            <summary>
            Top
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.Margin.Right">
            <summary>
            Right
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.Margin.Bottom">
            <summary>
            Bottom
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.Margin.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="!:Spacing"/> struct.
            </summary>
            <param name="setOverallSpacing">Set overall spacing</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.Margin.#ctor(System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="!:Spacing"/> struct.
            </summary>
            <param name="setHorizontal">Set horizontal</param>
            <param name="setVertical">Set vertical</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.Margin.#ctor(System.IO.BinaryReader)">
            <summary>
            Create spacing
            </summary>
            <param name="setDataReader">Set data reader</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.Margin.Load(System.IO.BinaryReader)">
            <summary>
            Loads all data of the object again which were previously saved.
            </summary>
            <param name="dataReader">
            The container object which contains the data which were saved before.
            </param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.Margin.Save(System.IO.BinaryWriter)">
            <summary>
            Saves all necessary data of the object into a binary stream.
            </summary>
            <param name="dataWriter">
            The container object which will store all the saved data.
            </param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.Margin.op_Equality(Delta.Utilities.Datatypes.Advanced.Margin,Delta.Utilities.Datatypes.Advanced.Margin)">
            <summary>
            Check for equality
            </summary>
            <param name="value1">Margin value 1</param>
            <param name="value2">Margin value 2</param>
            <returns>
            True if the margin values are equal, false otherwise.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.Margin.op_Inequality(Delta.Utilities.Datatypes.Advanced.Margin,Delta.Utilities.Datatypes.Advanced.Margin)">
            <summary>
            Check for inequality
            </summary>
            <param name="value1">Margin value 1</param>
            <param name="value2">Margin value 2</param>
            <returns>
            True if the margin values are not equal, false otherwise.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.Margin.Equals(System.Object)">
            <summary>
            Check if the object is a Margin instance and then compare them.
            </summary>
            <param name="obj">Object to check.</param>
            <returns>True if object is equal to this instance, otherwise False.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.Margin.GetHashCode">
            <summary>
            Get the hash code.
            </summary>
            <returns>Hash code.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.Margin.ToString">
            <summary>
            To string
            </summary>
        </member>
        <member name="T:Delta.Utilities.Profiling.PerformanceTester">
            <summary>
            Performance tester helper class for profiling certain code paths
            many million times to compare different implementations. Heavily
            used for the MartixPerformance class.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Profiling.PerformanceTester.Profile(System.Int32,Delta.Utilities.Profiling.PerformanceTester.ProfileDelegate)">
            <summary>
            Profile some test code many million times and return how much time
            it took in ms.
            </summary>
            <param name="iterations">Iterations to execute the delegate</param>
            <param name="testDelegate">Test delegate to be executed</param>
            <returns>Number of milliseconds elapsed to run testDelegate iterations
            number of times</returns>
        </member>
        <member name="M:Delta.Utilities.Profiling.PerformanceTester.Profile10MilionTimes(System.String,Delta.Utilities.Profiling.PerformanceTester.ProfileDelegate)">
            <summary>
            Helper to profile 10 million times and output the performance result.
            Profiles the code with 10 million iterations and output the result.
            </summary>
            <param name="profileTestName">Name for the test</param>
            <param name="testDelegate">Test delegate to execute</param>
        </member>
        <member name="M:Delta.Utilities.Profiling.PerformanceTester.Profile1MilionTimes(System.String,Delta.Utilities.Profiling.PerformanceTester.ProfileDelegate)">
            <summary>
            Profiles the code with 1 million iterations and output the result.
            </summary>
            <param name="profileTestName">Name for the test</param>
            <param name="testDelegate">Test delegate to execute</param>
        </member>
        <member name="M:Delta.Utilities.Profiling.PerformanceTester.ShowTotalProfileRuns">
            <summary>
            Show total profile runs, which just displays the number of tests
            that were executed plus the total and average time spend in ms.
            After calling this numberOfProfileRuns and totalProfileRunsMs will
            both be reset to 0.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Profiling.PerformanceTester.numberOfProfileRuns">
            <summary>
            Helpers for ShowTotalProfileRuns (just displays the number of tests
            that were executed plus the total and average time spend in ms).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Profiling.PerformanceTester.totalProfileRunsMs">
            <summary>
            Helpers for ShowTotalProfileRuns (just displays the number of tests
            that were executed plus the total and average time spend in ms).
            </summary>
        </member>
        <member name="T:Delta.Utilities.Profiling.PerformanceTester.ProfileDelegate">
            <summary>
            Just a boring void delegate with no parameters for profiling.
            </summary>
        </member>
        <member name="T:Delta.Utilities.Cache`2">
            <summary>
            Generic cache class to help getting cached data values for different
            input or output type. For best performance the input type should be
            a small value type that can be compared quickly (int, float, string)
            and the output type should be a class or small struct (big structs also
            work, but performance wise lots of copying is needed). Finally this
            class automatically flushes the cache after a certain period of time.
            <para/>
            Please not that this class has changed from static method to instance
            methods and it does not contain the delegate or names anymore. The
            caller now has to create its own instance and manage the delegate or
            code himself. This removes some cool features from the old Cache class,
            but it is much faster this way and allows more control and fine-tuning
            by each implementor.
            </summary>
            <typeparam name="TInput">Input key, should be as simple as
            possible and be a value type for best performance (no complex struct)
            </typeparam>
            <typeparam name="TOutput">Return value when requesting data for
            the input type, can be more complex or even a class.</typeparam>
        </member>
        <member name="F:Delta.Utilities.Cache`2.WarningTooMuchCacheEntries">
            <summary>
            Warn when we hit 1000 cached entries and kill the whole cache. This
            usually does not happen in normal operation (except for heavy database
            use, e.g. for a website, then this needs to be increased a lot).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Cache`2.DefaultFlushTimeInSeconds">
            <summary>
            Default number of seconds till we force the next complete cache flush
            for each cache list! Since this is for game code we are happy with
            caching for up to 10 minutes, longer times are possible with the
            overloads below, but most simple code does not have to keep big
            cache lists (e.g. content caching, render list caching, etc.).
            Long times here have the advantage of keeping lots of cache data
            around and making calls faster, shorter times have the advantage of
            not wasting so much memory with cache data and updating the results
            after the flush time has run out.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Cache`2.customCode">
            <summary>
            Delegate for generating the output value from the input value in the
            Get method below.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Cache`2.data">
            <summary>
            Data we keep around in the cache
            </summary>
        </member>
        <member name="F:Delta.Utilities.Cache`2.secondsTillNextFlush">
            <summary>
            Time in seconds till we do the next flush (clearing all cached data)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Cache`2.nextTimeFlushedInTicks">
            <summary>
            The next time all cache data is flushed down the toilet is remembered
            here and calculated in the constructor and once a flush happened.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Cache`2.onlyCheckFlushEvery10Times">
            <summary>
            Helper to make sure we only check for the flush time every 10 calls
            to Get. Flushing is not so important to waste too much performance on
            the constant calls (Stopwatch.GetTimestamp is pretty fast, but still).
            Without this about 60-70% of performance is lost to
            topwatch.GetTimestamp for simple gets, with this it is only ~20%.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Cache`2.#ctor(Delta.Utilities.Cache{`0,`1}.CustomCodeDelegate,System.Int32)">
            <summary>
            Cache constructor, which will just set the time for the next flush.
            </summary>
            <param name="setCustomCode">Custom code to execute when a input
            key is not found and the output value needs to be generated.</param>
            <param name="setSecondsTillNextFlush">Set time till next flush, by
            default this value is 10 minutes (10*60).</param>
        </member>
        <member name="M:Delta.Utilities.Cache`2.#ctor(Delta.Utilities.Cache{`0,`1}.CustomCodeDelegate)">
            <summary>
            Cache constructor with the default cache flush time of 10 minutes.
            </summary>
            <param name="setCustomCode">Custom code to execute when a input
            key is not found and the output value needs to be generated.</param>
        </member>
        <member name="M:Delta.Utilities.Cache`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the cache values.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be
            used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Cache`2.Add(`0,`1)">
            <summary>
            Add a new input value with a specific output value, will update
            an existing item if it already exists.
            </summary>
            <param name="input">Input</param>
            <param name="value">Value</param>
        </member>
        <member name="M:Delta.Utilities.Cache`2.Remove(`0)">
            <summary>
            Remove cached value in case we updated something and want to clear a
            specific cache entry.
            </summary>
            <param name="input">Input</param>
        </member>
        <member name="M:Delta.Utilities.Cache`2.Clear">
            <summary>
            Clear whole cache, updated lastTimeFlushed time and clear statistics
            </summary>
        </member>
        <member name="M:Delta.Utilities.Cache`2.Get(`0)">
            <summary>
            Get method, which gets the cached data, most important method here.
            </summary>
            <param name="input">Input</param>
        </member>
        <member name="M:Delta.Utilities.Cache`2.GetAll">
            <summary>
            Helper method to get all entries used in this cache.
            </summary>
            <returns>Copied list of the cached output types</returns>
        </member>
        <member name="P:Delta.Utilities.Cache`2.Count">
            <summary>
            How many data cache entries do we currently have? This allows the
            caller to clear the cache if it gets too big (e.g. different font
            texts).
            </summary>
        </member>
        <member name="T:Delta.Utilities.Cache`2.CustomCodeDelegate">
            <summary>
            The method to generate the output value from the input value.
            </summary>
            <param name="input">Input type for this custom delegate</param>
        </member>
        <member name="T:Delta.Utilities.Cache`3">
            <summary>
            Same Cache class as above, but allows to have multiple input types,
            which is not an easy problem if you are targeting high performance
            dictionary gets. Here is a good article about this topic:
            http://www.aronweiler.com/2011/05/performance-tests-between-multiple.html
            <para />
            For now the easiest way to do this is used by having 2 dictionaries
            inside each other. The first key is the important one.
            </summary>
            <typeparam name="TInput1">First and important input key, should be as
            simple as possible and be a value type for best performance</typeparam>
            <typeparam name="TInput2">Second input key, only if both the first
            and second input key match, the output value is returned.</typeparam>
            <typeparam name="TOutput">Return value when requesting data for
            the input type, can be more complex or even a class.</typeparam>
        </member>
        <member name="F:Delta.Utilities.Cache`3.WarningTooMuchCacheEntries">
            <summary>
            Warn when we hit 1000 cached entries and kill the whole cache. This
            usually does not happen in normal operation (except for heavy database
            use, e.g. for a website, then this needs to be increased a lot).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Cache`3.DefaultFlushTimeInSeconds">
            <summary>
            Default number of seconds till we force the next complete cache flush
            for each cache list! Since this is for game code we are happy with
            caching for up to 10 minutes, longer times are possible with the
            overloads below, but most simple code does not have to keep big
            cache lists (e.g. content caching, render list caching, etc.).
            Long times here have the advantage of keeping lots of cache data
            around and making calls faster, shorter times have the advantage of
            not wasting so much memory with cache data and updating the results
            after the flush time has run out.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Cache`3.customCode">
            <summary>
            Delegate for generating the output value from the input value in the
            Get method below.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Cache`3.data">
            <summary>
            Data we keep around in the cache
            </summary>
        </member>
        <member name="F:Delta.Utilities.Cache`3.secondsTillNextFlush">
            <summary>
            Time in seconds till we do the next flush (clearing all cached data)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Cache`3.nextTimeFlushedInTicks">
            <summary>
            The next time all cache data is flushed down the toilet is remembered
            here and calculated in the constructor and once a flush happened.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Cache`3.onlyCheckFlushEvery10Times">
            <summary>
            Helper to make sure we only check for the flush time every 10 calls
            to Get. Flushing is not so important to waste too much performance on
            the constant calls (Stopwatch.GetTimestamp is pretty fast, but still).
            Without this about 60-70% of performance is lost to
            topwatch.GetTimestamp for simple gets, with this it is only ~20%.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Cache`3.#ctor(Delta.Utilities.Cache{`0,`1,`2}.CustomCodeDelegate,System.Int32)">
            <summary>
            Cache constructor, which will just set the time for the next flush.
            </summary>
            <param name="setSecondsTillNextFlush">Set time till next flush</param>
            <param name="setCustomCode">Custom code to execute when a input
            key is not found and the output value needs to be generated.</param>
        </member>
        <member name="M:Delta.Utilities.Cache`3.#ctor(Delta.Utilities.Cache{`0,`1,`2}.CustomCodeDelegate)">
            <summary>
            Cache constructor with the default cache flush time of 10 minutes.
            </summary>
            <param name="setCustomCode">Custom code to execute when a input
            key is not found and the output value needs to be generated.</param>
        </member>
        <member name="M:Delta.Utilities.Cache`3.Add(`0,`1,`2)">
            <summary>
            Add a new input value with a specific output value, will update
            an existing item if it already exists.
            </summary>
            <param name="input1">Input key part 1, must match</param>
            <param name="input2">Input key part 2, must also match</param>
            <param name="value">Value</param>
        </member>
        <member name="M:Delta.Utilities.Cache`3.Remove(`0,`1)">
            <summary>
            Remove cached value in case we updated something and want to clear a
            specific cache entry. Note: Will not kill any dictionaries as data
            will most likely be filled in soon. Use Clear to kill everything!
            </summary>
            <param name="input1">Input key part 1, must match</param>
            <param name="input2">Input key part 2, must also match</param>
        </member>
        <member name="M:Delta.Utilities.Cache`3.Clear">
            <summary>
            Clear whole cache, updated lastTimeFlushed time and clear statistics
            </summary>
        </member>
        <member name="M:Delta.Utilities.Cache`3.Get(`0,`1)">
            <summary>
            Get method, which gets the cached data, most important method here.
            </summary>
            <param name="input1">First input key part</param>
            <param name="input2">Second input key part</param>
            <returns>Output Type</returns>
        </member>
        <member name="M:Delta.Utilities.Cache`3.GetAllEntries">
            <summary>
            Return all entries as a flat list so we can easily enumerate though
            them. Useful for disposing stuff.
            </summary>
            <returns>Flat list of TOutput</returns>
        </member>
        <member name="P:Delta.Utilities.Cache`3.Count">
            <summary>
            How many data cache entries do we currently have? This allows the
            caller to clear the cache if it gets too big (e.g. different font
            texts).
            </summary>
        </member>
        <member name="T:Delta.Utilities.Cache`3.CustomCodeDelegate">
            <summary>
            The method to generate the output value from the input values.
            </summary>
            <param name="input1">Input type 1 for this custom delegate</param>
            <param name="input2">Input type 2 for this custom delegate</param>
        </member>
        <member name="T:Delta.Utilities.CacheTests">
            <summary>
            Tests for the generic Cache class (cannot do tests directly there).
            </summary>
        </member>
        <member name="M:Delta.Utilities.CacheTests.TestPerformance">
            <summary>
            Performance test of the Cache class, doing 1 million gets.
            <para />
            Result is for 1 million iterations each (with a 4Ghz Sandy Bridge CPU):
            <para />
            simpleIntCache (int in, int out): ~20ms
            <para />
            stringLengthCache (string in, int out): ~35ms
            <para />
            complexCache (string in, float in, string out): ~55ms
            <para />
            complexStructCache (string in, Struct in, string out): ~140ms
            <para />
            structCache (struct with string+int in, struct out): ~1200ms
            <para />
            Note: The last one (structCache) is much slower than the rest and the
            reason for this is the struct (string+int). Mixing string and other
            datatypes is slow as hell when comparing structs, even the
            complexStructCache version is slower than the rest with just 2 floats
            and an integer number. All this need to be copied to the Get method
            and then compared to all other dictionary values, which takes time!
            Always use the generic Cache class with 2 inputs if you have a string
            plus other data, and try to simplify the input key as much as possible.
            </summary>
        </member>
        <member name="M:Delta.Utilities.CacheTests.GetCachedData">
            <summary>
            Test get cached data
            </summary>
        </member>
        <member name="M:Delta.Utilities.CacheTests.ClearCachedData">
            <summary>
            Clear cached data
            </summary>
        </member>
        <member name="M:Delta.Utilities.CacheTests.MultipleInputKeys">
            <summary>
            Unit test to show of a more complex example with multiple input keys.
            </summary>
        </member>
        <member name="T:Delta.Utilities.CacheTests.SimpleStruct">
            <summary>
            Simple struct for the complexStructCache in TestPerformance.
            </summary>
        </member>
        <member name="T:Delta.Utilities.CacheTests.StringAndNumber">
            <summary>
            Helper struct for the input type of the ComplexInputAndOutputData test
            </summary>
        </member>
        <member name="T:Delta.Utilities.CacheTests.LotsOfNumbers">
            <summary>
            Helper struct for the output type of the ComplexInputAndOutputData test
            </summary>
        </member>
        <member name="T:Delta.Utilities.Helpers.StreamHelper">
            <summary>
            StreamHelper: Adding cool functions for stream stuff (writing/reading).
            For example to send small numbers, which are most likely not bigger
            than 255 or 65536 as bytes or shorts and not as full 4 byte (Int32).
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StreamHelper.WriteNumberMostlySmallerThan254(System.IO.BinaryWriter,System.Int32)">
            <summary>
            The first byte is used for the type of number we save:
            smaller than 254: Just use this number as positive number 0-253.
            - 254: +2 bytes for any ushort number (positive number)
            - 255: +4 bytes for any int number (negative or positive number)
            This function should be used if you are pretty sure this number
            is a byte, else this function will probably not be the optimal choice.
            Very good for enums and small values, flags, etc.
            Used all over the place for optimized network package code!
            </summary>
            <param name="smallNumber">Small number that should be less than 254
            (and not negative) if possible, but it can be any number.</param>
            <param name="writer">Writer to write compressed number into</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.StreamHelper.WriteNumberMostlySmallerThan16Bit(System.IO.BinaryWriter,System.Int32)">
            <summary>
            Similar to WriteNumberMostlySmallerThan255, but will write 
            at least 2 bytes for shorts, except short.MinValue, which is
            used to mark that this value does not fit into a short,
            we will write an 4 byte int instead (total length is 6 bytes then).
            Use this function to save a byte more if you know your number
            is most likely in the range -32768 - 32768 (good for counters,
            statistic values, points, etc.).
            Of course this function will always use 2 bytes, even if
            we store something smaller than 255 (in this case use other function)
            </summary>
            <param name="smallNumber">Small Number</param>
            <param name="writer">Writer</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.StreamHelper.WriteNumberMostlySmallerThan32Bit(System.IO.BinaryWriter,System.Int64)">
            <summary>
            Similar to WriteNumberMostlySmallerThan16Bit, but will
            write 4 bytes for everything in the range of an int. However,
            maybe we use the full capacity of a long, then int.MinValue is
            saved and then 8 bytes for the long value.MaxValue, else
            we got a long value and then 8 bytes for the number.
            Use this function to save a long if you know your number
            is most likely in the range -2bil - +2bil (good for long counters).
            </summary>
            <param name="number">Number</param>
            <param name="writer">Writer</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.StreamHelper.ReadNumberMostlySmallerThan254(System.IO.BinaryReader)">
            <summary>
            Read number written with WriteNumberMostlySmallerThan254,
            see that function for an explanation, returns number we submitted.
            Could read 1 byte (if value is between 0 and 253) or 3 (1 byte for
            the type=254 and 2 bytes for the ushort value) or even 5 bytes
            (in case an int was used).
            </summary>
            <param name="reader">Reader to extract the data from</param>
            <returns>Number that was stored in the stream with help of the
            WriteNumberMostlySmallerThan254 method above.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StreamHelper.ReadNumberMostlySmallerThan16Bit(System.IO.BinaryReader)">
            <summary>
            Read number written with WriteNumberMostlySmallerThan16Bit,
            see that function for an explanation, returns number we submitted.
            Could read 2 byte (if value is a short) or 6 bytes for integers.
            </summary>
            <param name="reader">Reader to extract the data from</param>
            <returns>Number that was stored in the stream with help of the
            WriteNumberMostlySmallerThan16Bit method above.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StreamHelper.ReadNumberMostlySmallerThan32Bit(System.IO.BinaryReader)">
            <summary>
            Read number written with WriteNumberMostlySmallerThan32Bit,
            see that function for an explanation,
            returns number we submitted there!
            We read 4 or 12 bytes (obviously we return a long, because if
            we got more than 32 bits, it won't fit!)
            </summary>
            <param name="reader">Reader to extract the data from</param>
            <returns>Number that was stored in the stream with help of the
            WriteNumberMostlySmallerThan32Bit method above.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StreamHelper.GetDataLengthOfNumberMostlySmallerThan254(System.Int32)">
            <summary>
            Helper method to figure out how many bytes we need to store the given
            small number (which should be mostly 1 byte because we expect values
            below 254, but it can go up to 3 or 5 bytes for big numbers).
            </summary>
            <param name="smallNumber">Small number that should be less than 254
            (and not negative) if possible, but it can be any number.</param>
            <returns>Number of bytes that we would need to save this number.
            Does not actually store anything, use
            <see cref="M:Delta.Utilities.Helpers.StreamHelper.WriteNumberMostlySmallerThan254(System.IO.BinaryWriter,System.Int32)"/> for that.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StreamHelper.TryToGetNumberMostlySmallerThan254(System.IO.BinaryReader,System.Int32@)">
            <summary>
            Helper function for network stream reading, we check if
            current byte array (we have no guarantee whole message has arrived,
            we have to check how much we got and if this is enough)
            contains full number in WriteNumberMostlySmallerThan255 style.
            Note: Will not restore the stream position because the caller usually
            does it anyway when we have to wait for more data.
            </summary>
            <returns>True if we successfully could read the number, false if
            there was not enough data and we have to wait for more data</returns>
            <param name="number">Number</param>
            <param name="reader">Reader</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.StreamHelper.LoadWithLength(System.IO.BinaryReader)">
            <summary>
            Helper method to load the length of data plus the data itself. Very
            useful for byte arrays that obviously need the size saved out too.
            </summary>
            <param name="reader">Reader to read the byte data from</param>
            <returns>Returns the byte array with the length specified in the
            stream.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StreamHelper.LoadWithLength``1(System.IO.BinaryReader,``0)">
            <summary>
            Generic helper method to load an ISaveLoadBinary object back in. Use
            SaveWithLength to save such an object out into a binary stream. This
            method is most useful if called from the Factory.Load method, which
            will also create the type for you and load all data in for you.
            This method will not crash, but report a warning in the log instead,
            when the ISaveLoadBinary loading fails (e.g. not enough data).
            </summary>
            <param name="reader">Reader to read the object data (T) from</param>
            <param name="objectToLoad">ISaveLoadBinary object for the data to
            be loaded into.</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.StreamHelper.SaveWithLength(System.IO.BinaryWriter,System.Byte[])">
            <summary>
            Helper method to not just save an array out, but also keep track of
            how many bytes were saved and store those first in case anything goes
            wrong when loading the data later (e.g. the format has changed and
            more or less data is required). Use the LoadWithLength method to load
            the data again.
            </summary>
            <param name="writer">Writer to save the length and the data itself
            into.</param>
            <param name="dataToSave">Data to save as an byte array.</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.StreamHelper.SaveWithLength(System.IO.BinaryWriter,System.IO.MemoryStream)">
            <summary>
            Helper method to not just save an array out, but also keep track of
            how many bytes were saved and store those first in case anything goes
            wrong when loading the data later (e.g. the format has changed and
            more or less data is required). Use the LoadWithLength method to load
            the data again.
            </summary>
            <param name="writer">Writer to save the length and the data itself
            into.</param>
            <param name="dataToSave">Data to save as a MemoryStream</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.StreamHelper.SaveWithLength(System.IO.BinaryWriter,Delta.Utilities.ISaveLoadBinary)">
            <summary>
            Helper method to not just save an object out, but also keep track of
            how many bytes were saved and store those first in case anything goes
            wrong when loading the data later (e.g. the format has changed and
            more or less data is required). Use the LoadWithLength method to load
            the data again.
            </summary>
            <param name="writer">Writer to save the length and the data itself
            into.</param>
            <param name="dataToSave">Data we want to save via the ISaveLoadBinary
            interface, which does not know its own length.</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.StreamHelper.GetSavedData(Delta.Utilities.ISaveLoadBinary)">
            <summary>
            Gets all saved pure data of the given object without any information
            about the data length at the beginning.
            </summary>
            <param name="dataToSave">
            Data we want to save via the ISaveLoadBinary interface, which does not
            know its own length.
            </param>
        </member>
        <member name="M:Delta.Utilities.Helpers.StreamHelper.GetSavedDataWithLength(Delta.Utilities.ISaveLoadBinary)">
            <summary>
            Gets all saved data of the given object with the number of the saved
            bytes at the beginning.
            </summary>
            <param name="dataToSave">
            Data we want to save via the ISaveLoadBinary interface, which does not
            know its own length.
            </param>
        </member>
        <member name="M:Delta.Utilities.Helpers.StreamHelper.Compare(System.IO.MemoryStream,System.IO.MemoryStream)">
            <summary>
            Helper method to compare two memory streams. Will return true if
            both streams are null or empty. If the streams have data, they must
            match exactly byte for byte to return true here. In all other cases
            false is returned.
            </summary>
            <param name="memoryStream1">First memory stream to check</param>
            <param name="memoryStream2">Second memory stream to check</param>
            <returns>True if both memory streams match (either both empty or null
            or both have exactly the same data), otherwise false.</returns>
        </member>
        <member name="T:Delta.Utilities.Helpers.StreamHelper.StreamHelperTests">
            <summary>
            Dummy class to do testing
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StreamHelper.StreamHelperTests.TestWritingAndReadingNumbers">
            <summary>
            Test writing and reading numbers
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StreamHelper.StreamHelperTests.GetDataLengthOfNumberMostlySmallerThan254">
            <summary>
            Test the GetDataLengthOfNumberMostlySmallerThan254 method.
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Point">
            <summary>
            Point class, can also be used as a Vector2 (because we got floats here).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Point.DataSize">
            <summary>
            Represents the size in bytes of each Point (2 * 4 = 8 bytes).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Point.Invalid">
            <summary>
            Invalid point, usually used to indicate invalid cached points.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Point.Zero">
            <summary>
            Returns the zero point (0, 0).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Point.Half">
            <summary>
            Returns the point (0.5, 0.5).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Point.One">
            <summary>
            Returns the point (1, 1).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Point.UnitX">
            <summary>
            Unit x vector, returns the point (1, 0)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Point.UnitY">
            <summary>
            Unit y vector, returns the point (0, 1)
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.Normalize(Delta.Utilities.Datatypes.Point)">
            <summary>
            Normalize
            </summary>
            <param name="anyPoint">anyPoint</param>
            <returns>Normalized point</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.Dot(Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Point)">
            <summary>
            Return a scale as result of the dot product from two points
            </summary>
            <param name="value1">Point 1</param>
            <param name="value2">Point 2</param>
            <returns>Result of the dot product</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.Dot(Delta.Utilities.Datatypes.Point@,Delta.Utilities.Datatypes.Point@,System.Single@)">
            <summary>
            Return a scale as result of the do product from two points
            </summary>
            <param name="value1">Point 1</param>
            <param name="value2">Point 2</param>
            <param name="result">Result of the dot product</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.Distance(Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Point)">
            <summary>
            Calculate the distance from two points resulting in scale value
            </summary>
            <param name="value1">Point 1</param>
            <param name="value2">Point 2</param>
            <returns>Distance between points</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.Distance(Delta.Utilities.Datatypes.Point@,Delta.Utilities.Datatypes.Point@,System.Single@)">
            <summary>
            Calculate the distance from two points resulting in scale value
            </summary>
            <param name="value1">Point 1</param>
            <param name="value2">Point 2</param>
            <param name="result">Distance between points</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.DistanceSquared(Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Point)">
            <summary>
            Calculate the squared distance from two points. This is faster than
            using Distance because we don't need to take the square root.
            </summary>
            <param name="value1">Point 1</param>
            <param name="value2">Point 2</param>
            <returns>Squared distance between points</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.DistanceSquared(Delta.Utilities.Datatypes.Point@,Delta.Utilities.Datatypes.Point@,System.Single@)">
            <summary>
            Calculate the squared distance from two points resulting in scale value
            </summary>
            <param name="value1">Point 1</param>
            <param name="value2">Point 2</param>
            <param name="result">Squared distance between points</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.Transform(Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Matrix)">
            <summary>
            Transform point by multiplying it with a matrix.
            Note: This is slower than using the ref version of Transform.
            </summary>
            <param name="matrix">Matrix for the transformation</param>
            <param name="position">Position to transform</param>
            <returns>Transformed point resulting from matrix*position</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.Transform(Delta.Utilities.Datatypes.Point@,Delta.Utilities.Datatypes.Matrix@,Delta.Utilities.Datatypes.Point@)">
            <summary>
            Transform point by multiplying it with a matrix
            </summary>
            <param name="matrix">Matrix for the transformation</param>
            <param name="position">Position to transform</param>
            <param name="result">Transformed point resulting from matrix*position
            </param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.TransformNormal(Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Matrix)">
            <summary>
            Transform normal by multiplying it with a matrix.
            Note: This is slower than using the ref version of Transform.
            </summary>
            <param name="normal">Position to transform</param>
            <param name="matrix">Matrix for the transformation</param>
            <returns>Transformed normal</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.TransformNormal(Delta.Utilities.Datatypes.Point@,Delta.Utilities.Datatypes.Matrix@,Delta.Utilities.Datatypes.Point@)">
            <summary>
            Transform normal by multiplying it with a matrix
            </summary>
            <param name="normal">Position to transform</param>
            <param name="matrix">Matrix for the transformation</param>
            <param name="result">Transformed normal</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.ComputeNormal(Delta.Utilities.Datatypes.Point)">
            <summary>
            Computes the normal of the given 2D vector. For more information see:
            http://www.sciface.com/education/data/web/Beschreibung-von-Geraden.html
            http://www.matheboard.de/archive/23062/thread.html
            </summary>
            <param name="vector2D">2D Vector</param>
            <returns>Normal, which is just (-Y, X)</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.Lerp(Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Point,System.Single)">
            <summary>
            Performs a linear interpolation between two points. 
            </summary>
            <param name="amount">Amount to lerp</param>
            <param name="value1">Point 1</param>
            <param name="value2">Point 2</param>
            <returns>Interpolated point between both points</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.Lerp(Delta.Utilities.Datatypes.Point@,Delta.Utilities.Datatypes.Point@,System.Single,Delta.Utilities.Datatypes.Point@)">
            <summary>
            Performs a linear interpolation between two points. 
            </summary>
            <param name="amount">Amount to lerp</param>
            <param name="value1">Point 1</param>
            <param name="value2">Point 2</param>
            <param name="result">Interpolated point between both points</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.Min(Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Point)">
            <summary>
            Returns the minimum of both points (X and Y are handled seperately).
            -> A(2,4), B(4,1) => Min(2,1)
            </summary>
            <param name="value1">Point 1</param>
            <param name="value2">Point 2</param>
            <returns>Minimum value of X and Y</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.Max(Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Point)">
            <summary>
            Returns the maximum of both points (X and Y are handled seperately).
            -> A(2,4), B(4,1) => Max(4,4)
            </summary>
            <param name="value1">Point 1</param>
            <param name="value2">Point 2</param>
            <returns>Maximum value of X and Y</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.Clamp(Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Point)">
            <summary>
            Clamp
            </summary>
            <param name="value">Value</param>
            <param name="min">Minimum</param>
            <param name="max">Maximum</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.FromString(System.String)">
            <summary>
            Convert a string to a Point. The expected format is (x.x, y.y), but
            it works fine with ToColladaString or ToCommaString strings too :)
            </summary>
            <param name="pointString">The string in the correct format
            (with or without brackets, comma or space seperated).</param>
            <returns>
            Point from the given string or Zero if parsing failed.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.IsPointInside(Delta.Utilities.Datatypes.Point@,Delta.Utilities.Datatypes.Rectangle@)">
            <summary>
            Is the given point inside the rectangle?
            </summary>
            <param name="point">Point to check</param>
            <param name="rect">Rectangle to check against</param>
            <returns>True if the point is inside the rectangle.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.IsCircleInside(Delta.Utilities.Datatypes.Point@,System.Single,Delta.Utilities.Datatypes.Rectangle@)">
            <summary>
            Check if a circle is inside a rectangle or not.
            </summary>
            <param name="centerPoint">The center point of the circle.</param>
            <param name="radius">The radius of the cirlce.</param>
            <param name="rect">The rectangle to check if the circle lays in.</param>
            <returns>
            True if the circle is in the rectangle, otherwise False.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.GetRandomPoint">
            <summary>
            Get random point with x and y between 0 and 1.
            </summary>
            <returns>Random point with x and y between 0 and 1</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.GetRandomPoint(System.Single,System.Single)">
            <summary>
            Get random point with x and y between minValue and maxValue.
            </summary>
            <param name="maxValue">Maximum value</param>
            <param name="minValue">Mininum value</param>
            <returns>
            Random point with x and y between minValue and maxValue.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.GetUnitCirclePosition(System.Single)">
            <summary>
            Returns the represented position by the given degree on the unit circle
            (-> degree of: 0/360 = top, 90 = right, 180 = bottom, 270 = left)
            </summary>
            <param name="degreeValue">Degree value</param>
            <returns>Unit vector pointing in the given direction.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.GetRotation(Delta.Utilities.Datatypes.Point,System.Boolean)">
            <summary>
            This will convert the given unit-circle position in an unit-circle
            rotation (-> top = 0/360, right = 90, bottom = 180, left = 270 degree).
            If the given position isn't normalized yet, then just set the second
            parameter to 'true'.
            <para />
            Note: When unitCirclePosition is Point.Zero, 0 is returned.
            </summary>
            <param name="unitCirclePosition">Unit circle position</param>
            <param name="isNormalizationNeeded">Is normalization needed</param>
            <returns>The unit circle rotation (top=0, right=90, etc.)</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.GetRotation(Delta.Utilities.Datatypes.Point)">
            <summary>
            This will convert the given unit-circle position in an unit-circle
            rotation (-> top = 0/360, right = 90, bottom = 180, left = 270 degree).
            The given position will be normalized automatically, if that isn't
            wished or needed, then just use the other overload with 'false' at the
            second parameter.
            </summary>
            <param name="unitCirclePosition">Unit circle position</param>
            <returns>Point</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.AngleBetweenPoints(Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Point)">
            <summary>
            Angle between points in degrees, pretty much the same as
            AngleBetweenVectors, just in 2D:
            http://www.euclideanspace.com/maths/algebra/vectors/angleBetween/index.htm
            RadiansToDegrees(atan2(a.y,a.x) - atan2(b.y,b.x)) would only give
            you 0-180 degrees, but we want full 0-360 degrees with Acos :)
            <para />
            Note: If one of the points is zero the method we will return 0.0f.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>Angle between the two vectors in the range [0, 360]</returns>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Point.X">
            <summary>
            X coordinate.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Point.Y">
            <summary>
            Y coordinate.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.#ctor(System.Single)">
            <summary>
            Creates a 2D point
            </summary>
            <param name="setValue">setValue</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.#ctor(System.Single,System.Single)">
            <summary>
            Creates a 2D point
            </summary>
            <param name="setX">setX</param>
            <param name="setY">setY</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.#ctor(Delta.Utilities.Datatypes.Vector)">
            <summary>
            Creates a 2D point from a Vector (ignores Z)
            </summary>
            <param name="fromVector">fromVector</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.#ctor(System.IO.BinaryReader)">
            <summary>
            Create point
            </summary>
            <param name="reader">reader</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.Equals(Delta.Utilities.Datatypes.Point)">
            <summary>
            Equals check will check if the other point is nearly equals (using
            the MathHelper.Epsilon value, which is close to zero).
            </summary>
            <param name="other">Other point to check against</param>
            <returns>
            True if both points are almost equal, false if they are apart.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.Load(System.IO.BinaryReader)">
            <summary>
            Load the point values from a stream.
            </summary>
            <param name="reader">The stream that will be used.</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.Save(System.IO.BinaryWriter)">
            <summary>
            Saves the point to a stream.
            </summary>
            <param name="writer">The stream that will be used.</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.op_UnaryNegation(Delta.Utilities.Datatypes.Point)">
            <summary>
            Operator for negation
            </summary>
            <param name="value">Value to subtract</param>
            <returns>
            The returned point is the negative version of the input point.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.op_Equality(Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Point)">
            <summary>
            Operator for equality
            </summary>
            <param name="value1">value1</param>
            <param name="value2">value2</param>
            <returns>Returns True if the points are equal, otherwise False.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.op_Inequality(Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Point)">
            <summary>
            Operator for inequality
            </summary>
            <param name="value1">value1</param>
            <param name="value2">value2</param>
            <returns>Returns True if the points are unequal, otherwise False.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.op_Addition(Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Point)">
            <summary>
            Operator for addition
            </summary>
            <param name="value1">value1</param>
            <param name="value2">value2</param>
            <returns>Returns a point as the result of the addition.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.op_Subtraction(Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Point)">
            <summary>
            Operator for subtraction
            </summary>
            <param name="value1">Point 1</param>
            <param name="value2">Point 2</param>
            <returns>Result of the subtraction</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.op_Multiply(Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Point)">
            <summary>
            Operator for multiplication points
            </summary>
            <param name="value1">Point 1</param>
            <param name="value2">Point 2</param>
            <returns>Result of the multiplication</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.op_Multiply(Delta.Utilities.Datatypes.Point,System.Single)">
            <summary>
            Operator for multiplication a point with a float as scaling
            </summary>
            <param name="scaleFactor">scaleFactor</param>
            <param name="value">value</param>
            <returns>Result of the multiplication</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.op_Multiply(System.Single,Delta.Utilities.Datatypes.Point)">
            <summary>
            Operator for multiplication a float as scaling with a point
            </summary>
            <param name="scaleFactor">scaleFactor</param>
            <param name="value">value</param>
            <returns>Result of the multiplication</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.op_Division(Delta.Utilities.Datatypes.Point,System.Single)">
            <summary>
            Operator to divide a point with a float.
            </summary>
            <param name="value">Value</param>
            <param name="divisor">Divisor</param>
            <returns>Result of the division</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.op_Division(System.Single,Delta.Utilities.Datatypes.Point)">
            <summary>
            Operator to divide a point with a float.
            </summary>
            <param name="divisor">Divisor</param>
            <param name="value">Value</param>
            <returns>Result of the division</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.op_Implicit(Delta.Utilities.Datatypes.Size)~Delta.Utilities.Datatypes.Point">
            <summary>
            Operator to implicit convert Size to Point.
            </summary>
            <param name="anySize">Any size</param>
            <returns>
            Point created from the size (x from width, y from height).
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.CloneX(System.Single)">
            <summary>
            Returns a new Point with the same X value as before and a new Y
            changed by the given offset (parameter) value.
            </summary>
            <param name="setOffsetOfY">The offset to compute the new Y value
            for the cloned point.</param>
            <returns>New cloned Point instance.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.CloneY(System.Single)">
            <summary>
            Returns a new Point with the same Y value as before and a new X
            changed by the given offset (parameter) value.
            </summary>
            <param name="setOffsetOfX">The offset to compute the new X value for
            the cloned point.</param>
            <returns>New cloned Point instance.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.Equals(System.Object)">
            <summary>
            Check if another object is a point and equals to this point.
            </summary>
            <param name="obj">Object to compare with</param>
            <returns>
            True if the object is a Point and equal to this point.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.NearlyEquals(Delta.Utilities.Datatypes.Point,System.Single)">
            <summary>
            NearlyEquals
            </summary>
            <param name="other">Other point we wan't check equality with.</param>
            <param name="epsilon">A very small value defining the range in which
            the two points can differ to still be nearly equal enough.</param>
            <returns>Value indicating the equality of two vectors</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.GetHashCode">
            <summary>
            Get hash code
            </summary>
            <returns>Hash code from X and Y values</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.Resize(System.Single)">
            <summary>
            Resize this point to given length and returns the new Point
            </summary>
            <param name="length">length</param>
            <returns>Resized point</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.Rotate(System.Single)">
            <summary>
            Rotates this instance around the origin, returns the 
            </summary>
            <param name="angle">Angle to rotate in degree</param>
            <returns>Rotated point with given direction from angle</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.ToString">
            <summary>
            To string
            </summary>
            <returns>String with braces, e.g. "(1.0, 2.3)"</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.ToString(System.String,System.String)">
            <summary>
            To string
            </summary>
            <returns>String with custom braces, e.g. "(1.0, 2.3)"</returns>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Point.XProperty">
            <summary>
            Property-wrapper for using the X field in the editor.
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Point.YProperty">
            <summary>
            Property-wrapper for using the Y field in the editor
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Point.Length">
            <summary>
            Length
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Point.LengthSquared">
            <summary>
            Length squared
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Point.PointTests">
            <summary>
            Tests
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.SizeOf">
            <summary>
            Checks if the size of Point is exactly 8 bytes (2 floats: X and Y)
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.DistanceSquared">
            <summary>
            DistanceSquared
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.Distance">
            <summary>
            Distance
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.Lerp">
            <summary>
            Lerp
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.TransformNormal">
            <summary>
            TransformNormal
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.Transform">
            <summary>
            Transform
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.Dot">
            <summary>
            Dot
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.Length">
            <summary>
            Length
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.LengthSquared">
            <summary>
            Length squared
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.Negation">
            <summary>
            Negation
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.Equality">
            <summary>
            Equality
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.Addition">
            <summary>
            Addition
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.Substraction">
            <summary>
            Substraction
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.Multiplication">
            <summary>
            Multiplication
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.Division">
            <summary>
            Division
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.NearlyEquals">
            <summary>
            Nearly equals
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.Normalize">
            <summary>
            Normalize
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.Min">
            <summary>
            Minimum
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.Max">
            <summary>
            Maximum
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.Rotate">
            <summary>
            Rotate
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.GetRotation">
            <summary>
            Get rotation
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Point.PointTests.ToString">
            <summary>
            To string
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Advanced.ContainmentType">
            <summary>
            Containment type for collision checking in BoundingBox and
            BoundingSphere with their Intersects and Contains methods.
            <para />
            Can also be casted to a boolean to just return if there are intersecting
            or are contained in each other (true) or disjoint otherwise (false).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.ContainmentType.None">
            <summary>
            Two objects are not touching and located with distance between them.
            There is no intersection going on and they are also not contained in
            each other.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.ContainmentType.Partial">
            <summary>
            The two physics objects intersect with each other because they
            partially are contained in each other.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.ContainmentType.Fully">
            <summary>
            One physics object is fully contains the calling object, e.g.
            <code>
            simpleBox.Contains(someSphere) == ContainmentType.Fully for
            BoundingBox simpleBox = new BoundingBox(Vector.Zero, Vector.One);
            BoundingSphere someSphere = new BoundingSphere(Vector.Half, 0.1f);
            </code>
            </summary>
        </member>
        <member name="T:Delta.Utilities.Helpers.ArrayHelper">
            <summary>
            Array helper class adding extra functionality to the System.Array class
            and similar classes (lists). Most useful methods here are resizing
            arrays, building sub arrays and adding arrays together.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.GetSubArray``1(``0[],System.Int32,System.Int32)">
            <summary>
            Get sub array (similar to String.Substring), again there is no function
            for arrays to do that easily.
            </summary>
            <typeparam name="T">Type of array</typeparam>
            <param name="length">Length of data to copy (can be smaller than
            originalData array size)</param>
            <param name="originalData">Data to grab from (full array)</param>
            <param name="startIndex">Start index for originalData</param>
            <returns>New array of type T with the specified length</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><c>startIndex</c> is out of range.</exception>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.GetSubArray``1(``0[],System.Int32)">
            <summary>
            Get sub array (similar to String.Substring), again there is no function
            for arrays to do that easily.
            </summary>
            <typeparam name="T">Type of array</typeparam>
            <param name="originalData">Original Data</param>
            <param name="startIndex">Start Index</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.Resize(System.Array,System.Int32)">
            <summary>
            Resize array, will create a new array with specified size, then copy
            all data (with Array.Copy, which is fast) and return the new array.
            There is no other faster possibility for managed arrays in C#!
            </summary>
            <param name="sourceArray">Source array to grab data from, can be
            bigger or smaller.</param>
            <param name="newLength">New length for the array we return here</param>
            <returns>The reduced or increased array</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.Resize``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            If you need to resize a generic list into another generic list,
            use Resize. But Resize is slow, the generation of the new list
            takes some time, use this function to speed that up to 50% faster.
            It will return a simple array, if this is whats you need you
            have almost as good as the performance of the normal Resize method.
            </summary>
            <typeparam name="T">Type for the sourceArray list</typeparam>
            <param name="sourceArray">Input</param>
            <param name="newLength">New desired length for resized array</param>
            <returns>Resized array, if you need a list, use ResizeSlow</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.IsEqualWithoutOrder``1(``0[],``0[])">
            <summary>
            Returns 'true' if both list matches, this means, they have the same
            elements but the order of the elements doesn't matter.
            </summary>
            <typeparam name="T">Type of arrays to compare</typeparam>
            <param name="list1">List 1</param>
            <param name="list2">List 2</param>
            <returns>Returns 'true' if both list matches</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.Compare``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>
            Compare 2 generic Lists. Returns 'true' if both list matches, this
            means, they have the same elements in the same order.
            </summary>
            <typeparam name="T">Type of lists to compare</typeparam>
            <param name="list1">List 1</param>
            <param name="list2">List 2</param>
            <returns>Returns 'true' if both list matches</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.Compare(System.Byte[],System.Byte[])">
            <summary>
            Compare 2 arrays, optimized for bytes, which are compared quite often.
            Returns 'true' if both list matches, this means, they have the same
            elements in the same order.
            </summary>
            <param name="list1">First bytes array</param>
            <param name="list2">Second bytes array</param>
            <returns>Returns 'true' if both list matches</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.Add(System.Array,System.Array)">
            <summary>
            Adds 2 arrays, pretty simple, but not implemented in Array!
            </summary>
            <param name="array1">Array 1</param>
            <param name="array2">Array 2</param>
            <returns>Big new array containing array1 and array2</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.Add(System.Byte[],System.Byte[])">
            <summary>
            Adds 2 arrays, pretty simple, but not implemented in Array!
            </summary>
            <param name="array1">Array 1</param>
            <param name="array2">Array 2</param>
            <returns>Big new array containing array1 and array2</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.Add``1(System.Collections.Generic.List{``0},System.Collections.Generic.List{``0})">
            <summary>
            For generic lists we can simply use .AddRange to do this!
            Use this method only if you want to create a new list from the
            first list + all data in the second list.
            </summary>
            <typeparam name="T">Type of lists</typeparam>
            <param name="list1">List 1</param>
            <param name="list2">List 2</param>
            <returns>Big new array containing array1 and array2</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.ConvertStringToIntArray(System.String)">
            <summary>
            Convert string data to int array, string must be in the form
            "1, 3, 8, 7", etc. WriteArrayData is the complementary function.
            </summary>
            <param name="text">Input text to be split up, if empty this method
            will return an empty array.</param>
            <returns>int array, will be null if string is invalid!</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.ConvertByteArrayToIntArray(System.Byte[])">
            <summary>
            Convert byte array to int array, we use 4 bytes and combine them
            into 1 int (first byte gets shifted 24 bits, next 16, next 8, next 0)
            </summary>
            <param name="byteArray">Byte Array</param>
            <returns>Integer array, has byteArray.Length/4 Length!</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.ConvertIntArrayToByteArray(System.Int32[])">
            <summary>
            Convert int array to byte array, we split each int into 4 bytes
            (first byte gets shifted 24 bits, next 16, next 8, next 0)
            </summary>
            <param name="intArray">Integer array</param>
            <returns>Byte array, has intArray.Length*4 Length!</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.ConvertByteArrayToString(System.Byte[])">
            <summary>
            Convert a byte array to a string, converts each byte to a char
            and add them up to the returning string.
            Useful for generating string data from a byte stream (ANSI style).
            </summary>
            <param name="byteArray">Byte array to write from (interpreted as char
            values)</param>
            <returns>String with all char values from the byteArray</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.ToText(System.Collections.Generic.IList{System.Char})">
            <summary>
            Converts the list of chars to a string.
            </summary>
            <param name="charList">Char list</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.RemoveIndex``1(``0[],System.Int32)">
            <summary>
            Remove a specific array element and return reduced array,
            often used in ArrayLists, but its more complicated for normal arrays!
            <para />
            Note: This method is slower than using dynamic lists.
            </summary>
            <typeparam name="T">Type of array data</typeparam>
            <param name="originalArray">Original Array</param>
            <param name="index">Index in originalArray</param>
            <returns>New array with the index removed</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.SetBitInByteArray(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Set bit in byte array
            </summary>
            <param name="byteArray">Byte Array</param>
            <param name="pos">Position to set bit (in bit position)</param>
            <param name="val">Value to set, either true (1) or false (0)</param>
            <exception cref="T:System.IndexOutOfRangeException">
            Throws index out of range if the position is more than array.Length*8.
            </exception>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.GetBitInByteArray(System.Byte[],System.Int32)">
            <summary>
            Get bit in byte array
            </summary>
            <param name="byteArray">Byte Array</param>
            <param name="pos">Position to set bit (in bit position)</param>
            <returns>Value to at bit position in byteArray, true (1) or false (0)
            </returns>
            <exception cref="T:System.IndexOutOfRangeException">
            Throws index out of range if the position is more than array.Length*8.
            </exception>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.BuildCompressedByteArrayFromBoolArray(System.Boolean[])">
            <summary>
            Creates a byte array from bool array. E.g if bool array has 8 entries
            we can compress this into one single byte, if it has 21 entries we can
            use 3 bytes, etc.!
            </summary>
            <param name="boolArray">Bool array</param>
            <returns>Byte array containing all bits from the boolArray</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.FillBoolArrayFromCompressedByteArray(System.Boolean[],System.Byte[])">
            <summary>
            Rebuilds a bool array compressed with
            BuildCompressedByteArrayFromBoolArray. E.g. we can extract 8 bool
            entries from a byte or 14 entries from 2 bytes, etc.
            </summary>
            <param name="boolArray">Bool array</param>
            <param name="byteArray">Byte array, with is 8 times smaller than
            boolArray</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.AreCollectionsEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines if the two collections contain equal items in the same 
            order. The two collections do not need to be of the same type; it is
            permissible to compare an array and an OrderedBag, for instance.
            </summary>
            <remarks>The default sense of equality for T is used, as defined by T's
            implementation of IComparable&lt;T&gt;.Equals or object.Equals.
            </remarks>
            <typeparam name="T">The type of items in the collections.</typeparam>
            <param name="collection1">The first collection to compare.</param>
            <param name="collection2">The second collection to compare.</param>
            <returns>True if the collections have equal items in the same order.
            If both collections are empty, true is returned.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.AreCollectionsEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines if the two collections contain equal items in the same
            order. The passed instance of IEqualityComparer&lt;T&gt; is used for
            determining if two items are equal.
            </summary>
            <typeparam name="T">The type of items in the collections.</typeparam>
            <param name="collection1">The first collection to compare.</param>
            <param name="collection2">The second collection to compare.</param>
            <param name="equalityComparer">The IEqualityComparer&lt;T&gt; used to
            compare items for equality. 
            Only the Equals member function of this interface is called.</param>
            <returns>True if the collections have equal items in the same order.
            If both collections are empty, true is returned.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection1"/>,
            <paramref name="collection2"/>, or <paramref name="equalityComparer"/>
            is null.</exception>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.ToArray``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Create an array with the items in a collection.
            </summary>
            <remarks>If <paramref name="collection"/> implements
            ICollection&lt;T&gt;T, then ICollection&lt;T&gt;.CopyTo() is used to
            fill the array. Otherwise, the IEnumerable&lt;T&gt;.GetEnumerator()
            is used to fill the array.</remarks>
            <typeparam name="T">Element type of the collection.</typeparam>
            <param name="collection">Collection to create array from.</param>
            <returns>An array with the items from the collection, in enumeration
            order.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/>
            is null.</exception>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.Write(System.Byte[])">
            <summary>
            Returns a string with the array data separated with commas.
            This is the byte array version.
            </summary>
            <param name="array">Byte array</param>
            <returns>A string with the byte array data, comma separated</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.Write(System.Int32[])">
            <summary>
            Returns a string with the array data separated with commas.
            This is the int array version.
            </summary>
            <param name="array">Integer array</param>
            <returns>A string with the int array data, comma separated</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.Write(System.Array)">
            <summary>
            Returns a string with the array data separated with commas.
            This is the general array version.
            </summary>
            <param name="array">Array of any type</param>
            <returns>A string with the array data, comma separated</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.Write(System.Array,System.Int32)">
            <summary>
            Returns a string with the array data separated with commas.
            This is the general array version with maxLength bounding (will return
            string with max. this number of entries).
            </summary>
            <param name="list">List</param>
            <param name="maxLength">MaxLength</param>
            <returns>A string with the array data, comma separated</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.Write(System.Collections.ICollection)">
            <summary>
            Returns a string with the array data separated with commas.
            </summary>
            <param name="list">List</param>
            <returns>A string with the array data, comma separated</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.Write(System.Collections.ICollection,System.String)">
            <summary>
            Returns a string with the array data with given separator.
            </summary>
            <param name="list">List to write out</param>
            <param name="separator">Separator</param>
            <returns>A string with the array data, comma separated</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.Write``1(System.Collections.Generic.List{``0})">
            <summary>
            Returns a string with the array data separated with commas.
            This is the List&lt;T&gt; version.
            </summary>
            <typeparam name="T">Type of list data</typeparam>
            <param name="list">List to write out</param>
            <returns>A string with the list data, comma separated</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.Write``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Returns a string with the array data separated with commas.
            This is the List&lt;T&gt; version with a maximum count.
            </summary>
            <typeparam name="T">Type of list data</typeparam>
            <param name="count">Count</param>
            <param name="list">List</param>
            <returns>A string with the list data, comma separated</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.Write``1(System.Collections.Generic.List{``0},System.String)">
            <summary>
            Returns a string with the array data with given separator.
            This is the List&lt;T&gt; version.
            </summary>
            <typeparam name="T">Type of list data</typeparam>
            <param name="list">List</param>
            <param name="separator">Separator</param>
            <returns>A string with the list data, comma separated</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.Write(System.Collections.IEnumerable)">
            <summary>
            Returns a string with the array data separated with commas.
            This is the enumerable class version.
            </summary>
            <param name="enumerableClass">Enumerable class</param>
            <returns>A string with the list data, comma separated</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.Write(System.Collections.IEnumerable,System.String)">
            <summary>
            Returns a string with the array data separated with commas.
            This is the enumerable class version.
            </summary>
            <param name="enumerableClass">Enumerable class</param>
            <param name="separator">Separator</param>
            <returns>A string with the list data, comma separated</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.WriteFirstAndLastValues(System.Array,System.Int32)">
            <summary>
            Write array data first and last values, e.g. the first 10 and the
            last 10 values of a really long array (e.g. a network package).
            All values are separated by commas.
            <para />
            Note: If the array has less entries than numberOfItemsAtStartAndEnd
            times two, we will just display the whole array.
            </summary>
            <param name="list">List to grab data from, can be huge</param>
            <param name="numberOfItemsAtStartAndEnd">Number of items at start and
            end we want to have in the output string</param>
            <returns>A string with the list data, comma separated</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.ConcatenateCollections``1(System.Collections.Generic.IEnumerable{``0}[])">
            <summary>
            Concatenates all the items from several collections. The collections
            need not be of the same type, but must have the same item type.
            </summary>
            <param name="collections">Set of collections to concatenate.
            In many languages, this parameter can be specified as several
            individual parameters.</param>
            <returns>An IEnumerable that enumerates all the items in each of the
            collections, in order.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.Count``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Count the number of items in an IEnumerable&lt;T&gt; collection. If 
            a more specific collection type is being used, it is more efficient to
            use the Count property, if one is provided.
            </summary>
            <remarks>If the collection implements ICollection&lt;T&gt;, this method
            simply returns ICollection&lt;T&gt;.Count. Otherwise, it enumerates all
            items and counts them.</remarks>
            <param name="collection">The collection to count items in.</param>
            <returns>The number of items in the collection.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="collection"/>
            is null.</exception>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.CountEqual``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Counts the number of items in the collection that are equal to
            <paramref name="find"/>.
            </summary>
            <remarks>The default sense of equality for T is used, as defined by
            T's implementation of IComparable&lt;T&gt;.Equals or object.Equals.
            </remarks>
            <param name="collection">The collection to count items in.</param>
            <param name="find">The item to compare to.</param>
            <returns>The number of items in the collection that are equal to
            <paramref name="find"/>.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.CountEqual``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Counts the number of items in the collection that are equal to
            <paramref name="find"/>.
            </summary>
            <param name="collection">The collection to count items in.</param>
            <param name="find">The item to compare to.</param>
            <param name="equalityComparer">The comparer to use to determine if
            two items are equal. Only the Equals member function will be called.
            </param>
            <returns>The number of items in the collection that are equal to
            <paramref name="find"/>.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="collection"/> or
            <paramref name="equalityComparer"/> is null.</exception>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.IsValidIndex(System.Int32,System.Array)">
            <summary>
            Returns 'true' if the given index of the array stays in the
            "array range".
            </summary>
            <param name="arrayIndex">Array index</param>
            <param name="anyArray">Any array</param>
            <returns>'true' if the given index of the array stays in the range
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.Pop``1(System.Collections.Generic.List{``0})">
            <summary>
            Returns the top most item of the list and removes it from the list.
            Warning: This method is a bit slow because we need to change the list
            and removing the last entry is not as fast as for Collections like
            Queue, use it with care.
            </summary>
            <typeparam name="T">The object type in the list</typeparam>
            <param name="list">The list we want to pop from</param>
            <returns>The top most object of the list</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.IsNullOrEmpty(System.Array)">
            <summary>
            Helper method for a common check if an array is null or has no
            elements. Same as String.IsNullOrEmpty
            </summary>
            <param name="array">The array to check.</param>
            <returns>True if array is null or empty.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.IsNullOrEmpty``1(System.Collections.Generic.List{``0})">
            <summary>
            Helper method for a common check if a list is null or has no
            elements. Same as String.IsNullOrEmpty
            </summary>
            <param name="list">The list to check.</param>
            <returns>True if list is null or empty.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.SafeGet``2(System.Collections.Generic.Dictionary{``0,System.Object},``0)">
            <summary>
            Gets given property value in a safe way (not found? then default is
            returned, otherwise the found object is returned).
            </summary>
            <param name="dict">Dictionary</param>
            <param name="key">Key</param>
            <returns>Value from dictionary or default value if not found</returns>
        </member>
        <member name="F:Delta.Utilities.Helpers.ArrayHelper.FreeDataWhenMemoryIsLow">
            <summary>
            Event handler everyone can attach to for freeing unneeded memory.
            The primary user of this delegate are all Cache classes, which will
            allow to free cache data when memory is low. All data will be reloaded
            internally, so we just need some extra CPU time to recalculate
            everything, but we can save a lot of memory without having to go to
            real data that is currently needed, which is much harder to optimize.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.ArrayHelper.NumberOfCachesGenerated">
            <summary>
            Helper variable to keep track on how many caches were generated. Only
            used for warnings, debugging and profiling, but cannot be inside the
            generic Cache class because each input/output type combination would
            have its own counter, we want to know the overall number of caches.
            </summary>
        </member>
        <member name="T:Delta.Utilities.Helpers.ArrayHelper.FreeMemoryDelegate">
            <summary>
            Parameterless delegate for code that should be invoked by the
            FreeDataWhenMemoryIsLow event handler.
            </summary>
        </member>
        <member name="T:Delta.Utilities.Helpers.ArrayHelper.ArrayHelperTests">
            <summary>
            ArrayHelper tests
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.ArrayHelperTests.CompareArrays">
            <summary>
            Test compare arrays. Note: Too slow for a dynamic unit test.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.ArrayHelperTests.IsNullOrEmpty">
            <summary>
            Test the IsNullOrEmpty method.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.ArrayHelperTests.SafeGet">
            <summary>
            Test the SafeGet method.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.ArrayHelperTests.Resize">
            <summary>
            Test resize
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.ArrayHelperTests.IsEqual">
            <summary>
            Is equal
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.ArrayHelperTests.AddArrays">
            <summary>
            Test add arrays
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.ArrayHelperTests.RemoveIndex">
            <summary>
            Test remove index
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.ArrayHelperTests.GetSubArray">
            <summary>
            Test get sub array
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.ArrayHelperTests.ConcatenateCollections">
            <summary>
            Test concatenate collections
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.ArrayHelperTests.AreCollectionsEqual">
            <summary>
            Test are collections equal
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.ArrayHelperTests.ToArray">
            <summary>
            Test to array
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.ArrayHelperTests.IsValidIndex">
            <summary>
            Is valid index
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.ArrayHelper.ArrayHelperTests.ConvertStringToIntArray">
            <summary>
            Convert string to int array
            </summary>
        </member>
        <member name="T:Delta.Utilities.Helpers.MathHelper">
            <summary>
            Math helper class. Provides the same functionality as System.Math, but
            instead of using doubles for all the functions here are using floats!
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.MathHelper.Epsilon">
            <summary>
            Epsilon is a small comparison offset for NearlyEqual checks.
            Note: Other frameworks use float.Epsilon (1.192092896e-07f), but we
            work great with this value too, so we should keep it this way.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.MathHelper.E">
            <summary>
            E constant as a float (2.718282).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.MathHelper.Pi">
            <summary>
            Pi constants, same as PI (double), but as a float here (less precise),
            please note that we usually use degrees and not radians in the engine!
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.MathHelper.PiDouble">
            <summary>
            Pi times two for getting around a whole circle (360 degrees).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.MathHelper.PiHalf">
            <summary>
            Pi Half, which represents 90 degrees.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.MathHelper.PiQuarter">
            <summary>
            Pi Quarter, which represents 45 degrees.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.MathHelper.OneThird">
            <summary>
            Represents just the fraction of 1/3 or in decimal 0.333333
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.MathHelper.InvalidIndex">
            <summary>
            The default value for an invalid index check (-1), very often used to
            set invalid and initial values to integer values to make sure that we
            initialize them first before using them, e.g. for shader parameters or
            for indices in precomputed arrays, but also often used by the .NET
            framework, e.g String.IndexOf returns -1 for not found.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.MathHelper.Sin45">
            <summary>
            Sinus value of 45 Degree
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.MathHelper.HalfShortMaxValue">
            <summary>
            Half of the short max. value (32768), which is 16392. This is used
            for the calculation of ViewProjection2DViaShorts and in the
            MaterialManager to setup compressed vertices.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.NearlyEqual(System.Single,System.Single)">
            <summary>
            Compares two floats if they are almost equal, taking an Epsilon offset
            (see Math.Epsilon) into account.
            </summary>
            <param name="value1">first float</param>
            <param name="value2">second float</param>
            <returns>Bool: True if Nearly Equal</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.InvertScalar(System.Single)">
            <summary>
            Invert scalar safely.
            </summary>
            <param name="value">Value</param>
            <returns>1.0f</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Clamp(System.Int32)">
            <summary>
            Clamps the value between [0, 1].
            </summary>
            <param name="value">Value</param>
            <returns>Clamp Value</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>
            Clamps the value between the given range [minimum, maximum].
            </summary>
            <param name="max">Max</param>
            <param name="min">Min</param>
            <param name="value">Value</param>
            <returns>value between the given range [minimum, maximum]</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Clamp(System.Single)">
            <summary>
            Clamps the value between [0.0, 1.0].
            </summary>
            <param name="value">Value</param>
            <returns>value between [0.0, 1.0]</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Clamp(System.Single,System.Single,System.Single)">
            <summary>
            Clamps the value between the given range [minimum, maximum].
            </summary>
            <param name="max">Max</param>
            <param name="min">Min</param>
            <param name="value">Value</param>
            <returns>value between the given range [minimum, maximum]</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Wrap(System.Int32,System.Int32,System.Int32)">
            <summary>
            Wrap the value between the given range [minimun, maximum].
            </summary>
            <param name="max">Max</param>
            <param name="min">Min</param>
            <param name="value">Value</param>
            <returns>value between the given range [minimun, maximum]</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Wrap(System.Single,System.Single,System.Single)">
            <summary>
            Wrap the value between the given range [minimun, maximum].
            </summary>
            <param name="max">Max</param>
            <param name="min">Min</param>
            <param name="value">Value</param>
            <returns>The wrapped Value</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Distance(System.Single,System.Single)">
            <summary>
            Distance between two float values.
            </summary>
            <param name="value1">First float value</param>
            <param name="value2">Second float value</param>
            <returns>Distance between the two values, always positive</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Min(System.Single,System.Single)">
            <summary>
            Returns the smaller of two values.
            </summary>
            <param name="value1">Value 1</param>
            <param name="value2">Value 2</param>
            <returns>the smaller of two values</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Min(System.Single,System.Single,System.Single)">
            <summary>
            Returns the smaller of three values.
            </summary>
            <param name="value1">Value 1</param>
            <param name="value2">Value 2</param>
            <param name="value3">Value 3</param>
            <returns>Returns the smaller of three values</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Min(System.Int32,System.Int32)">
            <summary>
            Returns the smaller of two values.
            </summary>
            <param name="value1">Value 1</param>
            <param name="value2">Value 2</param>
            <returns>Returns the smaller of two values</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Min(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the smaller of three values.
            </summary>
            <param name="value1">Value1</param>
            <param name="value2">Value2</param>
            <param name="value3">Value3</param>
            <returns>eturns the smaller of three values</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Max(System.Int32,System.Int32)">
            <summary>
            Returns the bigger one of the two values.
            </summary>
            <param name="value1">Value 1</param>
            <param name="value2">Value 2</param>
            <returns>Returns the bigger one of the two values</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Max(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the bigger one of the three values.
            </summary>
            <param name="value1">Value1</param>
            <param name="value2">Value2</param>
            <param name="value3">Value3</param>
            <returns>Returns the bigger one of the three values</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Max(System.Single,System.Single)">
            <summary>
            Returns the bigger one of the two values.
            </summary>
            <param name="value1">Value1</param>
            <param name="value2">Value2</param>
            <returns>Returns the bigger one of the two values</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Max(System.Single,System.Single,System.Single)">
            <summary>
            Returns the bigger one of the three values.
            </summary>
            <param name="value1">Value1</param>
            <param name="value2">Value2</param>
            <param name="value3">Value3</param>
            <returns>Returns the bigger one of the three values</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Lerp(System.Single,System.Single,System.Single)">
            <summary>
            Performs a linear interpolation between two values. 
            </summary>
            <param name="minValue">Value at "percentage = 0"</param>
            <param name="maxValue">Value at "percentage = 1"</param>
            <param name="percentage">Percentage in the range [0,1]</param>
            <returns>Float</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Lerp(System.Int32,System.Int32,System.Single)">
            <summary>
            Performs a linear interpolation between two values. 
            </summary>
            <param name="minValue">Value at "percentage = 0"</param>
            <param name="maxValue">Value at "percentage = 1"</param>
            <param name="percentage">Percentage in the range [0,1]</param>
            <returns>Float</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Lerp(System.Int64,System.Int64,System.Single)">
            <summary>
            Performs a linear interpolation between two values. 
            </summary>
            <param name="minValue">Value at "percentage = 0"</param>
            <param name="maxValue">Value at "percentage = 1"</param>
            <param name="percentage">Percentage in the range [0,1]</param>
            <returns>Float</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Sqrt(System.Single)">
            <summary>
            Sqrt
            </summary>
            <returns>Float</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Round(System.Single,System.Int32)">
            <summary>
            Rounds a value to a given position after the decimal point
            </summary>
            <param name="value">Value to round</param>
            <param name="decimals">Decimals</param>
            <returns>Float</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Round(System.Single)">
            <summary>
            Rounds a value to an int
            </summary>
            <param name="value">Value to round</param>
            <returns>Float</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Ceiling(System.Single)">
            <summary>
            Ceiling
            </summary>
            <param name="value">Value</param>
            <returns>Ceiling</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Abs(System.Single)">
            <summary>
            Returns the absolute value of a float
            </summary>
            <param name="value">Value</param>
            <returns>Returns the absolute value of a float</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Pow(System.Single,System.Single)">
            <summary>
            Pow
            </summary>
            <param name="power">Power</param>
            <param name="value">Value</param>
            <returns>Power</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.DegreeToRadians(System.Single)">
            <summary>
            Degree to radians
            </summary>
            <param name="degrees">Degrees</param>
            <returns>Degree to radians</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.RadiansToDegrees(System.Single)">
            <summary>
            Radians to degrees
            </summary>
            <param name="radians">Radians</param>
            <returns>radians</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Sin(System.Single)">
            <summary>
            Return the sinus of a degreeValue. Note: Most other math libraries use
            radians, please provide degrees here (used throughout the engine).
            </summary>
            <param name="degreeValue">Degree value for the sinus</param>
            <returns>Sinus of degreeValue</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Cos(System.Single)">
            <summary>
            Cosinus of a degreeValue, please use degree values here (not radians)
            </summary>
            <param name="degreeValue">Degree Value for the cosinus</param>
            <returns>Cosinus of degreeValue</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Tan(System.Single)">
            <summary>
            Get the tangent value, again using degrees, not radians.
            </summary>
            <param name="degreeValue">Degree value for the tagent</param>
            <returns>Tangent of degreeValue</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Asin(System.Single)">
            <summary>
            Returns the angle in degrees whose sin value is the specified value.
            </summary>
            <param name="value">Value for asin</param>
            <returns>Asin value in degrees from the value</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Acos(System.Single)">
            <summary>
            Returns the angle in degrees whose cos value is the specified value.
            </summary>
            <param name="value">Value for acos</param>
            <returns>Acos value in degrees from the value</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Atan(System.Single)">
            <summary>
            Returns the angle in degrees whose tangent is the specified number.
            Use Atan(x, y) if you do not want to calculate the quotient yourself.
            </summary>
            <param name="tangent">Tangent</param>
            <returns>Atan value in degrees from the tangent value</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Atan(System.Single,System.Single)">
            <summary>
            Returns the angle in degrees whose tangent is the quotient of two
            specified numbers. For more help see System.Math.Atan2 (which works in
            radians however).
            </summary>
            <param name="x">X value for atan2</param>
            <param name="y">Y value for atan2</param>
            <returns>Atan value in degrees from the x and y values</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.GetNextPowerOfTwo(System.Single)">
            <summary>
            Get the nearest power of two value that must be bigger or equal to
            value. Used for making sure textures are power of two. E.g.
            GetNextPowerOfTwo(128) is 128, GetNextPowerOfTwo(129) is 256, etc.
            </summary>
            <param name="value">Value</param>
            <returns>the nearest power of two value</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.IsPowerOfTwo(System.Single)">
            <summary>
            Is power of two
            </summary>
            <param name="value">Value</param>
            <returns>Is power of two</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.GetNearestMultiple(System.Int32,System.Int32)">
            <summary>
            Get the nearest multiple of 'multipleValue' from the value.
            </summary>
            <param name="multipleValue">Multiple Value</param>
            <param name="value">Value</param>
            <returns>the nearest multiple of 'multipleValue' from the 
            value</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.Sign(System.Single)">
            <summary>
            Implementation of Math.Sign, which works more solid than MonoTouches
            System.Math.Sign method, that crashes on the iPad if the value is not
            valid (e.g. NaN). This method will always return -1, 0 or 1.
            </summary>
            <param name="value">Value</param>
            <returns>-1, 0 or 1</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.ComputePercentageValue(System.Single,System.Single,System.Single)">
            <summary>
            Computes the percentage value in the range [0 = 0%, 1 = 100%] based on
            the given value related to the given value range.
            </summary>
            <param name="value">The value we want to calculate the percentage
            for.</param>
            <param name="minValue">The minimum allowed value.</param>
            <param name="maxValue">The maximum allowed value.</param>
            <returns>The percentage value in the range [0 = 0%, 1 = 100%] based
            on the given value related to the given value range.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.ComputeValue(System.Single,System.Single,System.Single)">
            <summary>
            Returns the exact value based on the given percentage related to the
            given value range.
            </summary>
            <param name="percentageValue">Percentage value in the range of [0 = 0%,
            1 = 100%].</param>
            <param name="minValue">The minimum allowed value.</param>
            <param name="maxValue">The maximum allowed value.</param>
            <returns>Float</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.LineToLineIntersection(Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Point,System.Single@,System.Single@)">
            <summary>
            Check if two lines intersect and return the position if occurred.
            </summary>
            <param name="a">The start point of line one.</param>
            <param name="b">The end point of line one.</param>
            <param name="c">The start point of line two.</param>
            <param name="d">The end point of line two.</param>
            <param name="resultX">If they intersect the X value is stored here.
            </param>
            <param name="resultY">If they intersect the Y value is stored here.
            </param>
            <returns>True if they intersect, otherwise false.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.LineToLineIntersection(Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Point)">
            <summary>
            Check if two lines intersect and return the position if occurred.
            </summary>
            <param name="a">The start point of line one.</param>
            <param name="b">The end point of line one.</param>
            <param name="c">The start point of line two.</param>
            <param name="d">The end point of line two.</param>
            <returns>True if they intersect, otherwise false.</returns>
        </member>
        <member name="T:Delta.Utilities.Helpers.MathHelper.MathHelperTests">
            <summary>
            Tests
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.NearlyEqual">
            <summary>
            Nearly equal
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.Clamp">
            <summary>
            Clamp
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.Min">
            <summary>
            Minimum
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.Max">
            <summary>
            Maximum
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.Sqrt">
            <summary>
            Sqrt
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.Round">
            <summary>
            Round
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.Abs">
            <summary>
            Absolute
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.Pow">
            <summary>
            Pow
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.GetNearestMultiple">
            <summary>
            Test GetNearestMultiple
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.Ceiling">
            <summary>
            Ceiling
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.DegreeToRadians">
            <summary>
            Degree to radians
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.RadiansToDegrees">
            <summary>
            Radians to degrees
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.Lerp">
            <summary>
            Lerp
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.TestIntTruncate">
            <summary>
            Test int truncate
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.Sin">
            <summary>
            Sin
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.Cos">
            <summary>
            Sin
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.Tan">
            <summary>
            Tan
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.Asin">
            <summary>
            Asin
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.Acos">
            <summary>
            Acos
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.Atan">
            <summary>
            Atan
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.GetNextPowerOfTwo">
            <summary>
            Get next power of two
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.IsPowerOfTwo">
            <summary>
            IsPowerOfTwo
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.ComputeValue">
            <summary>
            Compute value
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.MathHelper.MathHelperTests.ComputePercentageValue">
            <summary>
            Compute percentage value
            </summary>
        </member>
        <member name="T:Delta.Utilities.Helpers.DirectoryHelper">
            <summary>
            Directory helper
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.Exists(System.String)">
            <summary>
            Helper method to figure out if a directory exists, will just call
            Directory.Exists except on WP7 where this just would lead to a
            MethodAccessException, there we use the isolated storage instead.
            </summary>
            <param name="directory">
            Directory to check for. If this is null or empty, true is returned (the
            current path we are in obviously exists).
            </param>
            <returns>True if the directory path exists, false otherwise</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.GetBaseDirectory">
            <summary>
            Get base directory where the application was started, is usually the
            same as GetCurrentDirectory, but can differ if current directory was
            changed (e.g. via SetCurrentDirectory).
            </summary>
            <returns>String with the base directory</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.GetCurrentDirectory">
            <summary>
            Get current directory, just uses Directory.GetCurrentDirectory except
            on WP7 where no such thing is available, will just return "" there.
            </summary>
            <returns>String with the current directory</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.SetCurrentDirectory(System.String)">
            <summary>
            Set current directory, just uses Directory.SetCurrentDirectory except
            on WP7 where no such thing is available, will do nothing there.
            </summary>
            <param name="newDirectory">New Directory to switch into</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.CreateDirectory(System.String,System.Boolean)">
            <summary>
            Create a directory with the specific path.
            </summary>
            <param name="directoryPath">Directory path to create</param>
            <param name="deleteIfExists">
            If the directory already exists, then delete it or not.
            </param>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.GetFiles(System.String,System.String)">
            <summary>
            Get files helper method.
            Note: WP7 uses isolated storage, else this is just Directory.GetFiles.
            </summary>
            <param name="path">File path for the search</param>
            <param name="searchPattern">Search Pattern</param>
            <returns>
            Files in the directory matching searchPattern as filename string list
            with full file paths.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.GetFilesRecursive(System.String,System.String)">
            <summary>
            Get files function with recursive file searching in sub directories.
            </summary>
            <param name="path">File path for the start of the search</param>
            <param name="searchPattern">Search Pattern</param>
            <returns>
            Files in the directory and any sub directory matching searchPattern as
            filename string list (with full absolute file paths).
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.GetFilesMultiPattern(System.String,System.String,System.Boolean)">
            <summary>
            Same as normal GetFiles but with the option to use multi patterns,
            e.g. "*.txt|*.wma".
            </summary>
            <param name="path">Path to search for files in.</param>
            <param name="searchPattern">Multiple pattern separated by an |</param>
            <param name="recursive">Recursive file search</param>
            <returns>Array of found files.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.GetDirectories(System.String)">
            <summary>
            Get the directories in the given path.
            </summary>
            <param name="path">Path</param>
            <returns>Array of sub directories of path</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.GetDirectories(System.String,System.String)">
            <summary>
            Get the directories in the given path.
            </summary>
            <param name="path">Path</param>
            <param name="searchPattern">Search pattern to find specific
            directories only.</param>
            <returns>Array of sub directories of path</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.GetDirectoriesRecursive(System.String)">
            <summary>
            Get all directories and sub directories in the given path recursively.
            </summary>
            <param name="path">Path</param>
            <returns>List of all directories found</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.GetDirectoriesRecursive(System.String,System.String)">
            <summary>
            Get all directories and sub directories in the given path recursively.
            </summary>
            <param name="path">Path</param>
            <param name="searchPattern">Search Pattern</param>
            <returns>List of all directories found</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.GetParentDirectory(System.String,System.String@)">
            <summary>
            Gets the parent directory of the given directory.
            </summary>
            <param name="directory">The path of the current folder</param>
            <param name="parentDirectory">The path of the parent directory.</param>
            <returns>Returns 'true' if there is a parent directory.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.ComparePaths(System.String,System.String)">
            <summary>
            Compare two paths, ignoring if they use \\ or / and if
            something is written in big or small letters. We also check the full
            path so if we have something like .. or . this won't affect the
            comparison.
            </summary>
            <param name="path1">First path.</param>
            <param name="path2">Second path.</param>
            <returns>True if the paths are equal.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.IncludeTrailingBackslash(System.String)">
            <summary>
            Include trailing backslash. Makes sure the directory ends with "\".
            </summary>
            <param name="directory">Directory</param>
            <returns>String that always ends with a backslash</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.ExcludeTrailingBackslash(System.String)">
            <summary>
            Exclude last trailing backslash from a directory.
            </summary>
            <param name="directory">Directory</param>
            <returns>String without a trailing backslash</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.CopyDirectory(System.String,System.String)">
            <summary>
            Copy directory and all files over to destinationPath.
            Note: This method isn't supported on platforms like Windows Phone 7.
            </summary>
            <param name="destinationPath">Destination Path</param>
            <param name="sourcePath">Source Path</param>
            <returns>True if the directory was copied successfully</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.MoveDirectory(System.String,System.String)">
            <summary>
            Move directory and all files in it to destinationPath.
            </summary>
            <param name="destinationPath">Destination Path</param>
            <param name="sourcePath">Source Path</param>
            <returns>True if the move was successful</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.SafeDelete(System.String)">
            <summary>
            Delete directory and warn if we are unable to delete files.
            </summary>
            <param name="path">Path</param>
            <returns>True if the deletion succeeded</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.Delete(System.String,System.Boolean)">
            <summary>
            Delete directory and optionally warn if we are unable to delete files.
            </summary>
            <param name="path">Path</param>
            <param name="warnIfFailing">Warn if any file fails to be deleted.
            </param>
            <returns>True if the deletion succeeded, if the directory does not
            exist this method simply returns false.</returns>
        </member>
        <member name="F:Delta.Utilities.Helpers.DirectoryHelper.GetBaseDirectoryCallback">
            <summary>
            Callback for getting the base directory. On Windows this is just
            Directory.GetBaseDirectory.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.DirectoryHelper.GetCurrentDirectoryCallback">
            <summary>
            Callback for getting the current directory. On Windows this is just
            Directory.GetCurrentDirectory.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.DirectoryHelper.SetCurrentDirectoryCallback">
            <summary>
            Callback for setting the current directory. On Windows this is just
            Directory.SetCurrentDirectory.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.DirectoryHelper.CreateDirectoryCallback">
            <summary>
            Callback for creating a new directory. On Windows this is just
            Directory.Create.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.DirectoryHelper.GetFilesCallback">
            <summary>
            Callback for getting all files in a directory. On Windows this is just
            Directory.GetFiles.
            </summary>
        </member>
        <member name="T:Delta.Utilities.Helpers.DirectoryHelper.GetBaseDirectoryDelegate">
            <summary>
            Delegate definition for getting the base directory. 
            </summary>
            <returns>String with the base directory</returns>
        </member>
        <member name="T:Delta.Utilities.Helpers.DirectoryHelper.GetCurrentDirectoryDelegate">
            <summary>
            Delegate definition for getting the current directory. 
            </summary>
            <returns>String with the current directory</returns>
        </member>
        <member name="T:Delta.Utilities.Helpers.DirectoryHelper.SetCurrentDirectoryDelegate">
            <summary>
            Delegate definition for setting the current directory. 
            </summary>
            <param name="newDirectory">New Directory to switch into</param>
        </member>
        <member name="T:Delta.Utilities.Helpers.DirectoryHelper.CreateDirectoryDelegate">
            <summary>
            Create a directory with the specific path.
            </summary>
            <param name="directoryPath">Directory path to create</param>
        </member>
        <member name="T:Delta.Utilities.Helpers.DirectoryHelper.GetFilesDelegate">
            <summary>
            Get files helper method (on WP7 uses isolated storage, else this is
            just Directory.GetFiles).
            </summary>
            <param name="path">File path for the search</param>
            <param name="searchPattern">Search Pattern</param>
        </member>
        <member name="T:Delta.Utilities.Helpers.DirectoryHelper.DirectoryHelperTests">
            <summary>
            Test file helper
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.DirectoryHelperTests.CopyDir">
            <summary>
            Copy directory. Note: Too slow for a dynamic unit test.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.DirectoryHelperTests.GetFilesRecursive">
            <summary>
            Test GetFilesRecursive
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.DirectoryHelperTests.TestGetFilesMultiPattern">
            <summary>
            Test get files multi pattern
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.DirectoryHelperTests.ComparePaths">
            <summary>
            Test the ComparePaths method.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.DirectoryHelper.DirectoryHelperTests.GetParentDirectory">
            <summary>
            Get parent directory
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Advanced.PlaneIntersectionType">
            <summary>
            Defines the Plane Intersection Type, whether a plane intersects with an
             object or the object is in front or behind it.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.PlaneIntersectionType.Back">
            <summary>
            The Datatype object is behind the plane.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.PlaneIntersectionType.Front">
            <summary>
            The Datatype object is in front of the plane.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.PlaneIntersectionType.Intersecting">
            <summary>
            The Datatype object is intersecting the plane.
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.BoundingSphere">
            <summary>
            Bounding sphere struct with basically just a center position in 3D and
            a radius. Allows quick collision and bounding sphere intersection tests
            and is sometimes even more useful than bounding boxes.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingSphere.CreateFromMinMax(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Create from minimum maximum
            </summary>
            <param name="max">Max</param>
            <param name="min">Min</param>
            <returns>
            Bounding sphere created from the given minimum and maximum vector.
            </returns>
        </member>
        <member name="F:Delta.Utilities.Datatypes.BoundingSphere.Center">
            <summary>
            Center
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.BoundingSphere.Radius">
            <summary>
            Radius
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingSphere.#ctor(Delta.Utilities.Datatypes.Vector,System.Single)">
            <summary>
            Create bounding sphere
            </summary>
            <param name="setCenter">Set Center</param>
            <param name="setRadius">Set Radius</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingSphere.Equals(Delta.Utilities.Datatypes.BoundingSphere)">
            <summary>
            Does another bounding sphere have the same values as this one?
            </summary>
            <param name="other">Other</param>
            <returns>
            True if the other bounding sphere has the same values, false otherwise.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingSphere.Load(System.IO.BinaryReader)">
            <summary>
            Loads the BoundingSphere (Center+Radius) from a stream.
            </summary>
            <param name="reader">Reader</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingSphere.Save(System.IO.BinaryWriter)">
            <summary>
            Saves the BoundingSphere (Center+Radius) to a stream.
            </summary>
            <param name="writer">Writer</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingSphere.op_Equality(Delta.Utilities.Datatypes.BoundingSphere,Delta.Utilities.Datatypes.BoundingSphere)">
            <summary>
            Check for equality
            </summary>
            <param name="value1">Value 1</param>
            <param name="value2">Value 2</param>
            <returns>True if the spheres are equal, false otherwise.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingSphere.op_Inequality(Delta.Utilities.Datatypes.BoundingSphere,Delta.Utilities.Datatypes.BoundingSphere)">
            <summary>
            Check for inequality
            </summary>
            <param name="value1">Value 1</param>
            <param name="value2">Value 2</param>
            <returns>True if both spheres are not equal, false otherwise.</returns>	
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingSphere.Contains(Delta.Utilities.Datatypes.BoundingSphere)">
            <summary>
            Check whether a Sphere contains another sphere
            </summary>
            <param name="sphere">The sphere.</param>
            <returns>
            Containment type (fully, partial or none)
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingSphere.Contains(Delta.Utilities.Datatypes.BoundingBox)">
            <summary>
            Check whether a Sphere contains a bounding box
            </summary>
            <param name="box">The box.</param>
            <returns>Containment type (fully, partial or none)</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingSphere.Contains(Delta.Utilities.Datatypes.Vector)">
            <summary>
            Check if the Point lays inside this sphere or not.
            </summary>
            <param name="point">Point to check containment for.</param>
            <returns>True if the point lays inside of the sphere.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingSphere.Equals(System.Object)">
            <summary>
            Is another object an bounding sphere and has it the same values?
            </summary>
            <param name="obj">Object to compare.</param>
            <returns>
            True if the other bounding sphere has the same values, false otherwise.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingSphere.GetHashCode">
            <summary>
            Get hash code
            </summary>
            <returns>hash code</returns>
        </member>
        <member name="T:Delta.Utilities.Datatypes.BoundingSphere.BoundingSphereTests">
            <summary>
            Tests
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingSphere.BoundingSphereTests.CreateFromMinMax">
            <summary>
            Create a sphere from a Min, Max vectors
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingSphere.BoundingSphereTests.TestIntersects">
            <summary>
            Test Intersection
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingSphere.BoundingSphereTests.Equality">
            <summary>
            Equality
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.BoundingSphere.BoundingSphereTests.SaveAndLoad">
            <summary>
            Test to save and load spheres into a binary stream
            </summary>
        </member>
        <member name="T:Delta.Utilities.Helpers.StringHelper">
            <summary>
            StringHelper: Provides additional or simplified string functions. This
            class does also offer a lot of powerful functions and allows complicated
            string operations. Easy functions at the beginning, harder ones later.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.StringHelper.NewLine">
            <summary>
            New line, just "\r\n" (the default for Windows), used all over in
            StringHelper and always when multiline text is generated.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.Compare(System.String,System.String)">
            <summary>
            Helps to compare strings, uses case insensitive comparison.
            String.Compare is also gay because we have always to check for == 0.
            </summary>
            <param name="s1">s1</param>
            <param name="s2">s2</param>
            <returns>String</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.Compare(System.String,System.String[])">
            <summary>
            Is any of the names in searchNames the same as stringToCheck,
            will check case insensitive, for a normal case sensitive test
            use stringToCheck.Compare(searchName).
            </summary>
            <param name="stringToCheck">String to check</param>
            <param name="searchNames">Search names</param>
            <returns>True if one of the searchNames was found</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.Split(System.String,System.String)">
            <summary>
            Split text with given separator and auto-trimming.
            </summary>
            <param name="text">Text</param>
            <param name="separator">Separator</param>
            <returns>Array of splitted strings, automatically trimmed</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.Split(System.String,System.String,System.Boolean)">
            <summary>
            Split text with given separator and optional trimming.
            </summary>
            <param name="text">Text to split up</param>
            <param name="separator">Separator between splitted parts</param>
            <param name="trimSplittedParts">Trim splitted parts</param>
            <returns>Array of splitted strings</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.IsNullOrWhiteSpace(System.String)">
            <summary>
            Checks if a string is 'null' or a contains of white space characters
            only.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.SplitMultiLineText(System.String)">
            <summary>
            Splits a multi line string to several strings and returns the result as
            a string array.
            </summary>
            <param name="text">Text</param>
            <returns>the result as a string array</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.ForceTextIntoMultipleLines(System.String,System.Int32)">
            <summary>
            Just goes through the whole text and add new lines when reaching
            maxLineLength (will not keep lines below maxLineLength, but is good
            enough solution for now).
            </summary>
            <param name="inputText">Input text with any length</param>
            <param name="maxLineLength">Maximum line length after we should
            add newlines</param>
            <returns>Input text string with added new lines</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.IsNumericInt(System.String)">
            <summary>
            Check if string is numeric integer. A decimal point is not accepted.
            </summary>
            <param name="str">String to check</param>
            <returns>bool</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.IsNumericFloat(System.String)">
            <summary>
            Is the given string a numeric float?
            </summary>
            <param name="str">Input string text to check</param>
            <returns>
            True if str is a numeric float (e.g. "0.0"), false otherwise.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.IsNumericFloat(System.String,System.Globalization.NumberFormatInfo)">
            <summary>
            Checks if string is numeric float value
            </summary>
            <param name="str">Input string text to check</param>
            <param name="numberFormat">Used number format, e.g. 
            CultureInfo.InvariantCulture.NumberFormat</param>
            <returns>
            True if str can be converted to a float (e.g. "0.0"), false otherwise.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.AllowOnlyOneDecimalPoint(System.String,System.Globalization.NumberFormatInfo)">
            <summary>
            Allow only one decimal point, used for IsNumericFloat.
            </summary>
            <param name="str">Input string to check</param>
            <param name="numberFormat">Used number format, e.g.
            CultureInfo.InvariantCulture.NumberFormat</param>
            <return>True if check succeeded, false otherwise</return>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.GetLastWord(System.String,System.Char)">
            <summary>
            Gets the last word of a text based on the given separator.
            </summary>
            <param name="text">Text</param>
            <param name="separator">Seperator</param>
            <returns>the last word of a text based on the given separator</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.GetClassName(System.Type)">
            <summary>
            Get class name
            </summary>
            <param name="classType">Class type</param>
            <returns>class name</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.GetAllSpacesAndTabsAtBeginning(System.String)">
            <summary>
            Get all spaces and tabs at beginning
            </summary>
            <param name="text">Text</param>
            <returns>ret</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.GetInListContainsIndex(System.String,System.String[],System.Int32)">
            <summary>
            Get Index of specific name in list. Case sensitive. Returns
            MathHelper.InvalidIndex if not found.
            </summary>
            <param name="name">Name</param>
            <param name="list">List</param>
            <param name="startIndex">
            Start index. Offset value to search from.</param>
            <returns>Index</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.GetInListContainsSpecialIndex(System.String,System.String[],System.Int32)">
            <summary>
            Get Index of specific name in list. Case sensitive. Returns
            MathHelper.InvalidIndex if not found.
            <para />
            Special Version: Ignores commented lines: "/*" ... "*/"; "//"
            <para />
            Ignores code in same line as a closing: "*/".
            </summary>
            <param name="name">Name</param>
            <param name="list">List</param>
            <param name="startIndex">
            Start index. Offset value to search from.</param>
            <returns>Int</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.IsMultiBeginCommentValid(System.String)">
            <summary>
            Returns if Multiline comment "/*" is not commented out,
            with "//".
            </summary>
            <param name="testString">Test string</param>
            <returns>True if this is a multiline comment, that is not commented
            out</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StartsWith(System.String,System.String)">
            <summary>
            Checks if a string starts with the given expression.
            </summary>
            <param name="stringToCheck">String to check</param>
            <param name="expression">Expression</param>
            <returns>True if the expression was found</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StartsWith(System.String,System.String[])">
            <summary>
            Checks if a string starts with one of the strings in searchNames. This
            method will check case insensitive and is often used for file checks.
            </summary>
            <param name="stringToCheck">String to check</param>
            <param name="searchNames">Search names</param>
            <returns>True if one of the searchNames was found</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.EndsWith(System.String,System.String)">
            <summary>
            Checks if a string ends with the given expression.
            </summary>
            <param name="stringToCheck">String to check</param>
            <param name="expression">Expression</param>
            <returns>True if the expression was found</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.EndsWith(System.String,System.String[])">
            <summary>
            Checks if a string ends with one of the strings in searchNames. This
            method will check case insensitive and is often used for file checks.
            </summary>
            <param name="stringToCheck">String to check</param>
            <param name="searchNames">Search names</param>
            <returns>True if one of the searchNames was found</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.RemoveKeyWords(System.String,System.String[])">
            <summary>
            Remove keywords from the stringToCheck. Useful to get rid of C#
            keywords like public, private, internal, etc. in source code lines.
            For example RemoveKeyWords("public static class Program",
            new string[] { "public", "private", "internal", "static" }) would
            return "class Program".
            </summary>
            <param name="stringToCheck">String to check</param>
            <param name="keywords">List of keywords to remove</param>
            <returns>Trimmed string without keywords</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.Contains(System.String,System.String)">
            <summary>
            Is searchName contained in stringToCheck, will check case insensitive,
            for a normal case sensitive test use stringToCheck.Contains(searchName)
            </summary>
            <param name="stringToCheck">String to check</param>
            <param name="searchName">Search name</param>
            <returns>True if stringToCheck contains searchName</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.Contains(System.String,System.String[])">
            <summary>
            Is any of the names in searchNames contained in stringToCheck,
            will check case insensitive, for a normal case sensitive test
            use stringToCheck.Contains(searchName).
            </summary>
            <param name="stringToCheck">String to check</param>
            <param name="searchNames">Search names</param>
            <returns>True if one of the searchNames was found</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.Contains(System.Collections.Generic.List{System.String},System.String)">
            <summary>
            Is any of the names in stringsToCheck contain searchName,
            will check case insensitive, for a normal case sensitive test
            use stringsToCheck.Contains(searchName).
            </summary>
            <param name="stringsToCheck">Array of strings to check</param>
            <param name="searchName">Search name</param>
            <returns>True if searchName was found</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.ToIntArray(System.String)">
            <summary>
            Convert string data to int array, string must be in the form
            "1, 3, 8, 7", etc. WriteArrayData is the complementary function.
            </summary>
            <param name="str">Input string</param>
            <returns>int array, will be null if string is invalid!</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.ToFloatArray(System.String)">
            <summary>
            Convert string data to float array, string must be in the form
            "1.5, 3.534, 8.76, 7.49", etc. WriteArrayData is the complementar
            function.
            </summary>
            <param name="s">s</param>
            <returns>float array, will be null if string is invalid!</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.ToFloatArray(System.String,System.String)">
            <summary>
            Convert string data to float array.
            <para />
            Note: The string numbers must be in the invariant number format.
            </summary>
            <param name="s">s</param>
            <returns>float array, will be null if string is invalid!</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.ToInvariantString(System.Object)">
            <summary>
            Write invariant string, which is helpful to write out floats, doubles
            or decimals in a invariant number format (not in german, spanish
            or whatever current language is running format, which can cause
            problems when importing the exported string number back).
            <para />
            Note: Not longer an extension method as it is annoying to type
            "To" for strings and intellisense brings this up first instead of
            the usual "ToString", which we almost always want instead.
            </summary>
            <param name="someObj">Some object, should be a number</param>
            <returns>Invariant string of the object</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.ToInvariantString(System.Single)">
            <summary>
            Extension to convert a float into an invariant string, which makes sure
            that the number format is always in the same for saving and parsing
            back to avoid problems because of the differences in the number format
            of the system languages.
            </summary>
            <param name="number">Any float number</param>
            <returns>Invariant string of the object</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.ToInvariantString(System.Single,System.String)">
            <summary>
            Extension to convert a float into an invariant string, which makes sure
            that the number format is always in the same for saving and parsing
            back to avoid problems because of the differences in the number format
            of the system languages.
            </summary>
            <param name="number">Any float number</param>
            <returns>Invariant string of the object</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.ToInvariantString(System.Double)">
            <summary>
            Extension to convert a double into an invariant string, which makes
            sure that the number format is always in the same for  saving and
            parsing back to avoid problems because of the differences in the number
            format of the system languages.
            </summary>
            <param name="number">Any float number</param>
            <returns>Invariant string of the object</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.ToInvariantString(System.Decimal)">
            <summary>
            Extension to convert a decimal to an invariant string, which makes sure
            that the number format is always in the same for saving and parsing
            back to avoid problems because of the differences in the number format
            of the system languages.
            </summary>
            <param name="number">Any float number</param>
            <returns>Invariant string of the object</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.FromInvariantString``1(System.String,``0,System.String)">
            <summary>
            Converts string to type, for example: integer, boolean or other stuff.
            </summary>
            <typeparam name="T">Type to convert into</typeparam>
            <param name="value">Input text containing value of T</param>
            <param name="defaultValue">The default value</param>
            <param name="extraWarningTextIfAnythingGoesWrong">A warning if anything 
            goes wrong</param>
            <returns>Type or default value if failed</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.WriteIntoSpaceString(System.String,System.Int32)">
            <summary>
            Write into space string, useful for writing parameters without
            knowing the length of each string, e.g. when writing numbers
            (-1, 1.45, etc.). You can use this function to give all strings
            the same width in a table. Maybe there is already a string function
            for this, but I dont found any useful stuff.
            </summary>
            <param name="msg">Message to write</param>
            <param name="spaces">Number of spaces to fill</param>
            <returns>Same text as msg, but at least as long as spaces</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.WriteInternetTime(System.DateTime,System.Boolean)">
            <summary>
            Write internet time
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.WriteKbMbGbNumber(System.Int64,System.String)">
            <summary>
            Write bytes, KB, MB, GB, TB message.
            1 KB = 1024 Bytes
            1 MB = 1024 KB = 1048576 Bytes
            1 GB = 1024 MB = 1073741824 Bytes
            1 TB = 1024 GB = 1099511627776 Bytes
            E.g. 100 will return "100 Bytes"
            2048 will return "2.00 KB"
            2500 will return "2.44 KB"
            1534905 will return "1.46 MB"
            23045904850904 will return "20.96 TB"
            </summary>
            <param name="decimalSeperator">Decimal Separator</param>
            <param name="num">Number of bytes to write out</param>
            <returns>
            String with number of bytes in text form, e.g. "3.23 MB"
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.WriteKbMbGbNumber(System.Int64)">
            <summary>
            Write bytes, KB, MB, GB, TB message.
            1 KB = 1024 Bytes
            1 MB = 1024 KB = 1048576 Bytes
            1 GB = 1024 MB = 1073741824 Bytes
            1 TB = 1024 GB = 1099511627776 Bytes
            E.g. 100 will return "100 Bytes"
            2048 will return "2.00 KB"
            2500 will return "2.44 KB"
            1534905 will return "1.46 MB"
            23045904850904 will return "20.96 TB"
            </summary>
            <param name="num">Number of bytes to write out</param>
            <returns>
            String with number of bytes in text form, e.g. "3.23 MB"
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.Save(System.String,System.IO.BinaryWriter)">
            <summary>
            Saves a string value to the given data stream writer. Since saving
            null is not allowed, we always store a string (empty string in this
            case). Loading the string can just be done with reader.ReadString().
            </summary>
            <param name="value">Value to save</param>
            <param name="dataWriter">Data writer</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.BuildStringFromLines(System.String[],System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Build string from lines
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.BuildStringFromLines(System.String[],System.String)">
            <summary>
            Build string from lines
            </summary>
            <param name="lines">Input lines</param>
            <param name="separator">
            Separator between lines (by default NewLine).
            </param>
            <returns>
            Long text string with all the lines in in separated with NewLines.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.BuildStringFromLines(System.String[],System.Int32,System.Int32,System.String)">
            <summary>
            Build string from lines
            </summary>
            <param name="lines">Input lines, but only used partically</param>
            <param name="startLine">Start line to start writing out</param>
            <param name="endLine">End line to write</param>
            <param name="separator">
            Separator between lines (by default NewLine).
            </param>
            <returns>
            Long text string with all the lines in in separated with NewLines.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.SplitAndTrim(System.String,System.Char)">
            <summary>
            Performs basically the same job as String.Split, but does
            trim all parts, no empty parts are returned, e.g.
            "hi  there" (thats 2 spaces) returns "hi", "there",
            String.Split would return "hi", "", "there".
            Or another example: "Flak, Shootgun".Split(',') would return
            "Flak" and " Shotgun", this function returns "Flak" and "Shotgun"
            </summary>
            <param name="text">Text</param>
            <param name="separator">Seperator</param>
            <returns>Array of strings</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.SplitAndTrim(System.String,System.String)">
            <summary>
            Performs basically the same job as String.Split, but does
            trim all parts, no empty parts are returned, e.g.
            "hi  there" (thats 2 spaces) returns "hi", "there",
            String.Split would return "hi", "", "there".
            Or another example: "Flak, Shootgun".Split(',') would return
            "Flak" and " Shotgun", this function returns "Flak" and "Shotgun"
            </summary>
            <param name="text">Text</param>
            <param name="separator">Separator</param>
            <returns>Array of strings</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.SplitAndTrim(System.String,System.Char[])">
            <summary>
            Performs basically the same job as String.Split, but does
            trim all parts, no empty parts are returned, e.g.
            "hi  there" (thats 2 spaces) returns "hi", "there",
            String.Split would return "hi", "", "there".
            Or another example: "Flak, Shootgun".Split(',') would return
            "Flak" and " Shotgun", this function returns "Flak" and "Shotgun"
            </summary>
            <param name="text">Text</param>
            <param name="separators">Separators</param>
            <returns>Array of strings</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.IsMultiline(System.String)">
            <summary>
            Is text multiline checks if the string text has newline characters.
            </summary>
            <param name="text">Text to check.</param>
            <returns>True if the text is multiline, otherwise False.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.HasMultipleWords(System.String)">
            <summary>
            Has multiple words checks if the string text, splitted at spaces,
            tabs or new lines, contains multiple words.
            </summary>
            <param name="text">Text to check.</param>
            <returns>True if the text has multiple words, otherwise False.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.SplitWords(System.String)">
            <summary>
            Split words, the line can contain characters like whitespaces,
            newlines, spaces, commas, points or semicolons, everything is used
            to split words. Only words with at least one other characters are
            returned. Other delimiters characters: ~!@%^()-+=|\/{}[]:;"',?
            and the following ones (can't display here): amp, star and brackets.
            E.g. "He, she, it, yo man!" returns "He", "she", "it", "yo", "man".
            </summary>
            <param name="line">Line</param>
            <returns>Array of strings containing the splitted and trimmed words,
            can be an empty array if there were no words in the input text.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.LimitAllWordLengths(System.String,System.Int32)">
            <summary>
            Limit all word lengths
            </summary>
            <param name="textSnippet">Text snippet</param>
            <param name="maxWordLength">Maximum word length</param>
            <returns>String</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.MaxStringLength(System.String,System.Int32,Delta.Utilities.Helpers.StringHelper.CutModes)">
            <summary>
            Return the same string back, but reduce it if it is too long. Often
            used for SQL databases table entries, which often only allow a certain
            string length for data fields.
            </summary>
            <param name="originalString">Original string</param>
            <param name="maxLength">Maximum length for the string</param>
            <param name="cutMode">Cut mode</param>
            <returns>
            String with the maximum length of maxLength characters.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.CreatePasswordString(System.String)">
            <summary>
            Create password string
            </summary>
            <param name="originalString">Original String</param>
            <returns>Password string</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.SplitFunctionNameToWordString(System.String,System.Boolean)">
            <summary>
            Splits a function name to words, was used for CR_Commenter in the past.
            E.g. "MakeDamageOnUnit" gets "Make damage on unit".
            Will also detect abbreviation like TCP and leave them
            intact, e.g. "CreateTCPListener" gets "Create TCP listener".
            </summary>
            <param name="functionString">Function String</param>
            <param name="upperLetterWords">Handle upper letter words</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.GetLeftPartAtFirstOccurence(System.String,System.Char)">
            <summary>
            Get left part of everything to the left of the first occurrence of a 
            character.
            </summary>
            <param name="ch">character</param>
            <param name="sourceString">Source String</param>
            <returns>String on the left side of ch</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.GetRightPartAtFirstOccurence(System.String,System.Char)">
            <summary>
            Get right part of everything to the right of the first
            occurrence of a character.
            </summary>
            <param name="ch">character</param>
            <param name="sourceString">Source String</param>
            <returns>String on the right of ch</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.GetLeftPartAtLastOccurence(System.String,System.Char)">
            <summary>
            Get left part of everything to the left of the last
            occurrence of a character.
            </summary>
            <param name="ch">character</param>
            <param name="sourceString">Source String</param>
            <returns>String on the left side of ch</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.GetRightPartAtLastOccurence(System.String,System.Char)">
            <summary>
            Get right part of everything to the right of the last
            occurrence of a character.
            </summary>
            <param name="ch">character</param>
            <param name="sourceString">Source String</param>
            <returns>String on the right side of ch</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.SearchTextBetweenChars(System.String,System.Char,System.Char)">
            <summary>
            Search text between chars, e.g. "hello" returns "ell" if
            firstChar is 'h' and lastChar is 'o'.
            </summary>
            <example>
            "ell" == SearchTextBetweenChars("hello", 'h', 'o');
            </example>
            <param name="sourceString">source string</param>
            <param name="firstChar">First char</param>
            <param name="lastChar">Last char</param>
            <returns>String</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.ToLower(System.Char)">
            <summary>
            Helper function to convert letter to lowercase. Could someone
            tell me the reason why there is no function for that in char?
            </summary>
            <param name="letter">Letter</param>
            <returns>Letter in lower case</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.ToUpper(System.Char)">
            <summary>
            Helper function to convert letter to uppercase. Could someone
            tell me the reason why there is no function for that in char?
            </summary>
            <param name="letter">Letter</param>
            <returns>Letter in upper case</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.IsLowercaseLetter(System.Char)">
            <summary>
            Helper function to check if this is an lowercase letter.
            </summary>
            <param name="letter">Letter to check</param>
            <returns>True if this a lowercase letter</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.IsUppercaseLetter(System.Char)">
            <summary>
            Helper function to check if this is an uppercase letter.
            </summary>
            <param name="letter">Letter</param>
            <returns>True if this an uppercase letter</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.ToLowerJustFirstLetterUpper(System.String)">
            <summary>
            Convert text to lower case letters, make just first letter upper case
            </summary>
            <param name="someText">Some Text</param>
            <returns>String with just the first letter as uppercase</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.IsSpaceOrPunctuation(System.Char)">
            <summary>
            Checks if letter is space ' ' or any punctuation (. , : ; ' " ! ?)
            </summary>
            <param name="letter">Letter</param>
            <returns>True if this letter is space or any punctuation</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.GetAllIndicesOf(System.String,System.Char)">
            <summary>
            Get all indices of the given string. Good to check how many occurances
            are in a string (e.g. how many special characters are in a code line).
            </summary>
            <param name="str">String to check</param>
            <param name="charValue">Char Value</param>
            <returns>Array of indices with the charValue we found</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.GetAllIndicesOf(System.String,System.String)">
            <summary>
            Get all indices of the given string. Good to check how many occurances
            are in a string (e.g. how many special characters are in a code line).
            </summary>
            <param name="str">String to check</param>
            <param name="stringValue">String Value</param>
            <returns>Array of indices with the stringValue we found</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.IsInList(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Is a specific name in a list of strings? This allows multiple strings
            to be checked, if any of them matches with the specified "name" (e.g.
            ("hi", {"hey", "hello", "hi"}) will return true). Does not do a
            contains check, the string has to be in the list.
            </summary>
            <param name="list">List</param>
            <param name="name">Name</param>
            <returns>Is name in any of the list entries</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.IsInList(System.String,System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Is a specific name in a list of strings? This allows multiple strings
            to be checked, if any of them matches with the specified "name" (e.g.
            ("hi", {"hey", "hello", "hi"}) will return true). Does not do a
            contains check, the string has to be in the list.
            </summary>
            <param name="list">List</param>
            <param name="name">Name</param>
            <param name="ignoreCase">Ignore Case</param>
            <returns>Is name in any of the list entries</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.GetLastWord(System.String)">
            <summary>
            Get last word
            </summary>
            <param name="text">Text</param>
            <returns>Last word of Text</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.GetLastWord(System.String,System.Char[])">
            <summary>
            Get last word
            </summary>
            <param name="splitCharacters">Split Characters</param>
            <param name="text">Text</param>
            <returns>Last word of Text</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.RemoveFirstWord(System.String)">
            <summary>
            Remove first word
            </summary>
            <param name="text">Text</param>
            <returns>String with the first word removed</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.RemoveLastWord(System.String)">
            <summary>
            Remove last word
            </summary>
            <param name="text">Text</param>
            <returns>String with the last word removed</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.TryToConvertToFloat(System.Single@,System.String)">
            <summary>
            Try to convert to float. Will not modify value if that does not work. 
            This uses also always the invariant culture.
            </summary>
            <param name="value">Value</param>
            <param name="textToConvert">Text to convert</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.TryToConvertToFloat(System.Single@,System.String,System.Globalization.NumberFormatInfo)">
            <summary>
            Try to convert to float. Will not modify value if that does not work.
            </summary>
            <param name="value">Value</param>
            <param name="textToConvert">Text to convert</param>
            <param name="format">Format for converting</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.CountWords(System.String)">
            <summary>
            Count words in a text (words are only separated by ' ' (spaces))
            </summary>
            <param name="text">Text</param>
            <returns>Number of words</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.CountChars(System.String,System.Char)">
            <summary>
            Count chars, how much checkChar'str are in str.
            </summary>
            <param name="str">String</param>
            <param name="checkChar">Check char</param>
            <returns>Number of times checkChar was found</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.WriteFormatedFloatNumber(System.Single,System.Int32,System.Globalization.CultureInfo)">
            <summary>
            Write formated float number. Well, String.Format is nice, but
            there is no way to skip the optional decimals if they are all 0
            while not having the generic number handling but forcing for
            example max. 3 digits. See below for a unit test that will make
            things more clear. For example this method returns:
            WriteFormatedFloatNumber(5, 2) == "5"
            WriteFormatedFloatNumber(0.012345f, 2) == "0.01"
            </summary>
            <param name="number">Number</param>
            <param name="maxDecimals">Maximum decimals</param>
            <param name="format">Format for String.Format</param>
            <returns>String with the number</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.WriteFormatedFloatNumber(System.Single,System.Int32)">
            <summary>
            Write formated float number
            </summary>
            <param name="number">Number</param>
            <param name="maxDecimals">Maximum decimals</param>
            <returns>String</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.ToByteArray(System.String)">
            <summary>
            Converts text to byte array for ANSI strings. This is NOT unicode, any
            character above 255 will be cut off and not saved into the byte array.
            <para />
            This is the same "Encoding.Default" which is Ansi but faster.
            <para />
            Note: Do not use this for BytesToString, ANSI and C# byte data strings
            are not compatible!
            </summary>
            <param name="text">Text</param>
            <returns>Byte array with ANSI data from Text</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.FromByteArray(System.Byte[])">
            <summary>
            From byte array
            Converts a byte array back into an ANSI string. This is NOT unicode,
            any character above 255 will be cut off and not saved into the byte
            array.
            <para />
            Note: This is the same "Encoding.Default" which is Ansi but faster
            </summary>
            <param name="textBytes">Text bytes</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.ConvertByteArrayToString(System.Byte[])">
            <summary>
            Convert byte array with ANSI characters converted back to a string.
            This is the opposite of ToByteArray.
            </summary>
            <param name="byteArray">Byte Array</param>
            <returns>String</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.ConvertToHexString(System.Byte[])">
            <summary>
            Convert byteArray to hexString for varbinary type in SQL!
            E.g. creates from (0, 1, 5, 3) -> 0x00010503 (4 byte long)
            </summary>
            <param name="byteArray">Byte array</param>
            <returns>0x string like 0x0000FFFF (or longer or shorter)</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.GetBytesFromHexString(System.String)">
            <summary>
            Helper method to get the bytes back from ConvertToHexString
            </summary>
            <param name="hexString">Hex string in the 0x format like 0x0000FFFF
            </param>
            <returns>The byte array that was used to build this hex value</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.EncodeSqlString(System.String)">
            <summary>
            SQL helper, checks if any invalid char is in string (' in particular)
            </summary>
            <param name="message">Message that might contain '</param>
            <returns>String with each ' converted to ''</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.EncodeWithMinusEvery4Chars(System.String)">
            <summary>
            Helper for serials and activation keys, more readable for users if in
            4 chars-slash format.
            </summary>
            <param name="message">Message</param>
            <returns>String with a - after every 4 characters</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.CheckIfEmailIsValid(System.String)">
            <summary>
            Check if email is valid, checks some standard stuff, email could be
            still invalid! Now done with regular expressions and covers more stuff.
            </summary>
            <param name="email">Email to check, should be in format
            Username@Host.Domain</param>
            <returns>True if this looks like a valid email, we obviously don't
            know if this email is real, exists and the user owns it.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.RemoveSpecialChars(System.String)">
            <summary>
            Remove all special characters, only leave 0-9, a-z and A-Z
            </summary>
            <param name="name">Name</param>
            <returns>String with special characters removed</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.CheckIfNameContainsForbiddenChars(System.String)">
            <summary>
            Allow any unicode character, only disallow stuff below '!'
            (including space), will also throw exception if name is empty!
            </summary>
            <param name="name">Name</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.CheckIfMessageContainsForbiddenChars(System.String)">
            <summary>
            Allow any unicode character, only disallow stuff below ' '.
            This method will throw an exception if any illegal char is found.
            </summary>
            <param name="name">Name</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.RemoveAnyForbiddenCharsInName(System.String@)">
            <summary>
            Remove any invalid character, stuff below '!'
            (including space) and ','
            </summary>
            <param name="name">Name</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.RemoveAnyForbiddenPathCharacters(System.String@)">
            <summary>
            Check if filename has some illegal characters, this
            includes everything below ' ' (space) and the following
            characters: / \ * ? : | " &lt; &gt;
            </summary>
            <param name="filename">Filename</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.RemoveAnyForbiddenLettersForFilename(System.String@)">
            <summary>
            Check if filename has some illegal characters, this includes
            everything below ' ' (space) and the following characters:
            / \ * ? : ; | , " ' &lt; &gt;
            </summary>
            <param name="filename">Filename</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.RemoveAnySpecialLettersBelowSpace(System.String@)">
            <summary>
            Remove any special letters below space (char 0-31).
            </summary>
            <param name="checkString">Check string</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.GetMonthName(System.Int32)">
            <summary>
            Get month name, simple 3 letter stuff (jan, feb, etc.)
            </summary>
            <param name="month">Month</param>
            <returns>Name of the month in 3 letters</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.TrimString(System.String)">
            <summary>
            Trim string (start and end) of any whitespace (\n, \r, \t or ' ')
            </summary>
            <param name="String">String</param>
            <returns>String</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StartsWithNumber(System.String)">
            <summary>
            Does the someString starts with a number?
            </summary>
            <param name="someString">Some string</param>
            <returns>True if this string starts with a number</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.IsWhitespace(System.Char)">
            <summary>
            Is whitespace
            </summary>
            <param name="letter">Letter</param>
            <returns>True if the letter is a whitespace</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.Concatenate(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Concatenates a collection of strings.
            </summary>
            <param name="inputs">The strings to concatenate.</param>
            <param name="separator">The separator text that will be placed in
            between the individual strings.</param>
            <returns>Concatenated string from the inputs</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.EscapeChar(System.String,System.Char)">
            <summary>
            "Escapes" all instances of the specified character by inserting
            backslashes before them. In addition, backslashes are transformed to
            double-backslashes.
            </summary>
            <param name="text">Text</param>
            <param name="toEscape">To Escape</param>
            <returns>String with the escape characters</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.ParseEscaped(System.String,System.Char)">
            <summary>
            Splits a string into several fields.
            </summary>
            <remarks>
            Instances of <c>separator</c> alone are treated as field separators.
            Escaped instances of <c>separator</c> (prefixed by backslashes) are
            un-escaped, as are double-backslashes.
            </remarks>
            <param name="text">Text</param>
            <param name="separator">Separator</param>
            <returns>List of strings from the separated text</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.RemoveNumbersAtEnd(System.String)">
            <summary>
            Remove numbers at end
            </summary>
            <param name="inputString">Input String</param>
            <returns>Input String</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.AbsolutePathFromRelative(System.String,System.String)">
            <summary>
            Transforms a relative path to an absolute one based on a specified
            base folder.
            </summary>
            <param name="baseFolderForDerelativization">Base folder for 
            De-relativization</param>
            <param name="relativePath">Relative Path</param>
            <returns>Absolute path</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.RelativizePathsIfPossible(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Enumerates over a collection of rooted file paths, creating a new
            collection containing the relative versions.
            </summary>
            <remarks>
            If any of the paths cannot be relativized (because it does not have
            the same root as the base path), the absolute version is added to the
            collection that's returned.
            </remarks>
            <param name="absolutePaths">Absolute Paths</param>
            <param name="basePath">Base Paths</param>
            <returns>List of relativized paths if they are possible</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.CanRelativize(System.String,System.String)">
            <summary>
            Can relativize
            </summary>
            <param name="absolutePath">Absolute path</param>
            <param name="basePath">Base path</param>
            <returns>True if the path can be relativized</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.RelativePathFromAbsolute(System.String,System.String)">
            <summary>
            Transforms an absolute path to a relative one based on a specified
            base folder.
            </summary>
            <param name="basePath">Base Path</param>
            <param name="pathToRelativize">Path to relativize</param>
            <returns>Relative path if possible</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.Duplicate(System.String,System.Int32)">
            <summary>
            Duplicates a specified string a specified number of times.
            </summary>
            <param name="count">Count</param>
            <param name="text">Text</param>
            <returns>String with text duplicated count number of times</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.CountInstances(System.String,System.Char)">
            <summary>
            Returns the number of instances of a given character in a string.
            </summary>
            <param name="text">Text</param>
            <param name="toFind">To Find</param>
            <returns>Count number of instances in the text</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.FindCommonSubstring(System.String,System.String,System.Boolean)">
            <summary>
            Returns the longest string <c>first</c> and <c>second</c> have in
            common beginning at index 0.
            </summary>
            <param name="first">First</param>
            <param name="ignoreCase">Ignore Case</param>
            <param name="second">Second</param>
            <returns>String that is common in first or second</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.UnorderedCollectionsAreEqual``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``0})">
            <summary>
            Unordered collections are equal 
            </summary>
            <param name="first">First</param>
            <param name="second">Second</param>
            <returns>True if both collections are equal, no matter in which order
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.OrderedCollectionsAreEqual``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>
            Ordered collections are equal 
            </summary>
            <param name="first">First</param>
            <param name="second">Second</param>
            <returns>True if both collections are equal</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.GenerateKey(System.Int32)">
            <summary>
            Generate key helper method with help of cryptography methods. Will
            return a pretty unique key with the given length. Can be used to
            generate keys for serials, CD-keys or online keys for authentication.
            </summary>
            <param name="length">Length</param>
            <returns>String with the generated key</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringToBytes(System.String)">
            <summary>
            String to bytes helper method. Not very fast due the use of Write and
            MemoryStream. For multiple string use an extra memory stream. Use this
            method if Encoding.UTF8.GetBytes(message) does not work for you
            because that does not load the length of the string for you.
            </summary>
            <param name="message">Message</param>
            <returns>Byte array from the string, will always convert back to the
            same string with help of the BytesToString method (even for non ANSI
            strings).</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.BytesToString(System.Byte[])">
            <summary>
            Bytes to string helper method. Not very fast due the use of Write and
            MemoryStream. For multiple string use an extra memory stream. Use this
            method if Encoding.UTF8.GetString(byteArray) does not work for you
            because that does not load the length of the string for you.
            </summary>
            <param name="arrayData">Byte array data</param>
            <returns>String from data</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.GetStringAfterPart(System.String,System.Boolean,System.String,System.String)">
            <summary>
            Get string after part. Helper for the Apply method.
            partPosition must match found part, else null is returned
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.CheckPathSearchPattern(System.String,System.String)">
            <summary>
            This method does a pattern matching check like the
            Directory.GetFiles method with '*', '*.*' and so on.
            </summary>
            <param name="path">The path to check.</param>
            <param name="pattern">The pattern used to check the path.</param>
            <returns>True if the path matched the pattern, otherwise False.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.GetAbbreviationLengthInFunctionName(System.String,System.Int32)">
            <summary>
            Helper function for SplitFunctionNameToWordString to detect
            abbreviations in the function name
            </summary>
            <param name="functionString">Function String</param>
            <param name="startPos">Start Position</param>
            <returns>
            Length of the abbreviation, was used for CR_Commenter in the past.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.HexCharToNumber(System.Char)">
            <summary>
            Helper method to convert character in a hex string back to their
            numeric value.
            </summary>
            <param name="letter">Letter from a hex string</param>
            <returns>Number between 0 and 15</returns>
        </member>
        <member name="P:Delta.Utilities.Helpers.StringHelper.HourMinuteSecondTimeBlock">
            <summary>
            Hour minute time block from DateTime.Now
            </summary>
            <returns>String with the current time</returns>
        </member>
        <member name="P:Delta.Utilities.Helpers.StringHelper.DateHourMinuteSecondTimeBlock">
            <summary>
            Hour minute time block from the current DateTime.Now value
            </summary>
            <returns>String with the current time</returns>
        </member>
        <member name="T:Delta.Utilities.Helpers.StringHelper.CutModes">
            <summary>
            Cut modes for MaxStringLength, cut at beginning of the string,
            at the end (default) or at both ends (for centered text maybe).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.StringHelper.CutModes.Begin">
            <summary>
            Cut at beginning of text
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.StringHelper.CutModes.End">
            <summary>
            Cut at end of text
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.StringHelper.CutModes.BothEnds">
            <summary>
            Cut at both ends
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.StringHelper.CutModes.EndWithDots">
            <summary>
            End string with ".." if we had to cut something off!
            Else the string is used normally.
            </summary>
        </member>
        <member name="T:Delta.Utilities.Helpers.StringHelper.StringHelpersTests">
            <summary>
            StringHelper tests
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.TestCheckPathSearchPattern">
            <summary>
            Test the check search pattern method.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.TestStringToIntPerformance">
            <summary>
            Test string to int performance test
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.TestSplitStringAndCombineAgain">
            <summary>
            Test split string and combine again. Note: Too slow for a unit test.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.TestNumberFormattingForCurrency">
            <summary>
            Test number formatting for currency
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.ConvertToHexString">
            <summary>
            Test ConvertToHexString and GetBytesFromHexString methods.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.GetStringAfterPart">
            <summary>
            Test the GetStringAfterPart method.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.FromInvariantString">
            <summary>
            From invariant string
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.SaveAndLoad">
            <summary>
            Save and load
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.GetLastWord">
            <summary>
            Get last word
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.GetClassName">
            <summary>
            Get class name
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.GetAllSpacesAndTabsAtBeginning">
            <summary>
            Get all spaces and tabs at beginning
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.Contains">
            <summary>
            Contains
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.ConvertStringToIntArray">
            <summary>
            Test for the convert string to int array
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.ConvertStringToFloatArray">
            <summary>
            Test for the convert string to float array
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.TestIsNumericInt">
            <summary>
            Test is numeric int
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.TestIsNumericFloat">
            <summary>
            Test is numeric float
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.TestIsInList">
            <summary>
            Test is in list
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.TestWriteArray">
            <summary>
            Test write array
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.TestSplitMultiLineText">
            <summary>
            Test split multi line text
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.TestIsLowercaseOrUppercaseLetter">
            <summary>
            Test is lowercase or uppercase letter
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.TestSplitFunctionNameToWordString">
            <summary>
            Test split function name to word string
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.TestSplitAndTrim">
            <summary>
            Test split and trim
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.TestSaveAndLoadString">
            <summary>
            Test save and load string
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.TestWriteFormatedNumber">
            <summary>
            Test write formated number
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.TestConcatenate">
            <summary>
            Test concatenate
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.TestEscapeChar">
            <summary>
            Test escape char
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.TestPathStuff">
            <summary>
            Test path stuff
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.TestConvertToBase64">
            <summary>
            Test convert to base 64, was an idea to fix the naming problems
            in the urls for groups, clubs, teams, events, etc. but this
            leads to long unreadable urls, not what we want! Reverting to ids
            instead, not very pretty, but this is our datamodel and easy to
            remember, only users will stay as nicknames.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.GetAllIndecesOf">
            <summary>
            Get all indeces of
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.ToByteArray">
            <summary>
            To byte array
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.RemoveFirstWord">
            <summary>
            Test to remove first word in a sentence
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.StringHelper.StringHelpersTests.RemoveLastWord">
            <summary>
            Test to remove last word in a sentence
            </summary>
        </member>
        <member name="T:Delta.Utilities.Helpers.EnumHelper">
            <summary>
            Enum helper class, allows extracting Description attributes, which is
            useful for displaying name of enum and stuff. Also useful because
            Descriptions don't get obfuscated and EnumHelper has extra operations,
            like GetSize to get the number of elements an enum uses.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.GetCount``1">
            <summary>
            Gets the number of elements for the given Enum type.
            </summary>
            <typeparam name="T">T</typeparam>
            <returns>0</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.GetCount(System.Enum)">
            <summary>
            Gets the number of elements for the given Enum type.
            </summary>
            <param name="anyEnum">Any enum value</param>
            <returns>Number of enum values in this given enum</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.NextValue``1(``0)">
            <summary>
            Get the next enum value in any given enum.
            </summary>
            <typeparam name="T">Type for this enum</typeparam>
            <param name="enumValue">Enum type</param>
            <returns>Next enum value</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.ToUInt64(System.Enum)">
            <summary>
            Converts given enum into unsigned long
            </summary>
            <param name="enumValue">Enum value to convert</param>
            <returns>Unsigned long value created from this enum value</returns>
            <exception cref="T:System.InvalidOperationException">Invalid internal enum type</exception>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.ToInt(System.Enum)">
            <summary>
            Converts given enum into int
            </summary>
            <param name="enumValue">Enum value to convert</param>
            <returns>Integer value created from this enum value</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.IsFlagSet(System.Enum,System.Enum)">
            <summary>
            Checks if given Enum has given flag set. If the enum does not use
            flags, this method should not be used.
            </summary>
            <param name="combinedEnum">Combined enum value</param>
            <param name="flag">Flag to check</param>
            <returns>True if the enum flag is set, false otherwise.</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.ToEnum``1(System.String)">
            <summary>
            Simple implementation which replaces all other Enum conversion methods.
            Works with:
            -string names, string numbers
            -combined enums (comma separated, or as number string)
            -irregular numbered ones
            It returns default enum value, if there is no match
            Tested on: Windows, iOS, Android, WP7
            WP7 has only a 3 parameter variant, so we use this.
            WP7 also has no TryParse, so we do try/except.
            </summary>
            <typeparam name="T">Type of enum to parse</typeparam>
            <param name="enumName">Enum string to convert (can be a number, a
            string, a comma separated combination or a combined number)</param>
            <returns>Enum type parsed or the default value if parsing was not
            possible</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.ToEnum``1(System.String,``0@)">
            <summary>
            Simple implementation which replaces all other Enum conversion methods.
            Works with:
            -string names, string numbers
            -combined enums (comma separated, or as number string)
            -irregular numbered ones
            return value indicates success
            Tested on:
            -Windows
            -MonoDroid
            -Windows Phone (only has 3 parameter variant, so we use this)
            WindowsPhone also has no TryParse, so we do try/except
            </summary>
            <typeparam name="T">T</typeparam>
            <param name="enumName">Enum name</param>
            <param name="result">Result</param>
            <returns>True if the enum value was found, false otherwise</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.GetEnumIndex(System.Enum)">
            <summary>
            Get enum index from value. If we use a known enum, we could simply
            write (int)SomeEnum.Value, but we can't do that with System.Enum
            we have to use in a lot of methods or if we use an auto-generated enum
            </summary>
            <param name="enumValue">Enum value</param>
            <returns>
            Index of the enum value, which is normally the enum value,
            but if the enum uses custom values for each enum, it is not the same!
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.SelectNextEnum(System.Enum)">
            <summary>
            Select next enum
            </summary>
            <param name="enumValue">Enum</param>
            <returns>Next enum value</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.Next(System.Enum)">
            <summary>
            Get next enum value
            </summary>
            <param name="enumValue">Enum</param>
            <returns>Next enum value</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.SelectPreviousEnum(System.Enum)">
            <summary>
            Select previous enum
            </summary>
            <param name="enumValue">Enum</param>
            <returns>Previous enum value</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.Previous(System.Enum)">
            <summary>
            Get previous enum value
            </summary>
            <param name="enumValue">Enum</param>
            <returns>Previous enum value</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.GetValues``1">
            <summary>
            Returns all values of the given enum. See
            http://www.dolittle.no/blogs/einar/archive/2008/01/13/missing-enum-getvalues-when-doing-silverlight-for-instance.aspx
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.GetValues(System.Type)">
            <summary>
            Returns all values of the given enum.
            </summary>
            <param name="enumType">Some enum type</param>
            <returns>Array of enum values</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.GetNames``1">
            <summary>
            Returns the names for all enum values.
            See http://stackoverflow.com/questions/1038234/iterating-through-an-enumeration-in-silverlight
            </summary>
            <typeparam name="T">Type of enum</typeparam>
            <returns>List of strings with the enum names</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.GetNames(System.Type)">
            <summary>
            Returns the names for all enum values.
            </summary>
            <param name="enumType">Some enum type</param>
            <returns>List of strings with the enum names</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.GetEnumerator(System.Type)">
            <summary>
            Get enumerator
            </summary>
            <returns>Enumerator for enumeration (foreach, etc.)</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.GetEnumDescription(System.Enum)">
            <summary>
            Gets enum value Description Attribute
            </summary>
            <param name="value">The value you want the description attribute
            for</param>
            <returns>The description, if any, else it's value.ToString()</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.Description(System.Enum)">
            <summary>
            Description
            </summary>
            <param name="value">Enum</param>
            <returns>String</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.GetEnumDescription(System.Type,System.String)">
            <summary>
            Gets the description for a certain named value in an enum
            </summary>
            <param name="value">The type of the enum</param>
            <param name="name">The name of the enum value</param>
            <returns>The description, if any, else the passed name</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.GetAllEnumDescriptions(System.Type)">
            <summary>
            Get all enum descriptions as string array, useful for
            Controls.DrawDropDownList(...)
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.GetAllEnumDescriptions(System.Enum)">
            <summary>
            Get all enum descriptions as string array, useful for
            Controls.DrawDropDownList(...)
            </summary>
            <param name="value">Enum value</param>
            <returns>List of enum descriptions (if there are any)</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.GetEnumValue(System.Type,System.String)">
            <summary>
            Gets the value of an enum, based on its Description Attribute or
            named value.
            </summary>
            <param name="value">The enum type</param>
            <param name="description">The description or name of the element
            </param>
            <returns>The value, or the passed in description, if it was not found
            </returns>
        </member>
        <member name="T:Delta.Utilities.Helpers.EnumHelper.EnumEnumerator">
            <summary>
            Enum enumerator helper for GetEnumerator,
            this allow us to enumerate enums just like collections
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.EnumHelper.EnumEnumerator.EnumType">
            <summary>
            The enum we use
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.EnumHelper.EnumEnumerator.index">
            <summary>
            Own index
            </summary>
        </member>
        <member name="F:Delta.Utilities.Helpers.EnumHelper.EnumEnumerator.enumValues">
            <summary>
            Enum values
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.EnumEnumerator.#ctor(System.Type)">
            <summary>
            Create enum enumerator
            </summary>
            <param name="setEnumType">Enum type</param>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.EnumEnumerator.GetEnumerator">
            <summary>
            Get enumerator
            </summary>
            <returns>Enumerator to enumerate with</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.EnumEnumerator.MoveNext">
            <summary>
            Move next
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.EnumEnumerator.Reset">
            <summary>
            Reset
            </summary>
        </member>
        <member name="P:Delta.Utilities.Helpers.EnumHelper.EnumEnumerator.EnumCount">
            <summary>
            Count of enum values.
            </summary>
            <returns>Int</returns>
        </member>
        <member name="P:Delta.Utilities.Helpers.EnumHelper.EnumEnumerator.Current">
            <summary>
            Current enum value
            </summary>
        </member>
        <member name="T:Delta.Utilities.Helpers.EnumHelper.EnumHelperTests">
            <summary>
            Enum helper tests
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.EnumHelperTests.TestEnumStuff">
            <summary>
            Test enum stuff. Note: Too slow for a dynamic unit test.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.EnumHelperTests.TestNextAndPreviousEnum">
            <summary>
            Test next and previous enum. Note: Too slow for a dynamic unit test.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.EnumHelperTests.TestGetAllEnumValues">
            <summary>
            Test get all enum values. Note: Too slow for a dynamic unit test.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.EnumHelperTests.TestCreateEnum">
            <summary>
            Test create enum. Note: Too slow for a dynamic unit test.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.EnumHelperTests.GetValues">
            <summary>
            Get values
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.EnumHelperTests.GetNames">
            <summary>
            Get names
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.EnumHelperTests.ConvertToNumberWithCombinedEnum">
            <summary>
            Convert to number
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.EnumHelperTests.GetCount">
            <summary>
            Get count
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.EnumHelperTests.NextValue">
            <summary>
            Next value
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.EnumHelperTests.ToEnum">
            <summary>
            Get enum from name
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.EnumHelperTests.FlagTests">
            <summary>
            Flag tests
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.EnumHelperTests.ConvertToInteger">
            <summary>
            ConvertToInteger test
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.EnumHelper.EnumHelperTests.ConvertToNumber">
            <summary>
            Convert to number
            </summary>
        </member>
        <member name="T:Delta.Utilities.Helpers.EnumHelper.EnumHelperTests.TestEnum">
            <summary>
            Test enum
            </summary>
        </member>
        <member name="T:Delta.Utilities.Helpers.EnumHelper.EnumHelperTests.FlagEnum">
            <summary>
            Flag enum
            </summary>
        </member>
        <member name="T:Delta.Utilities.Helpers.EnumHelper.EnumHelperTests.TestCombinedEnum">
            <summary>
            Test combined enum
            </summary>
        </member>
        <member name="T:Delta.Utilities.Helpers.DateHelper">
            <summary>
            Date helper class, mostly used just to present date times in a common
            format (like ISO date strings), but also has some helper methods to
            check different dates and parse date strings.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.DateHelper.GetTimeString(System.DateTime)">
            <summary>
            GetTimeString
            </summary>
            <param name="time">Time</param>
            <returns>String</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DateHelper.GetForumDateAndTime(System.DateTime)">
            <summary>
            Get forum date and time in german format, day.month.year hour:minute
            </summary>
            <param name="date">Date</param>
            <returns>String</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DateHelper.GetAtForumDateAndTime(System.DateTime)">
            <summary>
            Get at forum date and time
            </summary>
            <param name="date">DateHelper</param>
            <returns>String</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DateHelper.GetDateFromString(System.String)">
            <summary>
            Get date from string
            </summary>
            <param name="dateString">Date string</param>
            <returns>Date time</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DateHelper.GetDateAndTimeFromString(System.String)">
            <summary>
            Get date and time from string
            </summary>
            <param name="dateString">Date string</param>
            <returns>Date time</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DateHelper.IsDateNewer(System.DateTime,System.DateTime)">
            <summary>
            Is date newer than the older date. Very useful for file comparisions.
            </summary>
            <param name="newerDate">Newer date</param>
            <param name="olderDate">Older date</param>
            <returns>True if the newer date is newer than the older date</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DateHelper.IsDateInRange(System.DateTime,System.DateTime,System.DateTime)">
            <summary>
            Is date in range. Will return true if currentData is between beginDate
            and endDate.
            </summary>
            <param name="currentDate">Current date</param>
            <param name="beginDate">Range begin</param>
            <param name="endDate">Range end</param>
            <returns>
            True if currentData is between beginDate and endDate.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DateHelper.AreSameDays(System.DateTime,System.DateTime)">
            <summary>
            Are day1 and day2 are the same day?
            </summary>
            <param name="day1">Day 1</param>
            <param name="day2">Day 2</param>
            <returns>
            True if the days are the same (ignoring all the other datetime values).
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DateHelper.GetIsoDate(System.DateTime)">
            <summary>
            Returns the "Iso Date" stamp (Year-Month-Day).
            </summary>
            <param name="date">Date</param>
            <returns>"Iso Date" stamp (Year-Month-Day)</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DateHelper.GetIsoTime(System.DateTime)">
            <summary>
            Get Iso time stamp (Hour:Minute:Second)
            </summary>
            <param name="time">Datetime input</param>
            <returns>String with the time in hours:minutes:seconds</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DateHelper.GetIsoTimeWithMiliseconds(System.DateTime)">
            <summary>
            Get iso time with miliseconds. Note: DateTime is not very accurate,
            use better timings with the Time or GameTime classes for ingame
            purposes (profiling, debugging, etc. otherwise strings should not be
            needed anyway). This is mostly 
            </summary>
            <param name="time">Time for output</param>
            <returns>
            Text with the time in hours:minutes:seconds.milliseconds format.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DateHelper.GetIsoDateTime(System.DateTime)">
            <summary>
            Get Iso date time stamp (Year-Month-Day Hour:Minute:Second)
            </summary>
            <param name="dateTime">Date Time</param>
            <returns>Date Time</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.DateHelper.IsDate(System.Object)">
            <summary>
            Is date, to check if for example the string contains DateTime value
            if not return false
            </summary>
            <param name="obj">Object to check if this is a date</param>
            <returns>True if this is a date, false otherwise</returns>
        </member>
        <member name="T:Delta.Utilities.Helpers.DateHelper.DateHelperTests">
            <summary>
            Test
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.DateHelper.DateHelperTests.IsDateNewer">
            <summary>
            Is date newer
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.DateHelper.DateHelperTests.GetIsoDateTime">
            <summary>
            Get iso date time stamp
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Quaternion">
            <summary>
            Quaternion, contains X, Y, Z and W values. Mostly used for cameras.
            Note: Sometimes used as a replacement for Vector4 because we only have
            Point for Vector2 and Vector for Vector3.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Quaternion.DataSize">
            <summary>
            Represents the size in bytes of a Quaternion (4 * 4 = 16 bytes).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Quaternion.Identity">
            <summary>
            Returns a identity quaternion (all values 0, except W is 1)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Quaternion.X">
            <summary>
            X value of the Vector.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Quaternion.Y">
            <summary>
            Y value of the Vector.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Quaternion.Z">
            <summary>
            Z value of the Vector.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Quaternion.W">
            <summary>
            W value of the Vector.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Quaternion.Vector">
            <summary>
            We can also use X, Y, Z as a vector (same data)
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.#ctor(Delta.Utilities.Datatypes.Vector,System.Single)">
            <summary>
            Create quaternion
            </summary>
            <param name="scalarPart">scalarPart</param>
            <param name="vectorPart">vectorPart</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Create quaternion
            </summary>
            <param name="setW">setW</param>
            <param name="setX">setX</param>
            <param name="setY">setY</param>
            <param name="setZ">setZ</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.Equals(Delta.Utilities.Datatypes.Quaternion)">
            <summary>
            Check if another quaternion has the same values.
            </summary>
            <param name="other">Other quaternion to compare against.</param>
            <returns>True if the other quaternion has the same values.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.Equals(System.Object)">
            <summary>
            Check if another object is an quaternion and has the same values.
            </summary>
            <param name="obj">Other object to compare against.</param>
            <returns>True if the other quaternion has the same values.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.GetHashCode">
            <summary>
            Get hash code
            </summary>
            <returns>Hash code</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.ToString">
            <summary>
            To string
            </summary>
            <returns>string</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.Conjugate">
            <summary>
            Conjugate
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.CreateFromAxisAngle(Delta.Utilities.Datatypes.Vector,System.Single)">
            <summary>
            Create from axis angle
            </summary>
            <param name="angle">angle</param>
            <param name="axis">axis</param>
            <returns>Quaternion with the rotation around the axis</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.CreateFromYawPitchRoll(System.Single,System.Single,System.Single)">
            <summary>
            Create from yaw pitch roll
            TODO: refactor me plz
            </summary>
            <param name="pitch">pitch</param>
            <param name="roll">roll</param>
            <param name="yaw">yaw</param>
            <returns>Quaternion with the rotation around yaw, pitch, roll</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.Concatenate(Delta.Utilities.Datatypes.Quaternion,Delta.Utilities.Datatypes.Quaternion)">
            <summary>
            Concatenate
            </summary>
            <param name="value1">Value 1</param>
            <param name="value2">Value 2</param>
            <returns>Concatenated quaternion</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.CreateFromRotationMatrix(Delta.Utilities.Datatypes.Matrix)">
            <summary>
            Create from rotation matrix
            </summary>
            <param name="matrix">matrix</param>
            <returns>Quaternion</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.Length">
            <summary>
            Length, also called Magnitude for Quaternions sometimes.
            </summary>
            <returns>Length</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.LengthSquared">
            <summary>
            Length squared, also called SquareMagnitude for Quaternions sometimes.
            </summary>
            <returns>Squared length</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.Normalize">
            <summary>
            Normalize this quaternion.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.Invert">
            <summary>
            Invert this quaternion
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.Lerp(Delta.Utilities.Datatypes.Quaternion,Delta.Utilities.Datatypes.Quaternion,System.Single)">
            <summary>
            Used to interpolate between two quaternions. This is not just
            quat1*amount+quat2*(1-amount) because we need to rotate correctly.
            </summary>
            <param name="quat1">Value 1</param>
            <param name="quat2">Value 2</param>
            <param name="amount">Interpolation amount</param>
            <returns>Interpolated quaternion</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.Dot(Delta.Utilities.Datatypes.Quaternion,Delta.Utilities.Datatypes.Quaternion)">
            <summary>
            Dot product of two quaternions
            </summary>
            <param name="quaternion1">Quaternion 1</param>
            <param name="quaternion2">Quaternion 2</param>
            <returns>Dot product result</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.op_Equality(Delta.Utilities.Datatypes.Quaternion,Delta.Utilities.Datatypes.Quaternion)">
            <summary>
            Operator for equality
            </summary>
            <param name="quaternion1">Quaternion 1</param>
            <param name="quaternion2">Quaternion 2</param>
            <returns>True if both quaternions are equal</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.op_Inequality(Delta.Utilities.Datatypes.Quaternion,Delta.Utilities.Datatypes.Quaternion)">
            <summary>
            Operator for inequality
            </summary>
            <param name="quaternion1">Quaternion 1</param>
            <param name="quaternion2">Quaternion 2</param>
            <returns>True if both quaternions are not equal</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.op_UnaryNegation(Delta.Utilities.Datatypes.Quaternion)">
            <summary>
            Operator for unary negation
            </summary>
            <param name="value">Quaternion to negate</param>
            <returns>Negated value</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.op_Addition(Delta.Utilities.Datatypes.Quaternion,Delta.Utilities.Datatypes.Quaternion)">
            <summary>
            Operator for addition
            </summary>
            <param name="value1">Quaternion 1</param>
            <param name="value2">Quaternion 2</param>
            <returns>Added quaternion</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.op_Multiply(Delta.Utilities.Datatypes.Quaternion,Delta.Utilities.Datatypes.Quaternion)">
            <summary>
            Operator for multiply
            </summary>
            <param name="value1">Quaternion 1</param>
            <param name="value2">Quaternion 2</param>
            <returns>Multiplied quaternion</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.op_Multiply(Delta.Utilities.Datatypes.Quaternion,System.Single)">
            <summary>
            Operator for multiply
            </summary>
            <param name="value">Quaternion to multiply with</param>
            <param name="scalar">Scalar to multiply with</param>
            <returns>Multiplied quaternion</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.op_Multiply(System.Single,Delta.Utilities.Datatypes.Quaternion)">
            <summary>
            Operator for multiply
            </summary>
            <param name="scalar">Scalar to multiply with</param>
            <param name="value">Quaternion to multiply with</param>
            <returns>Multiplied quaternion</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.op_Division(Delta.Utilities.Datatypes.Quaternion,Delta.Utilities.Datatypes.Quaternion)">
            <summary>
            Operator for division
            </summary>
            <param name="value1">Quaternion 1</param>
            <param name="value2">Quaternion 2</param>
            <returns>Divided quaternion</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.op_Division(Delta.Utilities.Datatypes.Quaternion,System.Single)">
            <summary>
            Operator for division
            </summary>
            <param name="value">Quaternion</param>
            <param name="scalar">Scalar to divide through</param>
            <returns>Divided quaternion</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.op_Explicit(Delta.Utilities.Datatypes.Quaternion)~Delta.Utilities.Datatypes.Matrix">
            <summary>
            Operator to explicitly convert a quaternion to a matrix.
            </summary>
            <param name="quat">Quaternion to convert</param>
            <returns>Matrix from quaternion</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.Save(System.IO.BinaryWriter)">
            <summary>
            Saves the point to a stream.
            </summary>
            <param name="writer">The stream that will be used.</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.Load(System.IO.BinaryReader)">
            <summary>
            Load the point values from a stream.
            </summary>
            <param name="reader">The stream that will be used.</param>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Quaternion.QuaternionTests">
            <summary>
            Tests
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.QuaternionTests.Length">
            <summary>
            Length test
            
            Calculation:
              10 * 10 =  100
            + 40 * 40 = 1600
            +  4 *  4 =   16
            +  2 *  2 =    4
            ----------------
                        _____
                      -/1720'
                          41.47288
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.QuaternionTests.Equality">
            <summary>
            Equality test
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.QuaternionTests.ArithmeticOperators">
            <summary>
            ArithmeticOperators test
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.QuaternionTests.LengthSquared">
            <summary>
            LengthSquared test
            
            Calculation:
              10 * 10 =  100
            + 40 * 40 = 1600
            +  4 *  4 =   16
            +  2 *  2 =    4
            ----------------
                        1720
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.QuaternionTests.Normalize">
            <summary>
            Normalize test
            
            Calculation:
            length = 41.47288 (see test above)
            invLength = 1 / 41.47288 = 0.02411
            X = 10 * invLength = 0.2411
            Y = 40 * invLength = 0.9644
            Z =  4 * invLength = 0.09644
            W =  2 * invLength = 0.04822
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.QuaternionTests.Invert">
            <summary>
            Invert test
            
            Calculation:
            length = 1720 (see test above)
            
            invLength = -1 / 1720 = -0.0005814
            X = 10 * invLength = -0.005814
            Y = 40 * invLength = -0.023256
            Z =  4 * invLength = -0.0023256
            W =  2 * -invLength = 0.0011628
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.QuaternionTests.Dot">
            <summary>
            Dot test
            
            Calculation:
            (x1 * x2) + (y1 * y2) + (z1 * z2) + (w1 * w2)
              10 *  5 =  50
            + 40 *  2 =  80
            +  4 * 50 = 200
            +  2 * 12 =  24
            ---------------
                        354
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.QuaternionTests.Lerp">
            <summary>
            Lerp test, will just interpolate two quaternions.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.QuaternionTests.Conjugate">
            <summary>
            Conjugate test
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.QuaternionTests.CreateFromRotationMatrix">
            <summary>
            CreateFromRotationMatrix test
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.QuaternionTests.CreateFromYawPitchRoll">
            <summary>
            CreateFromYawPitchRoll test
            
            Calculation:
            yaw = 40 * 0.5 = 20
            pitch = 2 * 0.5 = 1
            roll = 238 * 0.5 = 119
            
            rollSin = Sin(roll) = 0.342020
            rollCos = Cos(roll) = 0.939692
            pitchSin = Sin(pitch) = 0.017452
            pitchCos = Cos(pitch) = 0.999847
            yawSin = Sin(yaw) = 0.874619
            yawCos = Cos(yaw) = -0.484809
            
            X = ((yawCos * pitchSin) * rollCos) +
                ((yawSin * pitchCos) * rollSin)
              = ((-0.484809 * 0.017452) * 0.939692) +
                ((0.874619 * 0.999847) * 0.342020)
              = 0.291140794875046
            
            Y = ((yawSin * pitchCos) * rollCos) -
                ((yawCos * pitchSin) * rollSin)
              = ((0.874619 * 0.999847) * 0.939692) -
                ((-0.484809 * 0.017452) * 0.342020)
              = 0.824640523317155
            
            Z = ((yawCos * pitchCos) * rollSin) -
                ((yawSin * pitchSin) * rollCos)
              = ((-0.484809 * 0.999847) * 0.342020) -
                ((0.874619 * 0.017452) * 0.939692)
              = -0.180132323055428
            
            W = ((yawCos * pitchCos) * rollCos) +
                ((yawSin * pitchSin) * rollSin)
              = ((-0.484809 * 0.999847) * 0.939692) +
                ((0.874619 * 0.017452) * 0.342020)
              = -0.450280894197248
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.QuaternionTests.CreateFromAxisAngle">
            <summary>
            CreateFromAxisAngle test
            
            Calculation:
            sinAngle = Sin(4.5) = 0.0784590957278449
            X = 45 * sinAngle = 3.53065
            Y =  2 * sinAngle = 0.1569
            Z = 14 * sinAngle = 1.09842
            W = Cos(4.5) = 0.99691
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Quaternion.QuaternionTests.SizeOf">
            <summary>
            Checks if the size of Point is exactly 8 bytes (2 floats: X and Y)
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Matrix">
            <summary>
            Matrix struct, used mostly for 3D calculations. If possible this shares
            all the functionality of the XNA Matrix struct (if we are compiling
            with XNA for Windows, Xbox 360 or Windows Phone) or SlimDX (Windows
            only). In case we do not compile with XNA or SlimDX enabled (like on
            the iPhone or any other platform where XNA and SlimDX are not available),
            this class still provides all the basic functionality as a fallback. It
            might not be as optimized as some specialized xna code paths for the
            Xbox 360, but those only work on the XNA define and platform anyway.
            </summary>
            <remarks>
            Represents a row based matrix. Good wiki page about the coordinate
            system (right handed):
            http://en.wikipedia.org/wiki/Cartesian_coordinate_system
            <para />
            Note: This Matrix class was heavily profiled and optimized with help of
            the MatrixPerformance helper class included here. Many code paths
            are platform and framework dependant, this is why this class is so huge,
            but since this is very low level and highly performance critical, it is
            well worth the complexity and effort (the class is still easy to use).
            On the Xbox we will always try to use XNA implementation for performance
            critical methods, all other platforms are mostly implemented by us
            after testing performance. You can also checkout the SlimDX math classes,
            which mostly are just C#, only certain heavy methods like multiplying
            an array of matrices uses PInvoke to D3DXMatrixMultiply for example.
            <para />
            There are still performance improvements possible for this class
            like using ref for most performance critical methods like Invert,
            Multiply and most other operators, but that makes this class much harder
            to use and we can still do code-optimizations directly with the exposed
            data when needed (e.g. Bone Matrix code should be heavily optimized if
            it has to run on CPU). Currently this is fixed by marking slow methods
            as obsolete, which will give you compiler warnings, use the ref
            overload methods instead.
            <para />
            Also note that many methods are not faster by using the native XNA,
            OpenTK or SharpDX or SlimDX code paths, especially when just assigning
            values (where our code is almost always faster). But remember when any
            framework is using special tricks like low level assembly code or native
            code to calculate complex math operations, it can be faster and will be
            replaced by the build system automatically. If you notice any method
            that should be faster, contact us immediately so we can investigate!
            </remarks>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.ValueCount">
            <summary>
            Represents the number of values of that Matrix struct (here 4x4 = 16).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.Zero">
            <summary>
            Returns a zeroed matrix.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.Invert(Delta.Utilities.Datatypes.Matrix)">
            <summary>
            Invert matrix, this is only slightly faster on the xna platform
            specific implementation, for performance critical code use the ref
            version!
            </summary>
            <param name="a">Matrix to invert</param>
            <returns>Inverted Matrix</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.Invert(Delta.Utilities.Datatypes.Matrix@,Delta.Utilities.Datatypes.Matrix@)">
            <summary>
            Invert matrix ref version, this is the fastest one, especially if
            you use matrix and result for the same value, which will copy values
            over quickly.
            </summary>
            <param name="matrix">Matrix</param>
            <param name="result">Result</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.Transpose(Delta.Utilities.Datatypes.Matrix)">
            <summary>
            Transpose, which basically just means we switch from a row to a column
            based matrix.
            </summary>
            <param name="matrix">Matrix</param>
            <returns>Transposed matrix (row/columns switched)</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.Transpose(Delta.Utilities.Datatypes.Matrix@,Delta.Utilities.Datatypes.Matrix@)">
            <summary>
            Transpose, which basically just means we switch from a row to a column
            based matrix. Faster version using ref input and output values.
            </summary>
            <param name="matrix">Matrix</param>
            <param name="result">result</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.CreateColumnBased(System.Single[])">
            <summary>
            Create column based matrix, also used for creating an exported collada
            matrix, because the normal XNA/OpenTK/whatever matrix is row based.
            </summary>
            <param name="floatValues">Float values</param>
            <returns>Matrix</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.CreateScale(System.Single)">
            <summary>
            Create a scale matrix with the specified value for X, Y and Z.
            </summary>
            <param name="scale">Scale</param>
            <returns>New Matrix with the given scale</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.CreateScale(Delta.Utilities.Datatypes.Vector)">
            <summary>
            Create scale
            </summary>
            <param name="scale">Scale</param>
            <returns>New Matrix with the given scale</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.CreateScale(System.Single,System.Single,System.Single)">
            <summary>
            Create a scale matrix with the specified X, Y and Z scaling values.
            </summary>
            <param name="scaleX">The amount of scaling in X dimension.</param>
            <param name="scaleY">The amount of scaling in Y dimension.</param>
            <param name="scaleZ">The amount of scaling in Z dimension.</param>
            <returns>New Matrix with the given scale</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.CreateRotationX(System.Single)">
            <summary>
            Create rotation around x-axis (pitch)
            <para />
            It is important to know which axis is meant with Yaw, Pitch and Roll:
            http://www.spotimage.com/dimap/spec/dictionary/Spot_Scene/Illustrations/YAW.gif
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.CreateRotationY(System.Single)">
            <summary>
            Create rotation around y-axis (yaw)
            <para />
            It is important to know which axis is meant with Yaw, Pitch and Roll:
            http://www.spotimage.com/dimap/spec/dictionary/Spot_Scene/Illustrations/YAW.gif
            </summary>
            <param name="degrees">Degrees to rotate around the Y axis</param>
            <returns>New matrix with the given rotation</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.CreateRotationZ(System.Single)">
            <summary>
            Create rotation around z-axis (roll)
            <para />
            It is important to know which axis is meant with Yaw, Pitch and Roll:
            http://www.spotimage.com/dimap/spec/dictionary/Spot_Scene/Illustrations/YAW.gif
            </summary>
            <param name="degrees">Degrees to rotate around the Z axis</param>
            <returns>New matrix with the given rotation</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.CreateRotationZYX(System.Single,System.Single,System.Single)">
            <summary>
            Rotate around the Z axis, then the Y axis, and finally the X axis
            (rotX * rotY * rotZ). Please note that this is not the same as
            FromYawPitchRoll, which uses Z (yaw), then X (pitch), then Y (roll).
            <para />
            Note: This is the same as calling the CreateRotationX, Y, Z methods,
            just combined all together without having to multiply matrices).
            </summary>
            <param name="x">Degrees to rotate around the X axis</param>
            <param name="y">Degrees to rotate around the Y axis</param>
            <param name="z">Degrees to rotate around the Z axis</param>
            <returns>New matrix with the given rotation</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.CreateRotationZY(System.Single,System.Single)">
            <summary>
            Rotate around Z axis, then around Y axis.
            (equals rotY * rotZ)
            </summary>
            <param name="y">Degrees to rotate around the Y axis</param>
            <param name="z">Degrees to rotate around the Z axis</param>
            <returns>New matrix with the given rotation</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.FromYawPitchRoll(Delta.Utilities.Datatypes.Vector)">
            <summary>
            From yaw pitch roll (yaw = Y, pitch = X, roll = Z)
            http://www.euclideanspace.com/maths/geometry/rotations/conversions/eulerToMatrix/index.htm
            It is important to know which axis is meant with Yaw, Pitch and Roll:
            http://www.spotimage.com/dimap/spec/dictionary/Spot_Scene/Illustrations/YAW.gif
            <para />
            Note: This method calculates Y * X * Z where
            Y = value.X = yaw
            X = value.Y = pitch
            Z = value.Z = roll
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.FromYawPitchRoll(System.Single,System.Single,System.Single)">
            <summary>
            From yaw pitch roll (yaw = Y, pitch = X, roll = Z)
            It is important to know which axis is meant with Yaw, Pitch and Roll:
            http://www.spotimage.com/dimap/spec/dictionary/Spot_Scene/Illustrations/YAW.gif
            <para />
            Note: This method calculates Y * X * Z where
            Y = yaw
            X = pitch
            Z = roll
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.CreateTranslation(Delta.Utilities.Datatypes.Vector)">
            <summary>
            Create translation matrix
            </summary>
            <param name="position">Position</param>
            <returns>Identity matrix with the translation (M41, M42, M43)</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.CreateTranslation(System.Single,System.Single,System.Single)">
            <summary>
            Create translation matrix
            </summary>
            <param name="x">x</param>
            <param name="y">y</param>
            <param name="z">z</param>
            <returns>Identity matrix with the translation (M41, M42, M43)</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.CreateScaleAndTranslation(System.Single,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Create scale and translation, basically just does CreateScale and
            CreateTranslation, but much more efficient.
            </summary>
            <param name="scale">Scale for the new matrix</param>
            <param name="position">Position for the matrix translation.</param>
            <returns>New matrix with the given scale and translation.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.CreateLookAt(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Creates a right-handed look at matrix for a camera.
            </summary>
            <param name="cameraPosition">camera position</param>
            <param name="cameraTarget">camera target</param>
            <param name="cameraUpVector">camera up vector</param>
            <returns>New look at matrix</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.CreateFromAxisAngle(Delta.Utilities.Datatypes.Vector,System.Single)">
            <summary>
            Create from axis angle (in degrees)
            TODO: beautify variables in this method!
            </summary>
            <param name="angle">Angle in degrees</param>
            <param name="axis">Axis to rotate around</param>
            <returns>Rotated matrix around axis for rotations</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.CreateFromAxisAngle(Delta.Utilities.Datatypes.Vector@,System.Single,Delta.Utilities.Datatypes.Matrix@)">
            <summary>
            Create from axis angle (in degrees)
            </summary>
            <param name="angle">Angle in degrees</param>
            <param name="axis">Axis to rotate around</param>
            <param name="result">Rotated matrix around axis for rotations</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.CreateOrthographic(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Create orthographic
            </summary>
            <param name="bottom">bottom</param>
            <param name="farPlane">farPlane</param>
            <param name="left">left</param>
            <param name="nearPlane">near plane</param>
            <param name="right">right</param>
            <param name="top">top</param>
            <returns>New Orthographic matrix</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.CreatePerspective(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a right-handed perspective field of view matrix for a camera.
            </summary>
            <param name="fieldOfView">Field of view (Warning: In radians)</param>
            <param name="aspectRatio">Aspect ratio</param>
            <param name="nearPlaneDistance">Near plane distance</param>
            <param name="farPlaneDistance">Far plane distance</param>
            <returns>Matrix</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.Multiply(Delta.Utilities.Datatypes.Matrix@,Delta.Utilities.Datatypes.Matrix@,Delta.Utilities.Datatypes.Matrix@)">
            <summary>
            Ugly Matrix Multiply method (normally you would just use
            matrix1*matrix2 to multiply two matrices), but this one is a little
            faster because we don't need to copy over the matrix values and we can
            even provide a faster fallback on the xbox platform (using xna).
            Note: matrix1 or matrix2 can be the same as result, which results in
            even better performance for performance critical matrix multiply code.
            </summary>
            <param name="matrix1">matrix1</param>
            <param name="matrix2">matrix2</param>
            <param name="result">result</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.Multiply(Delta.Utilities.Datatypes.Matrix@,Delta.Utilities.Datatypes.Vector@,Delta.Utilities.Datatypes.Vector@)">
            <summary>
            Ugly Matrix*Vector multiply method (basically transforming a vector
            with a matrix). Normally you would just use matrix*position to
            multiply, but this one is a little faster because we don't need to
            copy over the matrix values and we can even provide a faster fallback
            on the xbox platform (using xna).
            Note: position and result can be the same as result, which results in
            even better performance for performance critical matrix multiply code.
            </summary>
            <param name="matrix">matrix</param>
            <param name="position">position</param>
            <param name="result">result</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.Multiply(Delta.Utilities.Datatypes.Matrix,System.Single)">
            <summary>
            Multiply matrix with a scale factor. Note: This is the slow version.
            This method needs to copy 128 bytes around (2 matrices, each 64 bytes).
            Try to use the ref version instead.
            </summary>
            <param name="matrix">Matrix</param>
            <param name="scaleFactor">Scale factor</param>
            <returns>
            New matrix with each value multiplied with scaleFactor
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.Equal(Delta.Utilities.Datatypes.Matrix@,Delta.Utilities.Datatypes.Matrix@)">
            <summary>
            Equality check. Optimized for speed via ref parameters, which
            are much faster than copying 128 bytes (2 matrices each 64 bytes).
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.Unequal(Delta.Utilities.Datatypes.Matrix@,Delta.Utilities.Datatypes.Matrix@)">
            <summary>
            Inequality check. Optimized for speed via ref parameters, which
            are much faster than copying 128 bytes (2 matrices each 64 bytes).
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.TranslationNearlyEqual(Delta.Utilities.Datatypes.Matrix@,Delta.Utilities.Datatypes.Matrix@)">
            <summary>
            Nearly equals (only checks the Translation of the matrices), two
            matrices are considered nearly equal if their translation distance
            is below MathHelper.Epsilon. Use the MatrixNearlyEqual method to
            compare two complete matrices (much slower than this check).
            </summary>
            <param name="matrix1">Matrix 1 to compare</param>
            <param name="matrix2">Matrix 2 to compare</param>
            <returns>True if the translations of the matrices are almost the
            same, false otherwise.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixNearlyEqual(Delta.Utilities.Datatypes.Matrix@,Delta.Utilities.Datatypes.Matrix@)">
            <summary>
            Matrix nearly equal helper method to compare two matrices that might
            not be 100% the same because of rounding errors, but they produce
            pretty much the same results.
            </summary>
            <param name="matrix1">Matrix 1 to compare</param>
            <param name="matrix2">Matrix 2 to compare</param>
            <returns>True if the matrices are almost the same</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.FromQuaternion(Delta.Utilities.Datatypes.Quaternion)">
            <summary>
            From quaternion
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.FromString(System.String)">
            <summary>
            Convert a string to a Matrix. The expected format is
            (M11, M12, M13, M14)
            (M21, M22, M23, M24)
            ...
            </summary>
            <param name="matrixString">The string containing the values in the
            correct format.</param>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.Identity">
            <summary>
            Returns a new identity matrix (no rotation, translation or scaling)!
            Note: Not readonly to allow passing it by ref, but this should never
            be set!
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.M11">
            <summary>
            1st row - 1st column value of the Matrix.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.M12">
            <summary>
            1st row - 2nd column value of the Matrix.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.M13">
            <summary>
            1st row - 3rd column value of the Matrix.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.M14">
            <summary>
            1st row - 4th column value of the Matrix.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.M21">
            <summary>
            2nd row - 1st column value of the Matrix.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.M22">
            <summary>
            2nd row - 2nd column value of the Matrix.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.M23">
            <summary>
            2nd row - 3nd column value of the Matrix.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.M24">
            <summary>
            2nd row - 4nd column value of the Matrix.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.M31">
            <summary>
            3rd row - 1st column value of the Matrix.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.M32">
            <summary>
            3rd row - 2nd column value of the Matrix.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.M33">
            <summary>
            3rd row - 3rd column value of the Matrix.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.M34">
            <summary>
            3rd row - 4th column value of the Matrix.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.M41">
            <summary>
            4th row - 1st column value of the Matrix.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.M42">
            <summary>
            4th row - 2nd column value of the Matrix.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.M43">
            <summary>
            4th row - 3rd column value of the Matrix.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.M44">
            <summary>
            4th row - 4th column value of the Matrix.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.Translation">
            <summary>
            The translation amount representing by the matrix.
            This vector shares the same data as M41, M42, M43, see above!
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.Right">
            <summary>
            Right vector of the matrix (M11, M12, M13)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.Up">
            <summary>
            Up vector of the matrix (M21, M22, M23)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.Front">
            <summary>
            Front vector of the matrix (M31, M32, M33)
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Create matrix by passing all the necessary values
            </summary>
            <param name="setM11">Set M11 value (first row)</param>
            <param name="setM12">Set M12 value (first row)</param>
            <param name="setM13">Set M13 value (first row)</param>
            <param name="setM14">Set M14 value (first row)</param>
            <param name="setM21">Set M21 value (second row)</param>
            <param name="setM22">Set M22 value (second row)</param>
            <param name="setM23">Set M23 value (second row)</param>
            <param name="setM24">Set M24 value (second row)</param>
            <param name="setM31">Set M31 value (third row)</param>
            <param name="setM32">Set M32 value (third row)</param>
            <param name="setM33">Set M33 value (third row)</param>
            <param name="setM34">Set M34 value (third row)</param>
            <param name="setM41">Set M41 value (forth row)</param>
            <param name="setM42">Set M42 value (forth row)</param>
            <param name="setM43">Set M43 value (forth row)</param>
            <param name="setM44">Set M44 value (forth row)</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.#ctor(System.Single[])">
            <summary>
            Create matrix by passing all 16 matrix values as array.
            m11, m12, m13, m14, 
            m21, m22, m23, m24,
            m31, m32, m33, m34, 
            m41, m42, m43, m44, 
            </summary>
            <param name="setMatrix">Set Matrix</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.#ctor(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Create matrix by passing in 3 vectors for M11-M33, rest stays default.
            </summary>
            <param name="firstRowVector">Vector for the first row (M11-M13)
            </param>
            <param name="secondRowVector">Vector for the second row (M21-M23)
            </param>
            <param name="thirdRowVector">Vector for the third row (M31-M33)
            </param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.#ctor(System.IO.BinaryReader)">
            <summary>
            Create matrix with help of BinaryReader, we will read 16 floats from
            the stream that is linked up with this BinaryReader.
            </summary>
            <param name="reader">Reader</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.Equals(Delta.Utilities.Datatypes.Matrix)">
            <summary>
            Equals, quickly checks if another matrix has the exact same values.
            This methods needs to copy 64 bytes around (1 matrix of 64 bytes).
            Try to use the ref version instead.
            </summary>
            <param name="other">Other Matrix to compare to</param>
            <returns>True if both matrices are equal, false otherwise.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.Load(System.IO.BinaryReader)">
            <summary>
            Load the matrix values from a stream (64 bytes, 16 floats).
            </summary>
            <param name="reader">The stream that will be used.</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.Save(System.IO.BinaryWriter)">
            <summary>
            Saves the matrix to a stream (64 bytes, 16 floats).
            </summary>
            <param name="writer">The stream that will be used.</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.op_Multiply(Delta.Utilities.Datatypes.Matrix,Delta.Utilities.Datatypes.Matrix)">
            <summary>
            Multiply operator. Warning: This operator is slower than using ref
            version, it needs to copy 192 bytes around (3 matrices, each 64 bytes).
            </summary>
            <param name="matrix1">Matrix 1 to multiply</param>
            <param name="matrix2">Matrix 2 to multiply</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.op_Multiply(Delta.Utilities.Datatypes.Matrix,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Operator to multiply matrix with a vector. This is very useful to
            transform vectors with the given matrix. Warning: This is slower than
            the ref version, this operator needs to copy 88 bytes around (1 matrix,
            64 bytes and 2 vectors, each 12 bytes)
            </summary>
            <param name="matrix">Matrix to multiply</param>
            <param name="vector">Vector to multiply with</param>
            <returns>Resulting vector from the multiplication.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.op_Multiply(Delta.Utilities.Datatypes.Matrix,System.Single)">
            <summary>
            Operator to multiply matrix with a scale factor. Try to use the ref
            version instead, this needs to copy 128 bytes around (2 matrices, each
            64 bytes).
            </summary>
            <param name="matrix">Matrix to multiply</param>
            <param name="scaleFactor">Scale factor to multiply with</param>
            <returns>
            New matrix with all values multiplied by scaleFactor.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.op_Multiply(System.Single,Delta.Utilities.Datatypes.Matrix)">
            <summary>
            Operator to multiply matrix with a scale factor. Try to use the ref
            version instead, this needs to copy 128 bytes around (2 matrices, each
            64 bytes).
            </summary>
            <param name="matrix">Matrix to multiply</param>
            <param name="scaleFactor">Scale factor to multiply with</param>
            <returns>
            New matrix with all values multiplied by scaleFactor.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.op_Addition(Delta.Utilities.Datatypes.Matrix,Delta.Utilities.Datatypes.Matrix)">
            <summary>
            Operator to add two matrices together, used in some physics or
            advanced math functions.
            Note: Since this is not used often we do not need a ref version!
            </summary>
            <param name="matrix1">Matrix1 to add</param>
            <param name="matrix2">Matrix2 to add</param>
            <returns>
            New matrix with all values of matrix1 and matrix2 added.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.op_Subtraction(Delta.Utilities.Datatypes.Matrix,Delta.Utilities.Datatypes.Matrix)">
            <summary>
            Operator to subtract one matrix from another, used in some physics or
            advanced math functions.
            Note: Since this is not used often we do not need a ref version!
            </summary>
            <param name="matrix1">Matrix1 as the basis</param>
            <param name="matrix2">Matrix2 to substract from Matrix1</param>
            <returns>
            New matrix with all values of matrix2 substracted from matrix1.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.op_Division(Delta.Utilities.Datatypes.Matrix,Delta.Utilities.Datatypes.Matrix)">
            <summary>
            Operator to divide through matrices through each other.
            Note: Since this is not used often we do not need a ref version!
            </summary>
            <param name="matrix1">Matrix1 as the basis</param>
            <param name="matrix2">Matrix2 to divide from Matrix1. Note: None of the
            values should be 0, else exceptions will occur.</param>
            <returns>
            New matrix with all values of matrix1 values divided by matrix2.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.op_Division(Delta.Utilities.Datatypes.Matrix,System.Single)">
            <summary>
            Operator to divide matrix through a scale factor.
            Note: Since this is not used often we do not need a ref version!
            </summary>
            <param name="matrix1">Matrix to divide.</param>
            <param name="divider">Divider, must not be 0</param>
            <returns>
            New matrix with all values of matrix1 values divided by divider.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.op_UnaryNegation(Delta.Utilities.Datatypes.Matrix)">
            <summary>
            Operator to do an unary negation (just make all values negative).
            Note: Since this is not used often we do not need a ref version!
            </summary>		
            <param name="matrix1">Matrix to negate</param>
            <returns>New matrix with all values negated.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.op_Equality(Delta.Utilities.Datatypes.Matrix,Delta.Utilities.Datatypes.Matrix)">
            <summary>
            Operator for equality. Try to use the ref version instead, this needs
            to copy 128 bytes around (2 matrices, each 64 bytes).
            </summary>
            <param name="matrix1">matrix1</param>
            <param name="matrix2">matrix2</param>
            <returns>True if matrix1 and matrix2 have the same values.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.op_Inequality(Delta.Utilities.Datatypes.Matrix,Delta.Utilities.Datatypes.Matrix)">
            <summary>
            Op inequality. Try to use the ref version instead, this needs to copy
            128 bytes around (2 matrices, each 64 bytes).
            </summary>
            <param name="matrix1">matrix1</param>
            <param name="matrix2">matrix2</param>
            <returns>
            True if matrix1 and matrix2 do not have the same values.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.GetRow(System.Int32)">
            <summary>
            Gets the n-th (0-3) row of the matrix.
            </summary>
            <param name="index">Zero based index of the row we want</param>
            <returns>The 0-3 row (right, up, front, translation)</returns>
            <exception cref="T:System.IndexOutOfRangeException">
            Is thrown if index is not 0, 1, 2 or 3
            </exception>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.Move2D(Delta.Utilities.Datatypes.Point)">
            <summary>
            Helper method to quickly move (translate) the matrix by a specified
            2D amount. Used for font rendering and aligning the text. If the
            matrix scaling is 1, 1, 1 and there is no orientation change we could
            also just add this value to the Translation property, but that is
            rarely the case (not even for ScreenSpace.ViewProjection2D for fonts).
            </summary>
            <param name="offset">How much to move the translation</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.Equals(System.Object)">
            <summary>
            Equals check with an object, will only return true if it is a matrix
            and has the exact same values as this matrix.
            </summary>
            <param name="obj">obj</param>
            <returns>True if obj is a Matrix and the same as this matrix.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.GetHashCode">
            <summary>
            Get hash code
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.ToString">
            <summary>
            To string
            </summary>
            <returns>string</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.ToColladaString">
            <summary>
            To collada string, which is just a space separated column-based matrix.
            </summary>
            <returns>
            All 16 matrix float values as invariant string in column format.
            </returns>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Matrix.Scaling">
            <summary>
            The scaling amount representing by the matrix.
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Matrix.Determinant">
            <summary>
            Returns the determinant of the matrix. Uses optimized code paths
            because XNAs implementation is twice as fast as ours, OpenTK is
            slightly faster (see MatrixPerformance class).
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Matrix.Inverse">
            <summary>
            Returns the inverse of the current matrix, which can be slightly
            faster than using the static Invert method below depending on the
            platform (e.g. with XNA), with Delta matrix code Invert() is a little
            faster however, so just use whatever method fits best for you.
            Both methods are the slowest matrix methods however, use with care!
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Matrix.MatrixTests">
            <summary>
            Tests
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Matrix.MatrixTests.matrix">
            <summary>
            Create a simple test martix for testing with unique values
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixTests.AssertMatrix(Delta.Utilities.Datatypes.Matrix,Delta.Utilities.Datatypes.Matrix,System.Int32)">
            <summary>
            Assert matrix, makes sure two matrices have ruffly the same value.
            This is more precise than Matrix.NearlyEqual, which just checks
            the transpose vector distance.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixTests.SizeOf">
            <summary>
            Checks if the size of Point is exactly 8 bytes (2 floats: X and Y)
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixTests.MultiplyWithMatrix">
            <summary>
            Multiply with matrix
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixTests.MultiplyWithVector">
            <summary>
            Multiply with vector
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixTests.MultiplyWithScalar">
            <summary>
            Multiply with scalar
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixTests.Add">
            <summary>
            Add
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixTests.Substract">
            <summary>
            Substract
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixTests.DivideThroughMatrix">
            <summary>
            Divide through matrix
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixTests.DivideThroughScalar">
            <summary>
            Divide through scalar
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixTests.Negate">
            <summary>
            Negate
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixTests.CreateScale">
            <summary>
            Create scale
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixTests.CreateRotationX">
            <summary>
            Create rotation x
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixTests.CreateRotationY">
            <summary>
            Create rotation y
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixTests.CreateRotationZ">
            <summary>
            Create rotation z
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixTests.CreateTranslation">
            <summary>
            Create translation
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixTests.CreateLookAt">
            <summary>
            CreateLookAt
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixTests.Invert">
            <summary>
            Invert
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixTests.Equals">
            <summary>
            Equals
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Matrix.MatrixPerformance">
            <summary>
            Matrix performance class to figure out performance differences between
            different implementations of Matrix methods available on different
            platforms and in different frameworks.
            <para />
            Tests were done originally with an Core i7 920 @ 2.67 GHz and 6GB RAM
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixPerformance.TestInvert">
            <summary>
            Test invert
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixPerformance.TestOperators">
            <summary>
            Test Operators
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixPerformance.TestDeterminant">
            <summary>
            Test determinant
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixPerformance.TestEquality">
            <summary>
            Test equality
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixPerformance.TestInequality">
            <summary>
            Test inequality
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixPerformance.TestFromQuaternion">
            <summary>
            Test from quaternion
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixPerformance.TestScale">
            <summary>
            Test scale
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixPerformance.TestRotation">
            <summary>
            Test rotation
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixPerformance.TestTranslation">
            <summary>
            Test translation
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixPerformance.TestTranspose">
            <summary>
            Test translation
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixPerformance.TestCreateLookAt">
            <summary>
            Test create look at
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixPerformance.TestCreateOrthographic">
            <summary>
            Test create look at
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixPerformance.TestCreatePerspective">
            <summary>
            Test create perspective
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixPerformance.TestComplexCase">
            <summary>
            Test complex cases with the matrix struct.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Matrix.MatrixPerformance.ExecuteAllForPerformanceOverview">
            <summary>
            Execute all tests for a performance overview.
            </summary>
        </member>
        <member name="T:Delta.Utilities.Profiling.BaseTimeSource">
            <summary>
            Interface for Time sources. All TimeSource should start at tick 0 after
            the constructor was called.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Profiling.BaseTimeSource.ElapsedMilliseconds">
            <summary>
            Elapsed milliseconds as a long value. Can be converted quite easily
            from the ticks values times 1000 divided by the timer frequency.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Profiling.BaseTimeSource.LastMilliseconds">
            <summary>
            Last frame milliseconds value. Used for many checks if some time
            interval has passed. The Time.Delta value is even more accurate
            because it is a float value and can be very small.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Profiling.BaseTimeSource.ElapsedSeconds">
            <summary>
            Total seconds that have passed of the application time. Use
            ElapsedMilliseconds for more accurate application timings.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Profiling.BaseTimeSource.LastSeconds">
            <summary>
            Last frame elapsed seconds. Used for some quick checks if a second
            has passed.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Profiling.BaseTimeSource.stringBuilder">
            <summary>
            The time string is usually 6 letters long like 03.498, but can go up
            to 9 or 10 for big times like 59:03.458 or 643:49.584. But we allow
            much bigger messages for Log.FormatMessage.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Profiling.BaseTimeSource.Update">
            <summary>
            Update the current ElapsedTicks and ElapsedMilliseconds values and
            return the difference to the last time this method was called as a
            floating point value in seconds.
            </summary>
            <returns>Difference to the last time this method was called, should
            never be null (we might devide through this value).</returns>
        </member>
        <member name="M:Delta.Utilities.Profiling.BaseTimeSource.GetExactTotalTimeInSecondsToday">
            <summary>
            Reports a very accurate value rounded to a float in seconds for today.
            Warning: This method is slow, try to use Time.Seconds,
            Time.Milliseconds, Time.Delta, etc. instead if possible (much faster).
            The return value is in seconds and reports a fraction for up to 0.1ns.
            The value will be reset every day to stay accurate (again, after 3
            days floats lose accuracy and will not be very useful anymore). Used
            for profilers and more accurate input for example. If you do not need
            this high accuracy please only use the Milliseconds value or the helper
            methods here (all millisecond exact and updated once per frame).
            </summary>
            <returns>Time in seconds today as a float value, not very accurate,
            but good enough for a day (after 20-40 days it gets really inaccurate)
            </returns>
        </member>
        <member name="M:Delta.Utilities.Profiling.BaseTimeSource.ToString">
            <summary>
            To string helper method to display the total time in the format:
            [Minutes optional:]Seconds:Milliseconds, which is used for logging,
            but also useful for debugging and profiling.
            </summary>
            <returns>String with the time in the format
            Minutes:Seconds:Milliseconds</returns>
        </member>
        <member name="M:Delta.Utilities.Profiling.BaseTimeSource.ToTimeString(System.Char,System.String)">
            <summary>
            To string helper method to display the total time in the format:
            [Hour optional:][Minutes optional:]Seconds:Milliseconds, which is used
            for logging, but also useful for debugging and profiling.
            </summary>
            <param name="message">Message to be written after the time stamp
            </param>
            <param name="separator">Separator between the time stamp and the
            message (e.g. ": ")</param>
            <returns>String with the time in the format
            [optional Hour:][optional Minutes:]Seconds:Milliseconds</returns>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Rectangle">
            <summary>
            Rectangle class, just consists of x, y, width and height (all float
            values). There is a possibility to rotate rectangles with the Rotate
            method, but the rotation data is not kept. This is mostly because
            passing big structures around in the engine is too slow. It is actually
            faster just to calculate the rotation if really needed (it is not
            needed much anyway). Performance testing is at the end of this file!
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Rectangle.Zero">
            <summary>
            Returns a rectangle at the position (0,0) with the size (0,0).
            -> Can be used to determine if a rectangle is "used" or not.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Rectangle.One">
            <summary>
            Returns a rectangle at the position (0,0) and with the size (1,1).
            -> Can be used for fullscreen rendering or for the full UV layout.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.FromCenter(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Create a new rectangle from a center position and given size.
            </summary>
            <param name="setCenterX">
            The x coordinate of the rectangle center.
            </param>
            <param name="setCenterY">
            The y coordinate of the rectangle center.
            </param>
            <param name="setWidth">Width of the new rectangle.</param>
            <param name="setHeight">Height of the new rectangle.</param>
            <returns>Rectangle</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.FromCenter(Delta.Utilities.Datatypes.Point,System.Single)">
            <summary>
            Create a new rectangle from a center position and given size.
            </summary>
            <param name="setCenterPosition">
            The center position of the rectangle.
            </param>
            <param name="setDimension">
            The dimension of the quadratic rectangle.
            </param>
            <returns>New rectangle created from center</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.FromCenter(Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Size)">
            <summary>
            Create a new rectangle from a center position and given size.
            </summary>
            <param name="setCenterPosition">
            The center position of the rectangle.
            </param>
            <param name="setSize">
            The size of the rectangle.
            </param>
            <returns>New rectangle created from center</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.FromCorners(Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Point)">
            <summary>
            Creates a rectangle based on the given corner coordinates.
            </summary>
            <param name="TopLeft">Top left</param>
            <param name="BottomRight">Bottom right</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.FromColladaString(System.String)">
            <summary>
            From collada string, the opposite of the ToColladaString method.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.FromCommaString(System.String)">
            <summary>
            From comma string, the opposite of the ToCommaString method.
            </summary>
            <param name="commaString">CommaString</param>
            <returns>Rectangle created from the commaString</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.BuildUVRectangle(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Build UV rectangle for a given image width and height. Will also
            take care of 0.5 pixel offseting, which is very important for 2d
            rendering and font rendering in particular. The offset is to make sure
            all pixels are offseted by 0.5, 0.5 (a little less actually) to make
            rendering work fine in XNA and DirectX modes. For OpenTK it works
            mostly without, but this seems to be driver specific, so with this
            offset everything still looks fine and won't hurt.
            </summary>
            <param name="x">X position</param>
            <param name="y">Y position</param>
            <param name="width">Width</param>
            <param name="height">Heigth</param>
            <param name="imageHeight">Total image height</param>
            <param name="imageWidth">Total image width</param>
            <returns>Created UV Rectangle from the given data</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.BuildUVRectangle(Delta.Utilities.Datatypes.Rectangle,Delta.Utilities.Datatypes.Size)">
            <summary>
            Build UV rectangle for a given uv pixel rect and imageSize. Will also
            take care of 0.5 pixel offseting, which is very important for 2d
            rendering and font rendering in particular. The offset is to make sure
            all pixels are offseted by 0.5, 0.5 (a little less actually) to make
            rendering work fine in XNA and DirectX modes. For OpenTK it works
            mostly without, but this seems to be driver specific, so with this
            offset everything still looks fine and won't hurt.
            <para>
            Warning: Do not use that for converting pixel space into quadratic
            space, use the Screen class for that.
            </para>
            </summary>
            <param name="uvInPixels">UV rectangle in pixels</param>
            <param name="bitmapSize">Bitmap size (to devide through)</param>
            <returns>Created UV Rectangle from the given data</returns>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Rectangle.X">
            <summary>
            X coordinate of the position.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Rectangle.Y">
            <summary>
            Y coordinate of the position.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Rectangle.Width">
            <summary>
            Width
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Rectangle.Height">
            <summary>
            Height
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Rectangle.Position">
            <summary>
            Position of the rectangle, just X and Y
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Rectangle.Size">
            <summary>
            Gets or sets the Size of the rectangle, just Width and Height
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Rectangle.Left">
            <summary>
            Left edge, same as X
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Rectangle.Top">
            <summary>
            Top edge, same as Y
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Rectangle.TopLeft">
            <summary>
            Returns the top left position, which is just X, Y again (as Position)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Rectangle.lastRotationAngle">
            <summary>
            Helpers for the Rotate method.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a rectangle.
            </summary>
            <param name="setHeight">setHeight</param>
            <param name="setLeft">setLeft</param>
            <param name="setTop">setTop</param>
            <param name="setWidth">setWidth</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.#ctor(Delta.Utilities.Datatypes.Point,Delta.Utilities.Datatypes.Size)">
            <summary>
            Creates a rectangle.
            </summary>
            <param name="setPosition">setPosition</param>
            <param name="setSize">setSize</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.#ctor(System.IO.BinaryReader)">
            <summary>
            Create rectangle
            </summary>
            <param name="setData">Set data</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.Equals(Delta.Utilities.Datatypes.Rectangle)">
            <summary>
            Check if two rectangles are nearly equal (using MathHelper.Epsilon).
            </summary>
            <param name="other">other</param>
            <returns>True if the other rectangle has the same values (allowing
            MathHelper.Espilon difference between the rectangles).</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.Load(System.IO.BinaryReader)">
            <summary>
            Load rectangle from a binary stream (16 bytes, 4 floats).
            </summary>
            <param name="reader">reader</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.Save(System.IO.BinaryWriter)">
            <summary>
            Save rectangle to a binary stream (16 bytes, 4 floats).
            </summary>
            <param name="writer">writer</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.op_Equality(Delta.Utilities.Datatypes.Rectangle,Delta.Utilities.Datatypes.Rectangle)">
            <summary>
            Check for equality, will check if both rectangles are almost equal.
            </summary>
            <param name="value1">Rectangle 1</param>
            <param name="value2">Rectangle 2</param>
            <returns>True if both rectangles are almost equal.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.op_Inequality(Delta.Utilities.Datatypes.Rectangle,Delta.Utilities.Datatypes.Rectangle)">
            <summary>
            Check for inequality, will check if both rectangles are almost equal.
            </summary>
            <param name="value1">value1</param>
            <param name="value2">value2</param>
            <returns>True if both rectangles are not equal.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.Equals(System.Object)">
            <summary>
            Check for equality, will check if both rectangles are almost equal.
            </summary>
            <param name="obj">Object to compare to</param>
            <returns>True if obj is a rectangle and almost equal</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.GetHashCode">
            <summary>
            Get hash code for this rectangle
            </summary>
            <returns>Hash code, build from X, Y, Width and Height</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.Shrink(System.Single)">
            <summary>
            Shrinks the rectangle by the given quad space amount, this will
            reduce the size by quadSpaceValue * 2 (all borders will be reduced
            by quadSpaceValue). Note that the original rectangle is unchanged,
            only the returned rectangle has the new size.
            </summary>
            <param name="quadSpaceValue">Quad space value for reducing</param>
            <returns>Reduced rectangle</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.Grow(System.Single)">
            <summary>
            Grows the rectangle by the given quad space amount, this will
            increase the size by quadSpaceValue * 2 (all borders will be increased
            by quadSpaceValue). Note that the original rectangle is unchanged,
            only the returned rectangle has the new size.
            </summary>
            <param name="quadSpaceValue">Quad space value for increasing</param>
            <returns>Increased rectangle</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.ScaleCentered(System.Single)">
            <summary>
            Scale a rectangle centered. Note that the original rectangle is
            unchanged, only the returned rectangle has the new size.
            </summary>
            <param name="scaleFactor">Scale factor to increase at all sides</param>
            <returns>Increased rectangle</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.ScaleCentered(System.Single,System.Single)">
            <summary>
            Scale a rectangle centered. Note that the original rectangle is
            unchanged, only the returned rectangle has the new size.
            </summary>
            <param name="scaleHeight">Scale factor to increase height</param>
            <param name="scaleWidth">Scale factor to increase width</param>
            <returns>Increased rectangle</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.Contains(Delta.Utilities.Datatypes.Point)">
            <summary>
            Determines whether a point lies inside a rectangle or not.
            </summary>
            <param name="position">The position we want to check if it
            intersects with the rectangle.</param>
            <returns>
              <c>true</c> if the Rectangle contains the point; otherwise,
              <c>false</c>.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.Contains(Delta.Utilities.Datatypes.Rectangle)">
            <summary>
            Intersects with another rectangle? This means rectangle should
            be inside or touching one border. If not, rectangle is out of
            our rectangle, which is useful for ScreenArea visibility checks.
            </summary>
            <param name="rectangle">The rectangle.</param>
            <returns>
            Fully: if the rectangle is inside this Rectangle
            Partially: if the two rectangles intersect
            None: The rectangles are far apart 
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.Move(Delta.Utilities.Datatypes.Point)">
            <summary>
            Will return a copy of the current rectangle which is moved by the given
            offset.
            </summary>
            <param name="offset">Offset to move</param>
            <returns>Moved rectangle</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.Move(System.Single,System.Single)">
            <summary>
            Will return a copy of the current rectangle which is moved by the given
            offsets.
            </summary>
            <param name="xOffset">X offset to move</param>
            <param name="yOffset">Y offset to move</param>
            <returns>Moved rectangle</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.ToString">
            <summary>
            To string, will provide a string about the position and size of this
            rectangle. Use ToColladaString or ToCommaString for storing this
            Rectangle as a string in text or xml files (because we have
            FromColladaString and FromCommaString methods, but we got no
            FromString method).
            </summary>
            <returns>string</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.ToColladaString">
            <summary>
            Returns the vector as a string that can be used in a Collada file.
            Note: Use FromColladaString to load this Rectangle again.
            </summary>
            <returns>
            String with the X, Y, Width and Height values just separated by spaces.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.ToCommaString">
            <summary>
            Returns the vector as a string with commas (x, y, width, height).
            Note: Use FromCommaString to load this Rectangle again.
            </summary>
            <returns>
            String with the X, Y, Width and Height values separated by commas.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.Rotate(System.Single,Delta.Utilities.Datatypes.Point[])">
            <summary>
            Rotate rectangle around its center and return the 4 corner points in
            this order: TopLeft, TopRight, BottomRight, BottomLeft. This way
            these points can be rendered directly by a shader. Used for material
            drawing (rendering). Will return the original rectangle if
            rotationAngle is 0 (then executing this is much faster).
            Note: This method is not returning anything new, it will only change
            the content of rotPoints because of performance. Creating an array of
            4 points (8 floats) costs a lot of performance on mobile platforms. If
            you do it hundred or thousands of times per frame you don't want all
            these newly created point arrays hanging around. Instead each caller
            uses his own point array (only initialized once).
            </summary>
            <param name="rotationAngle">rotationAngle</param>
            <param name="rotPoints">
            Preinitialized array of 4 Points used to store the rotation points
            resulting in the rectangle rotation with rotationAngle.
            </param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.Rotate(System.Single,Delta.Utilities.Datatypes.Point[],Delta.Utilities.Datatypes.Point)">
            <summary>
            Rotate rectangle around its center and return the 4 corner points in
            this order: TopLeft, TopRight, BottomRight, BottomLeft. This way
            these points can be rendered directly by a shader. Used for material
            drawing (rendering). Will return the original rectangle if
            rotationAngle is 0 (then executing this is much faster).
            Special version of this method with a given center rotation point!
            </summary>
            <param name="center">center</param>
            <param name="rotationAngle">rotationAngle</param>
            <param name="rotPoints">rotPoints</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.GetInnerPosition(Delta.Utilities.Datatypes.Point)">
            <summary>
            Get inner position helper method. Used by FbxFile.GetMeshData to
            remap UVs from the FBX Model file to our new atlas texture UVs.
            </summary>
            <param name="relativePosition">Relative position (0-1)</param>
            <returns>
            Point inside this rectangle based on the relative position.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.GetInnerRectangle(Delta.Utilities.Datatypes.Rectangle)">
            <summary>
            Get inner position helper method out of a relative rectangle. This
            can be used to position stuff inside controls, mini-maps, for aligning
            and re-mapping UVs from model files and much more.
            </summary>
            <param name="relativeRectangle">Relative rectangle, if this is
            Rectangle.One, the current rectangle will be returned.</param>
            <returns>Returns the current rectangle multiplied by the
            relativeRectangle (usually smaller, inside of it)</returns>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Rectangle.XProperty">
            <summary>
            Property-wrapper for using the X field in the editor.
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Rectangle.YProperty">
            <summary>
            Property-wrapper for using the Y field in the editor
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Rectangle.WidthProperty">
            <summary>
            Property-wrapper for using the X field in the editor.
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Rectangle.HeightProperty">
            <summary>
            Property-wrapper for using the Y field in the editor
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Rectangle.IsZero">
            <summary>
            Is zero
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Rectangle.Right">
            <summary>
            Right edge, which is at X+Width
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Rectangle.Bottom">
            <summary>
            Bottom edge, which is at Y+Height
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Rectangle.Center">
            <summary>
            The center point of the rectangle at X+Width/2, Y+Height/2.
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Rectangle.TopRight">
            <summary>
            Returns the top right position.
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Rectangle.BottomLeft">
            <summary>
            Returns the bottom left position.
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Rectangle.BottomRight">
            <summary>
            Returns the bottom right position.
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Rectangle.RectanglePerformance">
            <summary>
            Rectangle performance class to figure out performance.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectanglePerformance.TestCreation">
            <summary>
            Test the creation of a rectangle.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectanglePerformance.TestCopy">
            <summary>
            Test the copy method of the rectangle struct.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectanglePerformance.TestMove">
            <summary>
            Test the move method of the rectangle struct.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectanglePerformance.TestIntersects">
            <summary>
            Test the intersects method of the rectangle struct.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectanglePerformance.TestRotate">
            <summary>
            Test the rotate method of the rectangle struct.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectanglePerformance.ExecuteAllForPerformanceOverview">
            <summary>
            Execute all rectangle tests for a performance overview.
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Rectangle.RectangleTests">
            <summary>
            Tests
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectangleTests.SizeOf">
            <summary>
            Checks if the size of Point is exactly 8 bytes (2 floats: X and Y)
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectangleTests.Properties">
            <summary>
            Properties
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectangleTests.FromCenter">
            <summary>
            From center
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectangleTests.FromCorners">
            <summary>
            From corners
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectangleTests.FromColladaString">
            <summary>
            From collada string
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectangleTests.FromCommaString">
            <summary>
            From comma string
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectangleTests.EqualOperator">
            <summary>
            Equal Operator
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectangleTests.InequalOperator">
            <summary>
            Inequal Operator
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectangleTests.NearlyEquals">
            <summary>
            Nearly equals
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectangleTests.ScaleCentered">
            <summary>
            Scale centered
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectangleTests.TestContains">
            <summary>
            Tests Rectangle.Contains(Point)
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectangleTests.TestContiansRectangle">
            <summary>
            Tests rectangle.Contains(rectangle)
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectangleTests.Move">
            <summary>
            Move
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectangleTests.ToString">
            <summary>
            To string
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectangleTests.ToColladaString">
            <summary>
            ToColladaString
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Rectangle.RectangleTests.ToCommaString">
            <summary>
            ToCommaString
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Plane">
            <summary>
            Plane helper struct to manage planes with just a normal 
            vector and D for the distance. Details can be found at:
            http://en.wikipedia.org/wiki/Plane_%28geometry%29
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Plane.Normal">
            <summary>
            Normal for the plane.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Plane.Distance">
            <summary>
            Distance of the plane from the origin.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.#ctor(Delta.Utilities.Datatypes.Vector,System.Single)">
            <summary>
            Create plane
            </summary>
            <param name="distance">distance</param>
            <param name="normal">normal</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Create plane
            </summary>
            <param name="distance">distance</param>
            <param name="x">X</param>
            <param name="y">Y</param>
            <param name="z">Z</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.#ctor(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Create plane
            </summary>
            <param name="point1">point1</param>
            <param name="point2">point2</param>
            <param name="point3">point3</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.Equals(Delta.Utilities.Datatypes.Plane)">
            <summary>
            Equals
            </summary>
            <param name="other">Other</param>
            <returns>Value indicating the equality of two vectors</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.Intersects(Delta.Utilities.Datatypes.Ray,Delta.Utilities.Datatypes.Vector@)">
            <summary>
            Intersects the current object with specified ray and returns true
            plus the intersectionPosition if the ray hits this object.
            </summary>
            <param name="ray">The ray to check with</param>
            <param name="intersectionPosition">The intersection vector</param>
            <returns>True if the ray intersected with this object</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.Intersects(Delta.Utilities.Datatypes.Plane,Delta.Utilities.Datatypes.Vector@)">
            <summary>
            Intersects the current object with specified plane and returns true
            plus the intersectionPosition if the plane intersects this object.
            </summary>
            <param name="plane">The plane to check with</param>
            <param name="intersectionPosition">The intersection vector</param>
            <returns>True if the plane intersected with this object</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.Intersects(Delta.Utilities.Datatypes.BoundingSphere)">
            <summary>
            Intersects the current object with the specified sphere.
            </summary>
            <param name="sphere">The sphere to check against</param>
            <returns>True if the sphere intersected with this object</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.Intersects(Delta.Utilities.Datatypes.BoundingBox)">
            <summary>
            Intersects the current object with the specified box.
            </summary>
            <param name="box">The box to check against</param>
            <returns>True if the box intersected with this object</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.Load(System.IO.BinaryReader)">
            <summary>
            Loads the plane from a binary stream (just the normal and distance).
            </summary>
            <param name="reader">reader</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.Save(System.IO.BinaryWriter)">
            <summary>
            Saves the plane into a binary stream (just the normal and distance).
            </summary>
            <param name="writer">Writer</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.op_Equality(Delta.Utilities.Datatypes.Plane,Delta.Utilities.Datatypes.Plane)">
            <summary>
            Check for equality
            </summary>
            <param name="value1">Value1</param>
            <param name="value2">Value2</param>
            <returns>True if the values are equal, false otherwise</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.op_Inequality(Delta.Utilities.Datatypes.Plane,Delta.Utilities.Datatypes.Plane)">
            <summary>
            Check for inequality
            </summary>
            <param name="value1">Value1</param>
            <param name="value2">Value2</param>
            <returns>True if the values are not equal, false otherwise</returns>	
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.DotCoordinate(Delta.Utilities.Datatypes.Vector)">
            <summary>
            Dot coordinate
            </summary>
            <param name="value">Value</param>
            <returns>Result of the dot calculation.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.DotCoordinate(Delta.Utilities.Datatypes.Vector@,System.Single@)">
            <summary>
            Dot coordinate
            </summary>
            <param name="result">result</param>
            <param name="value">value</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.GetDistance(Delta.Utilities.Datatypes.Vector)">
            <summary>
            Get distance from the given position to the plane.
            </summary>
            <param name="position">Position vector to check with.</param>
            <returns>The shortest distance between the position and the plane.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.Normalize">
            <summary>
            Normalize
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.Intersects(Delta.Utilities.Datatypes.Vector)">
            <summary>
            Determines whether a vector point is intersecting with a plane 
            otherwise defines its position.
            </summary>
            <param name="point">The point</param>
            <returns></returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.GetHashCode">
            <summary>
            Get hash code
            </summary>
            <returns>hash code</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.Equals(System.Object)">
            <summary>
            Equals
            </summary>
            <param name="obj">Object to compare</param>
            <returns>True if obj is a plane and equal to this plane.</returns>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Plane.PlaneTests">
            <summary>
            Tests
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.PlaneTests.CreatePlane">
            <summary>
            Test CreatePlane
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.PlaneTests.TestIntersects">
            <summary>
            Plane Intersection Tests
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.PlaneTests.Equality">
            <summary>
            Test Equality
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Plane.PlaneTests.DotCoordinate">
            <summary>
            Test DotCoordinate. Calculation:
            (N.X * value.X) + (N.Y * value.Y) + (N.Z * value.Z) + Distance
            </summary>
        </member>
        <member name="T:NUnit.Framework.CategoryAttribute">
            <summary>
            Nothing is in here, this is just a fake class to help tools to detect
            unit tests. Helper to simulate NUnit unit tests to be detected by test
            unit runners like ReSharper. TestDriven.NET however requires that a
            supported NUnit.Framework.dll is used, which is too much hassle for us,
            but you can easily do it if you like.
            </summary>
        </member>
        <member name="F:NUnit.Framework.CategoryAttribute.LongRunning">
            <summary>
            Tests in the categories "LongRunning" and "Visual" will be excluded,
            they should not be run automatically, see
            http://DeltaEngine.net/Wiki.CodingConventions
            </summary>
        </member>
        <member name="F:NUnit.Framework.CategoryAttribute.Visual">
            <summary>
            Tests in the categories "LongRunning" and "Visual" will be excluded,
            they should not be run automatically (same goes for "Static" or
            "Integration"), see http://DeltaEngine.net/Wiki.CodingConventions
            </summary>
        </member>
        <member name="T:Delta.Utilities.Profiling.StopwatchTimeSource">
            <summary>
            Implementation of ITimeSource using C# Stopwatch class
            </summary>
        </member>
        <member name="F:Delta.Utilities.Profiling.StopwatchTimeSource.stopwatch">
            <summary>
            Internal stopwatch
            </summary>
        </member>
        <member name="F:Delta.Utilities.Profiling.StopwatchTimeSource.timerFrequency">
            <summary>
            Number of ticks per second
            </summary>
        </member>
        <member name="F:Delta.Utilities.Profiling.StopwatchTimeSource.lastTicks">
            <summary>
            Ticks from last frame, used to calculate Delta, which is more
            accurate than using just ElapsedMilliseconds.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Profiling.StopwatchTimeSource.#ctor">
            <summary>
            Create stopwatch time source
            </summary>
        </member>
        <member name="M:Delta.Utilities.Profiling.StopwatchTimeSource.Update">
            <summary>
            Update the current ElapsedTicks and ElapsedMilliseconds values and
            return the difference of the last time with a floating point value.
            </summary>
            <returns>Difference to the last time this method was called</returns>
        </member>
        <member name="M:Delta.Utilities.Profiling.StopwatchTimeSource.GetExactTotalTimeInSecondsToday">
            <summary>
            Reports a very accurate value rounded to a float in seconds for today.
            The return value is in seconds and reports a fraction for up to 0.1ns.
            The value will be reset every day to stay accurate (again, after 3
            days floats lose accuracy and will not be very useful anymore). Used
            for profilers and more accurate input for example. If you do not need
            this high accuracy please only use the Milliseconds value or the helper
            methods here (all millisecond exact and updated once per frame).
            </summary>
            <returns>Time in seconds today as a float value, not very accurate,
            but good enough for a day (after 20-40 days it gets really inaccurate)
            </returns>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Advanced.VerticalAlignment">
            <summary>
            The available modes to align a text vertically. Just top and center modes
            exist right now, bottom was not needed yet. Add it once needed.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.VerticalAlignment.None">
            <summary>
            Displays the object unaligned to their original specified position.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.VerticalAlignment.Top">
            <summary>
            Displays the object aligned at the top.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.VerticalAlignment.Centered">
            <summary>
            Displays the object vertically centered.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.VerticalAlignment.Bottom">
            <summary>
            Displays the object aligned at the bottom.
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Ray">
            <summary>
            Ray struct, used to fire rays into a 3D scene to find out what we can
            hit with that ray (for mouse picking and other simple collision stuff)
            </summary>ZeroTolerance
        </member>
        <member name="F:Delta.Utilities.Datatypes.Ray.Position">
            <summary>
            Gets or sets the starting point of the ray
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Ray.Direction">
            <summary>
            Gets or sets the direction of the ray
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Ray.#ctor(Delta.Utilities.Datatypes.Vector,Delta.Utilities.Datatypes.Vector)">
            <summary>
            Create ray
            </summary>
            <param name="rayStart">Ray start</param>
            <param name="direction">Direction</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Ray.Equals(Delta.Utilities.Datatypes.Ray)">
            <summary>
            Check if another ray is equal to this ray.
            </summary>
            <param name="other">Other ray</param>
            <returns>
            True if the other ray has the same values as this ray.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Ray.Intersects(Delta.Utilities.Datatypes.Plane,Delta.Utilities.Datatypes.Vector@)">
            <summary>
            Intersects the current object with specified plane and returns true
            plus the intersectionPosition if the plane intersects this object.
            </summary>
            <param name="plane">The plane to check with</param>
            <param name="intersectionPosition">The intersection vector</param>
            <returns>True if the plane intersected with this object</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Ray.Intersects(Delta.Utilities.Datatypes.Ray,Delta.Utilities.Datatypes.Vector@)">
            <summary>
            Intersects the current object with specified ray and returns true
            plus the intersectionPosition if the ray hits this object.
            </summary>
            <param name="ray">The ray to check with</param>
            <param name="intersectionPosition">The intersection vector</param>
            <returns>True if the ray intersected with this object</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Ray.Intersects(Delta.Utilities.Datatypes.BoundingSphere)">
            <summary>
            Intersects the current object with the specified sphere.
            </summary>
            <param name="sphere">The sphere to check against</param>
            <returns>True if the sphere intersected with this object</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Ray.Intersects(Delta.Utilities.Datatypes.BoundingBox)">
            <summary>
            Intersects the current object with the specified box.
            </summary>
            <param name="box">The box to check against</param>
            <returns>True if the box intersected with this object</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Ray.Load(System.IO.BinaryReader)">
            <summary>
            Load the position and direction of this ray from a stream.
            </summary>
            <param name="reader">reader</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Ray.Save(System.IO.BinaryWriter)">
            <summary>
            Save the position and direction of this ray into a stream.
            </summary>
            <param name="writer">writer</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Ray.op_Equality(Delta.Utilities.Datatypes.Ray,Delta.Utilities.Datatypes.Ray)">
            <summary>
            Operator for equality
            </summary>
            <param name="value1">Ray 1</param>
            <param name="value2">Ray 2</param>
            <returns>True if both rays are the same</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Ray.op_Inequality(Delta.Utilities.Datatypes.Ray,Delta.Utilities.Datatypes.Ray)">
            <summary>
            Operator for inequality
            </summary>
            <param name="value1">Ray 1</param>
            <param name="value2">Ray 2</param>
            <returns>True if both rays are not the same</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Ray.Equals(System.Object)">
            <summary>
            Equals
            </summary>
            <param name="obj">Other ray</param>
            <returns>
            True if the other ray has the same values as this ray.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Ray.GetHashCode">
            <summary>
            Get hash code
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Ray.ToString">
            <summary>
            To string
            </summary>
            <returns>string</returns>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Ray.RayTests">
            <summary>
            Tests
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Ray.RayTests.TestProperties">
            <summary>
            Test properties
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Ray.RayTests.TestEquals">
            <summary>
            Test equals
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Ray.RayTests.TestToString">
            <summary>
            Test to string
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Ray.RayTests.TestIntersectPlane">
            <summary>
            Test for Ray.Intersects(Plane)
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Ray.RayTests.TestIntersectsBox">
            <summary>
            Test Ray.Intersects(Box)
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Ray.RayTests.TestIntersectSphere">
            <summary>
            Test Ray.Intersects(Sphere)
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Ray.RayTests.TestIntersectRay">
            <summary>
            Test Ray.Intersects(Ray)
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Advanced.DataContainer">
            <summary>
            This class allows to save and load primitive data which can be helpful
            for classes that uses the ISaveLoadBinary interface.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.DataContainer.VersionNumber">
            <summary>
            The current version of the implementation of this control class.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.DataContainer.ByteData">
            <summary>
            Byte data
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.DataContainer.BoolData">
            <summary>
            Boolean data
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.DataContainer.IntData">
            <summary>
            Int data
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.DataContainer.FloatData">
            <summary>
            Float data
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Advanced.DataContainer.StringData">
            <summary>
            String data
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.DataContainer.Load(System.IO.BinaryReader)">
            <summary>
            Loads all data of the object again which were previously saved.
            </summary>
            <param name="dataReader">The data of the object which were saved
            before.</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.DataContainer.Save(System.IO.BinaryWriter)">
            <summary>
            Saves all necessary data of the object to a byte array.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.DataContainer.Equals(System.Object)">
            <summary>
            Equals
            </summary>
            <param name="otherObject">Object</param>
            <returns>True if the otherObject is equal.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.DataContainer.GetHashCode">
            <summary>
            Get hash code for this data container (will just return base hashcode).
            </summary>
            <returns>hash code</returns>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Advanced.DataContainer.DataContainerTests">
            <summary>
            Tests
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Advanced.DataContainer.DataContainerTests.SaveAndLoad">
            <summary>
            Save and load
            </summary>
        </member>
        <member name="T:Delta.Utilities.Helpers.ThreadHelper">
            <summary>
            Simple thread helper class
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.ThreadHelper.Start(Delta.Utilities.Helpers.ThreadHelper.ThreadRunDelegate)">
            <summary>
            Start a thread with the given threadRunCode. Using the RunDelegate
            from Delta.Base because we have the Delta assembly in here anyway.
            Pretty much just creates a thread and starts it :)
            </summary>
            <param name="threadRunCode">Thread Run Code</param>
            <returns>Started thread with given run code</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ThreadHelper.Start(System.String,Delta.Utilities.Helpers.ThreadHelper.ThreadRunDelegate)">
            <summary>
            Start a thread with the given threadRunCode. Using the RunDelegate
            from Delta.Base because we have the Delta assembly in here anyway.
            Pretty much just creates a thread and starts it :)
            </summary>
            <param name="threadName">Thread Name</param>
            <param name="threadRunCode">Thread Run Code</param>
            <returns>Started thread with the given name and run code</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.ThreadHelper.Start(Delta.Utilities.Helpers.ThreadHelper.ThreadWithParameterDelegate,System.Object)">
            <summary>
            Start a thread with the given threadRunCode and a parameter used for
            threadRunCode for starting. Using the RunDelegate from Delta.Base
            because we have the Delta assembly in here anyway.
            Pretty much just creates a thread and starts it :)
            </summary>
            <param name="threadRunCode">Thread Run Code</param>
            <param name="param">Parameter to pass to the run code</param>
            <returns>Started thread with the given run code and parameter</returns>
        </member>
        <member name="T:Delta.Utilities.Helpers.ThreadHelper.ThreadRunDelegate">
            <summary>
            Run delegate with no parameters for the thread.
            </summary>
        </member>
        <member name="T:Delta.Utilities.Helpers.ThreadHelper.ThreadWithParameterDelegate">
            <summary>
            Helper delegate for ThreadHelper.Start with parameter.
            This way you can pass any parameter to the new thread easily.
            </summary>
            <param name="param">Parameter to pass into run code delegate</param>
        </member>
        <member name="T:Delta.Utilities.Helpers.ThreadHelper.ThreadHelperTests">
            <summary>
            Tests
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.ThreadHelper.ThreadHelperTests.Start">
            <summary>
            Start Thread. Note: Too slow for a dynamic unit test.
            </summary>
        </member>
        <member name="T:NUnit.Framework.TestAttribute">
            <summary>
            Nothing is in here, this is just a fake class to help tools to detect
            unit tests. Helper to simulate NUnit unit tests to be detected by test
            unit runners like ReSharper. TestDriven.NET however requires that a
            supported NUnit.Framework.dll is used, which is too much hassle for us,
            but you can easily do it if you like.
            </summary>
        </member>
        <member name="P:NUnit.Framework.TestAttribute.Description">
            <summary>
            Optional description for this test, rarely used.
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Color">
            <summary>
            Color datatype, originally contained 4 floats for all the color
            components. Now we still got those, but as properties because the
            internal format is a packed uint RGBA value (4 bytes instead of 16):
            R for red, G for green, B for blue and A for alpha, all between 0 and 1.
            </summary>
            <remarks> 
            The change to uint (and thanks to unions to the 4 byte values RedByte,
            GreenByte, BlueByte, and AlphaByte) was done to increase rendering
            performance. Especially on mobile platforms bandwidth is key and
            reducing the amount of data send to the vertex and fragment shaders
            can speed up rendering a lot (e.g. 36 bytes per vertex lead to max. 33
            fps on the iPad, while 16 bytes (2 floats for position, 2 ushorts for UV
            and 4 bytes for color) is almost 3 times faster!
            Here can find a lot of "color codes": System.Drawing.Color
            Use Reflector or the MSDN documentation to learn more.
            http://www.htmlhelp.com/cgi-bin/color.cgi
            http://www.pamramsey.com/colors.htm
            </remarks>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.DataSize">
            <summary>
            Represents the size in bytes of that R,G,B,A Color (just 4 bytes).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.Unused">
            <summary>
            Unused color, all values including alpha are set to 0. Usually used to
            indicate that a color is unused, e.g. if Graphic.Instances.ClearColor is
            set to Unused, we won't clear the backbuffer with the ClearColor
            (which is a bit faster for games that do not need to have the
            backbuffer cleared). Note that we usually have premultiplied alpha
            so it is faster to check if Alpha == 0 to see if a color is unused!
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.Black">
            <summary>
            Black color (0, 0, 0), but has alpha (1), use Unused for (0, 0, 0, 0)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.Grey">
            <summary>
            Grey color (0.5, 0.5, 0.5) = (127, 127, 127)
            http://en.wikipedia.org/wiki/Grey
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.White">
            <summary>
            White color (1, 1, 1)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.WhiteHalfAlpha">
            <summary>
            White color (1, 1, 1) but with an alpha value of 0.5
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.Red">
            <summary>
            Red color (1, 0, 0)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.Green">
            <summary>
            Green color (0, 1, 0)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.Blue">
            <summary>
            Blue color (0, 0, 1)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.Yellow">
            <summary>
            Yellow color (1, 1, 0)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.CornflowerBlue">
            <summary>
            CornflowerBlue color (0.39, 0.58, 0.93)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.DarkBlue">
            <summary>
            Dark blue color (0.19, 0.28, 0.43)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.Purple">
            <summary>
            Purple color (0.5, 0, 0.5)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.Cyan">
            <summary>
            Cyan color (0.0, 1.0, 1.0)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.Teal">
            <summary>
            Teal color (0, 0.5, 0.5)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.Orange">
            <summary>
            Orange color (1, 0.65, 0)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.Brown">
            <summary>
            Brown color (0.65, 0.16, 0.16)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.Gold">
            <summary>
            Gold color (1.0, 0.84, 0.0)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.LightGrey">
            <summary>
            Light grey color (0.65, 0.65, 0.65) = (165, 165, 165)
            http://en.wikipedia.org/wiki/Grey
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.LightRed">
            <summary>
            LightRed color (1, 0.25, 0.25)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.LightGreen">
            <summary>
            LightGreen color (0.25, 1, 0.25)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.LightPurple">
            <summary>
            LightPurple color (0.576, 0.44, 0.86)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.LightBlue">
            <summary>
            LightBlue color (0.65f, 0.795f, 1.0f)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.LightTeal">
            <summary>
            LightTeal color (0.25, 0.8, 0.8)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.LightOrange">
            <summary>
            LightOrange color (1, 0.8, 0.25)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.DarkGrey">
            <summary>
            Dark grey color (0.35, 0.35, 0.35) = (89, 89, 89)
            http://en.wikipedia.org/wiki/Grey
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.FromString(System.String)">
            <summary>
            Convert a string to a Color. The expected format is
            (r.r, g.g, b.b, a.a), e.g. (0.2, 0.3, 0.4, 1.0). Alpha is optional.
            </summary>
            <param name="colorString">String containing the color values</param>
            <returns>
            Color from the colorString or White if no valid string was used.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.Lerp(Delta.Utilities.Datatypes.Color,Delta.Utilities.Datatypes.Color,System.Single)">
            <summary>
            Lerp (interpolate) between to colors based on the given amount between
            0.0 and 1.0. If the amount value is closer to 0, the output color will
            be more like c1, otherwise it will be closer to c2.
            </summary>
            <param name="c1">Color 1</param>
            <param name="c2">Color 2</param>
            <param name="amount">Amount for interpolation</param>
            <returns>Color in between c1 and c2</returns>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.SolidColors">
            <summary>
            List of 15 predefined solid colors, which look better than random
            colors if used for profiling or effects (Red, Blue,
            Green, Yellow, Purple, Teal, Orange, White, Brown, Gray,
            CornflowerBlue, Gold, LightGreen, LightRed, LightPurple).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.LightColors">
            <summary>
            List of 15 predefined solid colors, which look better than random
            colors if used for profiling or effects (Red, Blue,
            Green, Yellow, Purple, Teal, Orange, White, Brown, Gray,
            CornflowerBlue, Gold, LightGreen, LightRed, LightPurple).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.PackedRGBA">
            <summary>
            This color as 4 packed bytes in an uint value. This is the same format
            used for OpenGL colors, xna colors and RGBA values in general :)
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.RedByte">
            <summary>
            Red byte in a range of [0,255]. Use the property R for a float [0,1].
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.GreenByte">
            <summary>
            Green byte in a range of [0,255]. Use the property G for a float [0,1].
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.BlueByte">
            <summary>
            Blue byte in a range of [0,255]. Use the property B for a float [0,1].
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.AlphaByte">
            <summary>
            Alpha channel byte in a range of [0,255]. Use the property B for a
            float [0,1]. 0=transparent, 255 (or A=1)=fully visible. Note: Like
            xna 4.0 we use premultiplied alpha by default, which makes
            multiplying colors a little easier (just newAlpha*Color).
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.SolidColorNumber">
            <summary>
            Current index for NextSolidColor, will increase each call.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Color.LightColorNumber">
            <summary>
            Current index for NextLightColor, will increase each call.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.#ctor(Delta.Utilities.Datatypes.Color,System.Single)">
            <summary>
            Creates a color with an alpha of 1.0
            </summary>
            <param name="setBaseColor">Sets the "base color" RGB</param>
            <param name="setA">Set alpha channel in a range of [0,1]</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Creates a color with an alpha of 1.0
            </summary>
            <param name="setR">Set red channel in a range of [0,1]</param>
            <param name="setG">Set green channel in a range of [0,1]</param>
            <param name="setB">Set blue channel in a range of [0,1]</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Creates a color with values for R, G, B, A.
            </summary>
            <param name="setR">Set red channel in a range of [0,1]</param>
            <param name="setG">Set green channel in a range of [0,1]</param>
            <param name="setB">Set blue channel in a range of [0,1]</param>
            <param name="setA">Set alpha channel in a range of [0,1]</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.#ctor(System.Byte,System.Byte,System.Byte)">
            <summary>
            Creates a color from the byte RGB values in the range [0-255] for each
            channel.
            </summary>
            <param name="setR">The red value in the range [0-255].</param>
            <param name="setG">The green value in the range [0-255].</param>
            <param name="setB">The blue value in the range [0-255].</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.#ctor(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Creates a color from the byte RGBA values in the range [0-255] for each
            channel.
            </summary>
            <param name="setR">The red value in the range [0-255].</param>
            <param name="setG">The green value in the range [0-255].</param>
            <param name="setB">The blue value in the range [0-255].</param>
            <param name="setA">The alpha value in the range [0-255].</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.#ctor(System.IO.BinaryReader)">
            <summary>
            Create color from binary data stream (e.g. to load vertices or
            material data).
            </summary>
            <param name="setReader">setReader</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.Equals(Delta.Utilities.Datatypes.Color)">
            <summary>
            Equals
            </summary>
            <param name="other">Other</param>
            <returns>Value indicating the equality of two colors</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.Load(System.IO.BinaryReader)">
            <summary>
            Load the color values from a stream (4 bytes).
            </summary>
            <param name="reader">The stream that will be used.</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.Save(System.IO.BinaryWriter)">
            <summary>
            Saves the color out to a stream (4 bytes).
            </summary>
            <param name="writer">The stream that will be used.</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.op_Multiply(Delta.Utilities.Datatypes.Color,System.Single)">
            <summary>
            Multiply operator to multiply all color values with a number.
            </summary>
            <param name="c1">Color to multiply</param>
            <param name="brightScale">Bright scale</param>
            <returns>Color</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.op_Multiply(Delta.Utilities.Datatypes.Color,Delta.Utilities.Datatypes.Color)">
            <summary>
            Multiply operator to multiply two colors (each value will be multiplied)
            </summary>
            <param name="c1">Color 1</param>
            <param name="c2">Color 2</param>
            <returns>Color</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.op_Equality(Delta.Utilities.Datatypes.Color,Delta.Utilities.Datatypes.Color)">
            <summary>
            Check for equality
            </summary>
            <param name="value1">Value 1</param>
            <param name="value2">Value 2</param>
            <returns>True if the values are equal, false otherwise</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.op_Inequality(Delta.Utilities.Datatypes.Color,Delta.Utilities.Datatypes.Color)">
            <summary>
            Check for inequality
            </summary>
            <param name="value1">Value 1</param>
            <param name="value2">Value 2</param>
            <returns>True if the values are not equal</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.GetHashCode">
            <summary>
            Get hash code
            </summary>
            <returns>hash code</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.Equals(System.Object)">
            <summary>
            Equals
            </summary>
            <param name="obj">Object to compare to</param>
            <returns>True if the values are equal, false otherwise</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.ToString">
            <summary>
            To string
            </summary>
            <returns>string</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.ToString(System.String,System.String)">
            <summary>
            To string
            </summary>
            <param name="closeBrace">closeBrace</param>
            <param name="openBrace">openBrace</param>
            <returns>string</returns>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Color.Random">
            <summary>
            Returns a random color (0-1, 0-1, 0-1)
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Color.NextSolidColor">
            <summary>
            Returns the next solid color from a predefined array (Red, Blue,
            Green, Yellow, Purple, Teal, Orange, White, Brown, Gray,
            CornflowerBlue, Gold, LightGreen, LightRed, LightPurple).
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Color.NextLightColor">
            <summary>
            Returns the next light color from a predefined array (White,
            LightRed, CornflowerBlue, LightBlue, LightGreen, LightOrange).
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Color.R">
            <summary>
            Red channel (in a range of [0,1], caller has to make sure not to set
            this to any crazy value). Set to the RedByte value of this color.
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Color.G">
            <summary>
            Green channel (in a range of [0,1]). Set to the GreenByte value of
            this color.
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Color.B">
            <summary>
            Blue channel (in a range of [0,1]). Set to the BlueByte value of this
            color.
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Color.A">
            <summary>
            Alpha channel (in a range of [0,1]). 0=transparent, 1=fully visible.
            Note: Like XNA 4.0 we use premultiplied alpha by default, which makes
            multiplying colors a little easier (just newAlpha*Color). Set to the
            AlphaByte value of this color.
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Color.ColorTests">
            <summary>
            Tests
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.ColorTests.Constructor">
            <summary>
            FromIntRGB
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.ColorTests.SizeOf">
            <summary>
            Checks if the size of Point is exactly 8 bytes (2 floats: X and Y)
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.ColorTests.ColorCompare">
            <summary>
            Color compare
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.ColorTests.SaveAndLoad">
            <summary>
            Save
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.ColorTests.Multiplication">
            <summary>
            Multiplication
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.ColorTests.FromString">
            <summary>
            FromString
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Color.ColorTests.Equality">
            <summary>
            Equality
            </summary>
        </member>
        <member name="T:Delta.Utilities.Assert">
            <summary>
            Assert helper class for testing and debugging. Provides static methods
            that help you figuring out if values are equal, not equal, less, greater,
            true, false, etc. This way xUnit, NUnit, etc. is not required and we can
            make sure all unit tests can be executed on all supported platforms.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Assert.Equals(System.Object,System.Object)">
            <summary>
            Equals, just trying to hide it. The Equals() method is not officially
            supported for 'Assert', please use the 'Equal()' method instead.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Assert.ReferenceEquals(System.Object,System.Object)">
            <summary>
            Hide method. The 'ReferenceEquals()' method is not officially
            supported for 'Assert', please use the 'Equal()' method instead.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Assert.Equal``1(``0,``0)">
            <summary>
            Are two values equal? All they need is some comparer (see IsEqual).
            Throws an AssertException if the values are not equal. Note: Other
            unit test frameworks use expected and actual values for the parameters
            here, but we don't care about the order, usually it is programmed in
            a natural way so you just say Assert.Equal(Numbers.Add(10, 7), 17),
            but you can also do it the xUnit/NUnit way: Assert.Equal(17,
            Numbers.Add(10, 7).
            </summary>
            <typeparam name="T">Type to compare</typeparam>
            <param name="firstValue">First value</param>
            <param name="secondValue">Second value</param>
            <exception cref="T:Delta.Utilities.Assert.AssertException">Exception is thrown if two values 
            are not equal</exception>
        </member>
        <member name="M:Delta.Utilities.Assert.NotEqual``1(``0,``0)">
            <summary>
            These values should not be equal, if they are an exception is thrown.
            </summary>
            <param name="firstValue">Expected value</param>
            <param name="secondValue">Actual value</param>
        </member>
        <member name="M:Delta.Utilities.Assert.NearlyEqual(System.Single,System.Single,System.Single)">
            <summary>
            Nearly equal check, pretty much the same as the Equal check above,
            but it only allows floats and it will still return true if
            expectedValue and actualValue are less than given max. difference.
            </summary>
            <param name="firstValue">First parameter to compare</param>
            <param name="secondValue">Second parameter to compare</param>
            <param name="maxDifference">
            Maximum difference allowed, MathHelper.Epsilon by default.
            </param>
        </member>
        <member name="M:Delta.Utilities.Assert.Between(System.Single,System.Single,System.Single)">
            <summary>
            Checks if valueToCheck is in between lowerLimit and upperLimit,
            lowerLimit must be smaller than upperLimit!
            </summary>
            <param name="valueToCheck">Value we want to check that should be
            between lowerLimit and upperLimit (both exclusive)</param>
            <param name="lowerLimit">Lower limit value</param>
            <param name="upperLimit">Upper limit value</param>
        </member>
        <member name="M:Delta.Utilities.Assert.Contains``1(``0,``0)">
            <summary>
            Simple string contains check that allows strings to be case-insensitive.
            Will throw an AssertException if expectedInString is not found in
            fullString. Note: Currently only supports strings, but this way
            we save one intellisense space (else we have 2 Contains methods).
            </summary>
            <typeparam name="T">Type to compare</typeparam>
            <param name="expectedInString">String value we search for</param>
            <param name="fullString">The string where expectedInString should be
            contained somewhere</param>
        </member>
        <member name="M:Delta.Utilities.Assert.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Contains check for any IEnumerable (array, list, etc.). Will fail
            with an AssertException if the expectedValue is not in someArray.
            </summary>
            <typeparam name="T">Type to compare</typeparam>
            <param name="someArray">Some Array</param>
            <param name="expectedValue">Expected Value</param>
        </member>
        <member name="M:Delta.Utilities.Assert.Throws(System.Type,Delta.Utilities.Assert.ThrowsDelegate)">
            <summary>
            Expects the testCode to throw an exception of exceptionType and catches
            it (no exception is thrown to the caller), if it does not throw the
            specified exceptionType, an AssertException is thrown.
            </summary>
            <param name="exceptionType">Exception Type</param>
            <param name="testCode">Test Code</param>
            <exception cref="T:Delta.Utilities.Assert.AssertException">
            This is thrown if the code does not throw the expected exception.
            </exception>
        </member>
        <member name="M:Delta.Utilities.Assert.True(System.Boolean)">
            <summary>
            Simple check if a condition is true. Since we do not know why this
            failed (if it is not true), you can optionally supply a why string!
            </summary>
            <param name="expectedTrueValue">
            Expected value that should be true
            </param>
            <exception cref="T:Delta.Utilities.Assert.AssertException">
            If the value was not 'true' as expected!
            </exception>
        </member>
        <member name="M:Delta.Utilities.Assert.True(System.Boolean,System.String)">
            <summary>
            Simple check if a condition is true. Since we do not know why this
            failed (if it is not true), you can optionally supply a why string!
            </summary>
            <param name="expectedTrueValue">
            Expected value that should be true.
            </param>
            <param name="why">
            Extra string to explain why this is wrong
            </param>
            <exception cref="T:Delta.Utilities.Assert.AssertException">
            If the value was not 'true' as expected!
            </exception>
        </member>
        <member name="M:Delta.Utilities.Assert.False(System.Boolean)">
            <summary>
            Simple check if a condition is false. Since we do not know why this
            failed (if it is not false), you can optionally supply a why string!
            </summary>
            <param name="expectedFalseValue">
            Expected value that should be false.
            </param>
            <exception cref="T:Delta.Utilities.Assert.AssertException">
            If the value was not 'false' as expected!
            </exception>
        </member>
        <member name="M:Delta.Utilities.Assert.False(System.Boolean,System.String)">
            <summary>
            Simple check if a condition is false. Since we do not know why this
            failed (if it is not false), you can optionally supply a why string!
            </summary>
            <param name="expectedFalseValue">
            Expected value that should be false.
            </param>
            <param name="why">
            Why did this happen? Optional extra information text that will be added
             when the expectedFalseValue is not false.
            </param>
            <exception cref="T:Delta.Utilities.Assert.AssertException">
            If the value was not 'false' as expected!
            </exception>
        </member>
        <member name="M:Delta.Utilities.Assert.Null(System.Object)">
            <summary>
            Simple check if a value is null.
            </summary>
            <param name="expectedNullValue">
            Expected value that should be null.
            </param>
            <exception cref="T:Delta.Utilities.Assert.AssertException">
            If the value was not 'null' as expected!
            </exception>
        </member>
        <member name="M:Delta.Utilities.Assert.NotNull(System.Object)">
            <summary>
            Simple check if a condition is false. Since we do not know why this
            failed (if it is not false), you must supply a why string!
            </summary>
            <param name="expectedValue">
            Expected value that should not be null
            </param>
            <exception cref="T:Delta.Utilities.Assert.AssertException">
            If the value was 'null', but we expected a not 'null' value!
            </exception>
        </member>
        <member name="M:Delta.Utilities.Assert.IsEqual``1(``0,``0)">
            <summary>
            Helper method to figure out if two values are equal.
            Value types can easily be compared via Equals, reference types have to
            be from the same type and then we try to compare them IComparable, then
            IEquatable and finally checking if enumerating works. If all fails we
            still can fallback to the Equals method (same as for value types), but
            this usually fails if two references are not exactly the same pointer.
            </summary>
            <exception cref="T:Delta.Utilities.Assert.AssertException">
            Exception if the two types are not equal (can be different types,
             different values, different lists lengths, etc.)
            </exception>
        </member>
        <member name="T:Delta.Utilities.Assert.AssertException">
            <summary>
            Assert exception, this is just a very simple exception. Can be derived
            and used for other exceptions too (sometimes used for testing too).
            </summary>
        </member>
        <member name="M:Delta.Utilities.Assert.AssertException.#ctor(System.String)">
            <summary>
            Create assert exception with just an assert message.
            We use mostly just this constructor to display the message string.
            </summary>
            <param name="setMessage">Message describing the problem</param>
        </member>
        <member name="M:Delta.Utilities.Assert.AssertException.#ctor(System.String,System.Exception)">
            <summary>
            Create assert exception with both an assert message and an inner
            exception. Usually used when something very bad happened and we even
            need to display the inner exception.
            </summary>
            <param name="setMessage">Message describing the problem</param>
            <param name="setInnerException">Inner exception</param>
        </member>
        <member name="M:Delta.Utilities.Assert.AssertException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the System.Exception class with
            serialized data. This is required e.g. for serializing an exception
            from another worker domain.
            </summary>
            <remarks>
            This constructor will be called after the public constructor.
            </remarks>
            <param name="info">
            Serialization info to pass to the base Exception.
            </param>
            <param name="context">Context for the base Exception</param>
        </member>
        <member name="P:Delta.Utilities.Assert.AssertException.LineNumber">
            <summary>
            The number of the code line where this exception has happened.
            </summary>
        </member>
        <member name="T:Delta.Utilities.Assert.ThrowsDelegate">
            <summary>
            Helper delegate for the Throws method below to test if code throws
            a specific exception. Same delegate as Base.RunDelegate, but we have
            no access to that one here.
            </summary>
        </member>
        <member name="T:Delta.Utilities.Assert.AssertTests">
            <summary>
            Tests, which can be tested with Delta.Tools.TestRunner.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Assert.AssertTests.Contains">
            <summary>
            Contains. Note: Too slow for a dynamic unit test.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Assert.AssertTests.Throws">
            <summary>
            Throws. Note: Too slow for a dynamic unit test.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Assert.AssertTests.NearlyEqual">
            <summary>
            Nearly equal
            </summary>
        </member>
        <member name="M:Delta.Utilities.Assert.AssertTests.Between">
            <summary>
            Between
            </summary>
        </member>
        <member name="M:Delta.Utilities.Assert.AssertTests.Equal">
            <summary>
            Is equal
            </summary>
        </member>
        <member name="M:Delta.Utilities.Assert.AssertTests.False">
            <summary>
            False
            </summary>
        </member>
        <member name="M:Delta.Utilities.Assert.AssertTests.NotEqual">
            <summary>
            Not equal
            </summary>
        </member>
        <member name="M:Delta.Utilities.Assert.AssertTests.NotNull">
            <summary>
            NotNull
            </summary>
        </member>
        <member name="M:Delta.Utilities.Assert.AssertTests.Null">
            <summary>
            Null
            </summary>
        </member>
        <member name="M:Delta.Utilities.Assert.AssertTests.True">
            <summary>
            True
            </summary>
        </member>
        <member name="T:Delta.Utilities.Helpers.RandomHelper">
            <summary>
            Random helper, which mostly provides methods to quickly generate random
            values for ints, floats, bytes, Vectors, Colors, etc. and some methods
            for more complex cases (strings, ids, random values with factors, etc.)
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.RandomHelper.GetNewRandomGenerator">
            <summary>
            Get new random generator with help of
            Win32Function.GetPerformanceCounter.
            </summary>
            <returns>Random</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.RandomHelper.RandomInt(System.Int32)">
            <summary>
            Gets a random int between '0' and the given (exclusive) maximum.
            </summary>
            <param name="max">The max. (exclusive) Limit</param>
            <returns>Int</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.RandomHelper.RandomInt(System.Int32,System.Int32)">
            <summary>
            Gets a random int between the given minimum and (exclusive) maximum.
            </summary>
            <param name="min">Min</param>
            <param name="max">Max</param>
            <returns>Random int</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.RandomHelper.RandomFloat(System.Random,System.Single,System.Single)">
            <summary>
            Get random float between min and max (exclusive max)
            </summary>
            <param name="rnd">Rnd</param>
            <param name="min">Min</param>
            <param name="max">Max</param>
            <returns>Float</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.RandomHelper.RandomFloat(System.Single,System.Single)">
            <summary>
            Get random float between min and max (exclusive max)
            </summary>
            <param name="min">Minimum</param>
            <param name="max">Maximum</param>
            <returns>Float</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.RandomHelper.RandomByte(System.Random,System.Byte,System.Byte)">
            <summary>
            Get random byte between min and max (exclusive max)
            </summary>
            <param name="rnd">Rnd</param>
            <param name="min">Min</param>
            <param name="max">Max</param>
            <returns>Byte</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.RandomHelper.RandomVector(System.Single,System.Single)">
            <summary>
            Get random vector between min and max for all components.
            </summary>
            <param name="min">Minimum</param>
            <param name="max">Maximum</param>
            <returns>Vector</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.RandomHelper.RandomVector(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Get random vector between min and max for each component separated.
            </summary>
            <param name="minX">Minimum X</param>
            <param name="maxX">Maximum X</param>
            <param name="minY">Minimum Y</param>
            <param name="maxY">Maximum Y</param>
            <param name="minZ">Minimum Z</param>
            <param name="maxZ">Maximum Z</param>
            <returns>Vector</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.RandomHelper.CreateRandomBytes(System.Int32)">
            <summary>
            Creates random byte array with given length. Used to generate private
            keys and crypto IV values.
            </summary>
            <param name="length">Length of the byte array we return</param>
            <returns>Byte array with random byte data</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.RandomHelper.CreateRandomString(System.Int32)">
            <summary>
            Create random string, helper for GetFreeUnusedSerial()
            and RequestActivationKey(), use SerialLength or
            ActivationKeyLength as lengths!
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.RandomHelper.CreateRandomStringNoNumbers(System.Int32)">
            <summary>
            Create random string, helper for GetFreeUnusedSerial()
            and RequestActivationKey(), use SerialLength or
            ActivationKeyLength as lengths!
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.RandomHelper.RandomizeIds(System.Collections.Generic.List{System.Int32})">
            <summary>
            Randomize ids
            </summary>
            <param name="inputIds">Input ids</param>
            <returns>List</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.RandomHelper.RandomizeIds(System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary>
            Randomize ids
            </summary>
            <param name="inputIds">Input ids</param>
            <param name="maxCount">Maximum count</param>
            <returns>List</returns>
        </member>
        <member name="M:Delta.Utilities.Helpers.RandomHelper.GetRandomValueWithFactors(System.Collections.Generic.List{System.Int32})">
            <summary>
            Very nice function to calc random value with help of
            factors, e.g. when calling with { 0.1f, 0.1f, 2.0f }
            we will most likly (in >99% of all cases) get 2 as
            result and not 0 or 1!
            </summary>
        </member>
        <member name="M:Delta.Utilities.Helpers.RandomHelper.RandomizeList``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Randomize list
            </summary>
            <param name="list">List</param>
            <param name="maxCount">Maximum count</param>
            <returns>List</returns>
        </member>
        <member name="F:Delta.Utilities.Helpers.RandomHelper.lastUsedRandomGenerator">
            <summary>
            Last used random generator
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Size">
            <summary>
            Size struct, has just Width and Height as floats and is used to manage
            sizes, most importantly for our quadratic screen space and the
            Rectangle struct.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Size.Zero">
            <summary>
            Zero size, both Width and Height are 0.
            </summary>
            <returns>Size</returns>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Size.One">
            <summary>
            One size, has both Width and Height set to 1.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Size.Half">
            <summary>
            Half size, has both Width and Height set to 0.5.
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Size.Quarter">
            <summary>
            Quarter size, has both Width and Height set to 0.25.
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.Max(Delta.Utilities.Datatypes.Size,Delta.Utilities.Datatypes.Size)">
            <summary>
            Returns the max. dimesions based on both values.
            e.g. Max((2,5) (4,4)) -> (4,5)
            </summary>
            <param name="value1">value1</param>
            <param name="value2">value2</param>
            <returns>the max. dimesions based on both values</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.FromString(System.String)">
            <summary>
            Convert a string to a Size, works the same way as for Point.FromString
            </summary>
            <param name="pointString">The string in the correct format
            (with or without brackets, comma or space seperated).</param>
            <returns>
            Size from the given string or Zero if parsing failed.
            </returns>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Size.Width">
            <summary>
            Width
            </summary>
        </member>
        <member name="F:Delta.Utilities.Datatypes.Size.Height">
            <summary>
            Height
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.#ctor(System.Single)">
            <summary>
            Create size
            </summary>
            <param name="setDimension">setDimension</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.#ctor(System.Single,System.Single)">
            <summary>
            Create size
            </summary>
            <param name="setHeight">setHeight</param>
            <param name="setWidth">setWidht</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.#ctor(System.IO.BinaryReader)">
            <summary>
            Create size
            </summary>
            <param name="dataReader">Data reader</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.Equals(Delta.Utilities.Datatypes.Size)">
            <summary>
            Check if another size has almost the same values (using
            MathHelper.Epsilon).
            </summary>
            <param name="other">Other size to compare to</param>
            <returns>True if the other size has nearly the same values</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.Load(System.IO.BinaryReader)">
            <summary>
            Load size from binary stream (8 bytes, 2 floats)
            </summary>
            <param name="reader">reader</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.Save(System.IO.BinaryWriter)">
            <summary>
            Save size to binary stream (8 bytes, 2 floats)
            </summary>
            <param name="writer">writer</param>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.op_Equality(Delta.Utilities.Datatypes.Size,Delta.Utilities.Datatypes.Size)">
            <summary>
            Operator for equality
            </summary>
            <param name="value1">Size 1</param>
            <param name="value2">Size 2</param>
            <returns>True if both sizes are the same</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.op_Inequality(Delta.Utilities.Datatypes.Size,Delta.Utilities.Datatypes.Size)">
            <summary>
            Operator for inequality
            </summary>
            <param name="value1">Size 1</param>
            <param name="value2">Size 2</param>
            <returns>True if both sizes are not the same</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.op_Addition(Delta.Utilities.Datatypes.Size,Delta.Utilities.Datatypes.Size)">
            <summary>
            Operator for addition
            </summary>
            <param name="value1">Size 1</param>
            <param name="value2">Size 2</param>
            <returns>Added size from both sizes</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.op_Subtraction(Delta.Utilities.Datatypes.Size,Delta.Utilities.Datatypes.Size)">
            <summary>
            Operator for subtraction
            </summary>
            <param name="value1">Size 1</param>
            <param name="value2">Size 2</param>
            <returns>Subtracted size from both sizes</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.op_Multiply(Delta.Utilities.Datatypes.Size,Delta.Utilities.Datatypes.Size)">
            <summary>
            Operator for multiplication points
            </summary>
            <param name="value1">Size 1</param>
            <param name="value2">Size 2</param>
            <returns>
            Size with both Width multiplied and both Heights multiplied.
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.op_Multiply(Delta.Utilities.Datatypes.Size,System.Single)">
            <summary>
            Operator for multiplying a Size with a scale factor. 
            </summary>
            <param name="value">Size value</param>
            <param name="scaleFactor">Scale Factor</param>
            <returns>
            Size with both Width and Height multiplied by scaleFactor
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.op_Multiply(System.Single,Delta.Utilities.Datatypes.Size)">
            <summary>
            Operator for multiplying a Size with a scale factor. 
            </summary>
            <param name="scaleFactor">Scale Factor</param>
            <param name="value">Size value</param>
            <returns>
            Size with both Width and Height multiplied by scaleFactor
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.op_Division(Delta.Utilities.Datatypes.Size,System.Single)">
            <summary>
            Operator to divide a Size with a float.
            </summary>
            <param name="value">Value</param>
            <param name="divisor">Divisor</param>
            <returns>value.Width / divisor, value.Height / divisor</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.op_Division(System.Single,Delta.Utilities.Datatypes.Size)">
            <summary>
            Operator to divide a float with a Size.
            </summary>
            <param name="divisor">Divisor</param>
            <param name="value">Value</param>
            <returns>value / divisor.Width, value / divisor.Height</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.op_Division(Delta.Utilities.Datatypes.Size,Delta.Utilities.Datatypes.Size)">
            <summary>
            Operator to divide a Size with another Size.
            </summary>
            <param name="divisor">Divisor</param>
            <param name="value">Value</param>
            <returns>value.Width / divisor.Width, value.Height / divisor.Height
            </returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.op_Explicit(Delta.Utilities.Datatypes.Point)~Delta.Utilities.Datatypes.Size">
            <summary>
            Operator to implicit convert Point to Size.
            </summary>
            <param name="anyPoint">Any point value</param>
            <returns>Point converted to size</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.Equals(System.Object)">
            <summary>
            Check in another object is a Size and equal to this size.
            </summary>
            <param name="obj">Object to compare to</param>
            <returns>True if both sizes are the same</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.GetHashCode">
            <summary>
            Get hash code
            </summary>
            <returns>Hash code from Width and Height</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.Round">
            <summary>
            Round the width and height values to the nearest integer value.
            </summary>
            <returns>Size with rounded width and height values.</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.ToString">
            <summary>
            To string
            </summary>
            <returns>string</returns>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.ToCommaString">
            <summary>
            Returns the vector as a string that can be used in a Setting files,
            which is just using the x, y format (and works fine with FromString).
            </summary>
            <returns>vector</returns>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Size.WidthProperty">
            <summary>
            Property-wrapper for using the X field in the editor.
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Size.HeightProperty">
            <summary>
            Property-wrapper for using the Y field in the editor
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Size.WidthHalf">
            <summary>
            The half width of the size.
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Size.HeightHalf">
            <summary>
            The half height of the size.
            </summary>
        </member>
        <member name="P:Delta.Utilities.Datatypes.Size.IsZero">
            <summary>
            Returns "true" if the size hasn't any width AND height.
            </summary>
        </member>
        <member name="T:Delta.Utilities.Datatypes.Size.SizeTests">
            <summary>
            Tests
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.SizeTests.SizeOf">
            <summary>
            Checks if the size of Point is exactly 8 bytes (2 floats: X and Y)
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.SizeTests.SizeTest">
            <summary>
            Size test
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.SizeTests.Equality">
            <summary>
            Equality
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.SizeTests.Addition">
            <summary>
            Addition
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.SizeTests.Substraction">
            <summary>
            Substraction
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.SizeTests.Multiplication">
            <summary>
            Multiplication
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.SizeTests.NearlyEquals">
            <summary>
            Nearly equals
            </summary>
        </member>
        <member name="M:Delta.Utilities.Datatypes.Size.SizeTests.ToString">
            <summary>
            To string
            </summary>
        </member>
    </members>
</doc>
