<?xml version="1.0" encoding="utf-8"?>
<doc>
  <assembly>
    <name>Delta.ContentSystem</name>
  </assembly>
  <members>
    <member name="T:Delta.ContentSystem.Xml.XmlData">
      <summary>
            XML content class, which is both a basic implementation that is useful
            for testing for the whole content system and also an important class for
            for the Localization system (which is based on the Localization.xml
            file), which is also located in this assembly.
            <para />
            Note: This class is not publicly available, but you can re-implement it
            quickly, all it does is: <c>XmlNode.LoadFile(RelativeFilePath)</c></summary>
    </member>
    <member name="T:Delta.ContentSystem.Content">
      <summary>
            Content base class to keep content free from platform and framework
            types we need in specific modules. For example new Image(name) loads a
            texture, but on the native implementation it could be an XNA Texture2D,
            an OpenTK texture id or a SlimDX texture object, we just don't know!
            We also have many other great advantages through the ContentManager like
            automatic content reloading and language specific content with automatic
            updates if the language changes. Most properties and details are
            in the ContentMetaData class and all the heavy lifting is done by the
            Content System Server, which we can talk through the content client.
            <para />
            See http://DeltaEngine.net/Wiki.ContentSystem for details.
            <para />
            Note: Each Content class can also implement the ISaveLoadBinary
            interface, which is then used to both save and load data. Saving is not
            really needed for games as all content is generated by the content
            system on the server, but thanks to this interface we can easily support
            saving content data in the same way there too (e.g. for effects, scenes,
            materials, etc., but not for textures or sound files).
            <para />
            Please note that even while the Load method is called right away the
            constructor when creating a new content instance via the static Get,
            it does not mean that the native data is loaded right away. Usually it
            is, but for content that needs some time to be initialized like
            textures or sounds, the derived content classes can decide to load
            their native data delayed when it is actually needed (for rendering
            or when first playing it). This has two advantages and a disadvantage.
            First of all it saves a lot of memory and initial loading time, which
            will make your game startup almost instantly. However since content
            is loaded later you might not be so happy about it when the game is
            stuttering while playing until you have all content that you need.
            The solution to this is to use scenes, which solves many things in the
            Content System. Once a scene is opened, all content is pre-loaded the
            first time the scene is getting updated (via Run). This way all the
            content that you create when opening your scene both in the SceneEditor
            and in code (loading levels, textures, music, sounds, etc.) is loaded
            right away, but you still have the option to load more stuff later.
            </summary>
    </member>
    <member name="F:Delta.ContentSystem.Content.EmptyName">
      <summary>
            If the default (fallback) is needed directly, then just use this
            identifier as content name. Please note that null or strings starting
            with &gt; will also be considered as un-loadable content and just a
            dummy ContentData object is returned (and LoadFallbackData is used).
            This is also used for generated content (e.g. meshes, materials or
            scenes that are created during runtime). Please note that these
            generated content classes have always DefaultId (empty string) or
            start with &gt; (plus some name like "&gt;GeneratedMeshBox&lt;"), this
            is how you know if content was loaded or generated.
            </summary>
    </member>
    <member name="M:Delta.ContentSystem.Content.Exists(System.String,Delta.ContentSystem.ContentType)">
      <summary>
            Check if a specific content with given name and type exists. The
            content entry is not loaded and we do not care about languages here.
            </summary>
      <param name="contentName">Name to search for, will only search for
            content in our current language in the flatData dictionary</param>
      <param name="contentType">Type to search for in the flatData dictionary
            </param>
      <returns>
            True if we have such a content meta data, false otherwise (not found)
            </returns>
    </member>
    <member name="M:Delta.ContentSystem.Content.Equals(System.Object,System.Object)">
      <summary>
            Equals, just trying to hide it from intellisense.
            </summary>
      <param name="objA">The first System.Object to compare.</param>
      <param name="objB">The second System.Object to compare.</param>
      <returns>true if objA is the same instance as objB; otherwise, false.
            </returns>
    </member>
    <member name="M:Delta.ContentSystem.Content.ReferenceEquals(System.Object,System.Object)">
      <summary>
            Hide method to hide ReferenceEquals from intellisense.
            </summary>
      <param name="objA">The first System.Object to compare.</param>
      <param name="objB">The second System.Object to compare.</param>
      <returns>true if objA is the same instance as objB or if both are null
            references; otherwise, false.</returns>
    </member>
    <member name="F:Delta.ContentSystem.Content.NativeClassObject">
      <summary>
            Link to the disposable and cloneable native class object, which we
            need in case we to clone the native object data. For example Load can
            determinate that two image data content instances should share their
            internal native data for the same atlas image. (see Load method).
            <para />
            Note: This is also used to dispose native data when the content system
            wants to free memory. Each class should implement a reload mechanism
            to ensure the native object can still be used and reloaded after it
            has been disposed (e.g. a texture, a font, etc.)
            </summary>
    </member>
    <member name="F:Delta.ContentSystem.Content.ContentChanged">
      <summary>
            Helper delegate to automatically notify external classes in case a
            content reload is happening here. Basically every time the content
            is loaded and then the Reload method is called, this is called too
            (except for the very first time, which just initializes the data).
            </summary>
    </member>
    <member name="M:Delta.ContentSystem.Content.#ctor(System.String,Delta.ContentSystem.ContentType)">
      <summary>
            The content constructor just searches for the ContentMetaData entry
            with the ContentManager.Add method and links it up for this content
            object (happens in the Reload method actually). Derived classes must
            just implement the Load method plus Clone and Dispose to allow cloning
            and unloading content (usually with custom logic, e.g. textures).
            </summary>
      <param name="setName">
            Name for this content object, should not contain any path, project,
            scene or any special character! If this is empty or starts with an
            &gt; character, we assume this is code generated content
            (e.g. "&gt;IntroScene&lt;" or "") and no loading will happen!
            </param>
      <param name="setType">Type of content to load (image, sound)</param>
    </member>
    <member name="M:Delta.ContentSystem.Content.Dispose">
      <summary>
            Dispose, this makes sure after disposing content we also kill all the
            links to the ContentManager. And we make sure the Data is not longer
            used plus all attached native objects are also disposed when they are
            not longer needed via NativeClassObject.Dispose!
            <para />
            Note: This does not kill the native data directly, instead the
            RemoveThisFromContentManager method is used to check if we can kill
            the native data or not if there are still cloned instances alive.
            <para />
            Also note that almost no content class needs to override this method
            as only the disposing of the native data is critical, the content
            meta data can be ignored and the data class has rarely any resources
            that need disposing for cloned objects (native data still can be
            handled with the DisposeNativeObject event).
            </summary>
    </member>
    <member name="M:Delta.ContentSystem.Content.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> with the class name and the
            content name and type.
            </summary>
      <returns>
            A <see cref="T:System.String" /> with the class name and content type.
            </returns>
    </member>
    <member name="M:Delta.ContentSystem.Content.Reload">
      <summary>
            Load or reload the content. Can be used to reload content and force
            calling Load when the native data is gone after disposing. Also
            important to make sure that we can clone native data like Textures or
            Sounds (so we don't load native resources like atlas images twice).
            </summary>
    </member>
    <member name="M:Delta.ContentSystem.Content.Reload(System.String,Delta.ContentSystem.ContentType,System.Boolean)">
      <summary>
            Load or reload the content, only used internally in the ContentManager
            and from this Content constructor to load the content initially.
            </summary>
      <param name="setName">Content name to load</param>
      <param name="setType">Content type</param>
      <param name="alsoNotifyNativeObjectViaContentChangedEvent">
            This is only set to true if this Reload is called by the
            ContentManager. Then the ContentChanged event is also fired (otherwise
            we would get into trouble with stack overflows if ContentChanged also
            does a Reload like for Texture Loads, where it is required).
            </param>
    </member>
    <member name="M:Delta.ContentSystem.Content.Load(Delta.ContentSystem.Content)">
      <summary>
            Native load data method, can consist of very few lines of code, in
            many cases is just one single line of code trying to load the native
            content. This method should not fail (it is called from the content
            constructor and that would crash then too), instead handle exceptions
            or missing data and load fallback data directly in the content class.
            <para />
            Please note that even while this method is called right away the
            constructor when creating a new content instance via the static Get,
            it does not mean that the native data is loaded right away. Usually it
            is, but for content that needs some time to be initialized like
            textures or sounds, the derived content classes can decide to load
            their native data delayed when it is actually needed (for rendering
            or when first playing it). This has two advantages and a disadvantage.
            First of all it saves a lot of memory and initial loading time, which
            will make your game startup almost instantly. However since content
            is loaded later you might not be so happy about it when the game is
            stuttering while playing until you have all content that you need.
            The solution to this is to use scenes, which solves many things in the
            Content System. Once a scene is opened, all content is pre-loaded the
            first time the scene is getting updated (via Run). This way all the
            content that you create when opening your scene both in the SceneEditor
            and in code (loading levels, textures, music, sounds, etc.) is loaded
            right away, but you still have the option to load more stuff later.
            </summary>
      <param name="alreadyLoadedNativeData">If we already have native data
            loaded, clone it from this instance. Only used if not null. Please
            note that this is only used for other objects that had the same
            RawFileId and are already loaded and returned true for this method.
            </param>
    </member>
    <member name="P:Delta.ContentSystem.Content.Path">
      <summary>
            The content directory path by default is always "Content". All content
            files are stored in that directory or its sub directories, all file
            paths to content are relative to this directory! Note: For the
            ContentManager tool this can be changed to different project names,
            you can use Content.Path or ContentManager.Name property for the current
            name of the content directory (setting it is internal). Note: If these
            properties are different (can only happen in the ContentManager tool)
            then the ContentManager needs to be disposed and restarted with the
            new Content.Path, which is required when switching content projects.
            </summary>
    </member>
    <member name="P:Delta.ContentSystem.Content.TotalNumberOfUsableContentEntries">
      <summary>
            Returns the number of content meta data entries that have been created
            and made available by the content system (server side) and can be used
            in the current project with the current language. For the current
            number of loaded content files use the following properties:
            <see cref="P:Delta.ContentSystem.Content.CurrentlyLoadedContentEntries" /> and
            <see cref="P:Delta.ContentSystem.Content.CurrentlyLoadedContentMemorySize" /></summary>
    </member>
    <member name="P:Delta.ContentSystem.Content.CurrentlyLoadedContentEntries">
      <summary>
            Number of currently loaded content entries (including clones and
            content that links to the same native data, like atlas textures).
            </summary>
    </member>
    <member name="P:Delta.ContentSystem.Content.TotalLoadedContentMemorySize">
      <summary>
            Returns the same size in bytes as CurrentlyLoadedContentMemorySize,
            but instead of a dictionary with the size for each content type, it
            is all added up here to the overall total content memory usage
            currently needed by this application.
            </summary>
    </member>
    <member name="P:Delta.ContentSystem.Content.Name">
      <summary>
            Name of this content file, only for informational purposes, you cannot
            change this outside of the constructor (same as Type)!
            </summary>
    </member>
    <member name="P:Delta.ContentSystem.Content.FailedToLoad">
      <summary>
            Failed to load the native data? In that case the fallback was used and
            as soon as we have new data available we should try to reload. The
            ToString method will also show the failed to load error (good for
            debugging) and the fallback itself is usually visible on screen (e.g.
            image is displayed as a fallback checker map, sounds and music are
            not played, but an error message is shown on the screen, etc.)
            This property is not saved or loaded and it can be set internally or
            by the classes that use this content object (e.g. textures or sounds).
            </summary>
    </member>
    <member name="P:Delta.ContentSystem.Content.RelativeFilePath">
      <summary>
            Returns the relative file path from the application directory to
            find the content, which is just the Content directory + the filename
            we got from ContentMetaData. Some native classes do not need this as
            they load content directly from the LocalFilePath (e.g. XNA).
            </summary>
    </member>
    <member name="P:Delta.ContentSystem.Content.Type">
      <summary>
            ContentType for this content file, only for informational purposes,
            you cannot change this outside of the constructor!
            </summary>
    </member>
    <member name="P:Delta.ContentSystem.Content.MemorySize">
      <summary>
            Native memory size needed for this content object. By default this is
            the file size as most content is just loaded 1:1, but each content
            class can override this and return the actual number of needed bytes.
            For example when compressing or decompressing content or creating
            additional content, this property should return the needed memory size.
            </summary>
    </member>
    <member name="M:Delta.ContentSystem.Xml.XmlData.Get(System.String)">
      <summary>
            This is the only method to load XmlData content. If a content object
            has already been loaded, it will be returned again.
            </summary>
      <param name="contentName">Name of the Xml content to load</param>
      <returns>The loaded XmlData object (or fallback if it failed)</returns>
    </member>
    <member name="M:Delta.ContentSystem.Xml.XmlData.#ctor(System.String,Delta.ContentSystem.ContentType)">
      <summary>
            Pass through constructor for derived classes. XmlData is always
            loaded as soon as possible (which is immediately in this constructor)
            </summary>
      <param name="setName">Name of the set.</param>
      <param name="contentType">Type of the content.</param>
    </member>
    <member name="M:Delta.ContentSystem.Xml.XmlData.#ctor(System.String)">
      <summary>
            Create xml content based on the content system. Loading happens in
            the Load method, all content is loaded right away.
            </summary>
      <param name="setName">Name of the xml content to load.</param>
    </member>
    <member name="M:Delta.ContentSystem.Xml.XmlData.Load(Delta.ContentSystem.Content)">
      <summary>
            Native load method, will just load the xml data.
            </summary>
    </member>
    <member name="P:Delta.ContentSystem.Xml.XmlData.RootNode">
      <summary>
            Xml data, which is loaded in the Load method (via the constructor).
            </summary>
    </member>
    <member name="T:Delta.ContentSystem.Xml.Localization">
      <summary>
            Localization class, which is based on the Localization.xml content file
            that will be loaded via XmlData like every other content file. To use
            this class just access the static methods to get text strings. Image
            localization works automatically via the content system once we switch
            the current language (see Settings.Language). Currently we only care
            about the 5 standard languages: English, German, French, Spanish and
            Italian, but more can easily be added to the content and localization
            file without changing any code (since the language is just a string
            from the Settings.xml).
            </summary>
    </member>
    <member name="F:Delta.ContentSystem.Xml.Localization.English">
      <summary>
            Name for the english (international) content language.
            </summary>
    </member>
    <member name="F:Delta.ContentSystem.Xml.Localization.German">
      <summary>
            Name for the german content language.
            </summary>
    </member>
    <member name="F:Delta.ContentSystem.Xml.Localization.French">
      <summary>
            Name for the french content language.
            </summary>
    </member>
    <member name="F:Delta.ContentSystem.Xml.Localization.Spanish">
      <summary>
            Name for the spanish content language.
            </summary>
    </member>
    <member name="F:Delta.ContentSystem.Xml.Localization.Italian">
      <summary>
            Name for the italian content language.
            </summary>
    </member>
    <member name="M:Delta.ContentSystem.Xml.Localization.Equals(System.Object,System.Object)">
      <summary>
            Equals
            </summary>
      <param name="objA">The <see cref="T:System.Object" /> to compare with this instance.</param>
      <param name="objB">The obj B.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Delta.ContentSystem.Xml.Localization.ReferenceEquals(System.Object,System.Object)">
      <summary>
            Reference equals
            </summary>
      <param name="objA">The obj A.</param>
      <param name="objB">The obj B.</param>
      <returns>True if objects are equal</returns>
    </member>
    <member name="M:Delta.ContentSystem.Xml.Localization.Get(System.String)">
      <summary>
            Get localized string if we have it in the Localization.xml file.
            If you need more precise text strings based on each scene in the game
            use Get(text, sceneName)
            </summary>
      <param name="text">The text.</param>
      <returns>Get string</returns>
    </member>
    <member name="M:Delta.ContentSystem.Xml.Localization.Get(System.String,System.String)">
      <summary>
            Get localized string if we have it in the Localization.xml file.
            If you need more precise text strings based on each scene in the game
            use the optional sceneName parameter!
            </summary>
      <param name="text">The text.</param>
      <param name="sceneName">Name of the scene.</param>
      <returns>Get String</returns>
    </member>
    <member name="T:Delta.ContentSystem.ContentType">
      <summary>
            Content type for ContentData, must be one of the given types here! All
            types except Project have parents and except for Project and Scene they
            all must be in a Scene. See http://deltaengine.net/Wiki.ContentFormats.
            <para />Invalid type (-1) is used for Projects and other negative numbers
            are for direct content project data,
            <para />Scene=0, UIScreen=1, UITheme=2, Level=3,<para />Image=4,
            ImageAnimation=5, Shader=6, Mesh=7, MeshAnimation=8,<para />
            ParticleEffect=9, Font=10,<para />Sound=11, Music=12, Video=13,<para />
            PhysicsCollision=14, Xml=15,<para />JustStore=16 and above 16 for custom
            types (see each IContentPlugin for type numbers, but be aware of type
            number collisions, which need to be avoided for each content project).
            </summary>
    </member>
    <member name="F:Delta.ContentSystem.ContentType.Scene">
      <summary>
            Binary scene content file, created by the SceneEditor and usually
            loaded when creating and opening scenes. Extension is .DeltaScene.
            This class is managed by the Delta.Scenes.Scene class and all content
            is sorted by projects first and then by Scenes. This is important for
            optimizations, streaming, generating content and reducing how much
            content needs to be loaded for each game scene.
            <para />
            For this reason you will always be forced to create a scene and
            a project first before you can important content. Using content
            however is very easy, you can use whatever content from all projects
            and scenes in all other projects and scenes (content from each scene
            is however always preferred if you have the same content name).
            </summary>
    </member>
    <member name="F:Delta.ContentSystem.ContentType.Sound">
      <summary>
            Sound file for sound playback, just a .wav file on most platforms.
            Any format can be used for importing, the processed sound file might
            however differ greatly in terms of quality (hz, stereo, bit-rate).
            Modify your project content quality settings to change how sound files
            are processed.
            </summary>
    </member>
    <member name="F:Delta.ContentSystem.ContentType.Music">
      <summary>
            Music file for playing in the background or even use streaming.
            This is just an .mp3 file (or .ogg for OpenTK platforms), but it can
            also be imported from a .wav file.
            </summary>
    </member>
    <member name="F:Delta.ContentSystem.ContentType.Video">
      <summary>
            Video file for multimedia. Supports .mp4 video files for many mobile
            platforms (iOS, Android)! iPhone uses .m4v, which is the same as .mp4.
            .wmv is used fo WP7. All the decissions are made on the server side!
            </summary>
    </member>
    <member name="T:Delta.ContentSystem.EmptySceneData">
      <summary>
            Empty scene data fallback class that does not contain any data, it is just
            the fallback to make projects without scenes work. Normally you would use
            SceneData, which loads all the required data for a scene.
            <para />
            Most importantly we always have only one scene active. All content that
            is loaded during the time that scene is open will automatically be
            disposed when closing the scene. This way we can open new scenes and
            make sure all content from the previous scenes has been unloaded. If
            you load new scenes while the old one is still open (stack add), you can
            load additional content, but nothing gets disposed automatically.
            <para />
            Note: This class is not publicly available and only used as fallback
            internally. However it is also the base class for SceneData in the
            Delta.ContentSystem.UserInterfaces namespace. SceneData is used in the
            sealed and protected Scene class (in Delta.Scenes).
            </summary>
    </member>
    <member name="M:Delta.ContentSystem.EmptySceneData.#ctor(System.String)">
      <summary>
            Create scene content based on the content system. Loading happens in
            the Load method, all content is loaded right away.
            </summary>
      <param name="setName">Name of the scene name to load.</param>
    </member>
    <member name="M:Delta.ContentSystem.EmptySceneData.Dispose">
      <summary>
            Dispose native data, which is called when the content system wants
            to free up some memory. This does NOT mean the whole content is
            disposed, this only happens if all instances of the used native
            content are released (we keep track of this in the ContentManager).
            Use the RemoveThisFromContentManager method to check if we can kill
            the native data or not.
            </summary>
    </member>
    <member name="M:Delta.ContentSystem.EmptySceneData.Load(Delta.ContentSystem.Content)">
      <summary>
            Native load method, will load all the scene data. This method does
            nothing here except setting currentScene. This class must be derived
            and all functionality must be implemented in the derived class.
            </summary>
      <param name="alreadyLoadedNativeData">Not used here</param>
    </member>
    <member name="P:Delta.ContentSystem.EmptySceneData.Current">
      <summary>
            By default the empty project scene is set (it is also set when no
            other scene is set anymore and Dispose was called from the last one).
            Each scene can have children and a parent.
            </summary>
    </member>
  </members>
</doc>